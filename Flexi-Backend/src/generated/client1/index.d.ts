
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model BusinessAcc
 * 
 */
export type BusinessAcc = $Result.DefaultSelection<Prisma.$BusinessAccPayload>
/**
 * Model Bill
 * 
 */
export type Bill = $Result.DefaultSelection<Prisma.$BillPayload>
/**
 * Model AdsCost
 * 
 */
export type AdsCost = $Result.DefaultSelection<Prisma.$AdsCostPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model Platform
 * 
 */
export type Platform = $Result.DefaultSelection<Prisma.$PlatformPayload>
/**
 * Model Store
 * 
 */
export type Store = $Result.DefaultSelection<Prisma.$StorePayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Credit
 * 
 */
export type Credit = $Result.DefaultSelection<Prisma.$CreditPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Reaction
 * 
 */
export type Reaction = $Result.DefaultSelection<Prisma.$ReactionPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Inbox
 * 
 */
export type Inbox = $Result.DefaultSelection<Prisma.$InboxPayload>
/**
 * Model Shop
 * 
 */
export type Shop = $Result.DefaultSelection<Prisma.$ShopPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Option
 * 
 */
export type Option = $Result.DefaultSelection<Prisma.$OptionPayload>
/**
 * Model OptionValue
 * 
 */
export type OptionValue = $Result.DefaultSelection<Prisma.$OptionValuePayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Cart
 * 
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  owner: 'owner',
  marketing: 'marketing',
  accountant: 'accountant',
  sales: 'sales'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const taxType: {
  Juristic: 'Juristic',
  Individual: 'Individual'
};

export type taxType = (typeof taxType)[keyof typeof taxType]


export const Gender: {
  Female: 'Female',
  Male: 'Male'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const Payment: {
  COD: 'COD',
  Transfer: 'Transfer',
  CreditCard: 'CreditCard'
};

export type Payment = (typeof Payment)[keyof typeof Payment]


export const SocialMedia: {
  Facebook: 'Facebook',
  Line: 'Line',
  Tiktok: 'Tiktok',
  Shopee: 'Shopee',
  Lazada: 'Lazada',
  Instagram: 'Instagram',
  X: 'X',
  Youtube: 'Youtube',
  Google: 'Google'
};

export type SocialMedia = (typeof SocialMedia)[keyof typeof SocialMedia]


export const IncomeChannel: {
  Storefornt: 'Storefornt',
  Facebook: 'Facebook',
  Line: 'Line',
  Tiktok: 'Tiktok',
  Shopee: 'Shopee',
  Lazada: 'Lazada',
  Instagram: 'Instagram',
  X: 'X',
  Youtube: 'Youtube',
  Google: 'Google',
  SCB: 'SCB',
  KBANK: 'KBANK',
  KTB: 'KTB',
  BBL: 'BBL',
  TMB: 'TMB'
};

export type IncomeChannel = (typeof IncomeChannel)[keyof typeof IncomeChannel]


export const Bank: {
  SCB: 'SCB',
  KBANK: 'KBANK',
  KTB: 'KTB',
  BBL: 'BBL',
  TMB: 'TMB'
};

export type Bank = (typeof Bank)[keyof typeof Bank]


export const BusinessType: {
  OnlineSale: 'OnlineSale',
  Massage: 'Massage',
  Restaurant: 'Restaurant',
  Bar: 'Bar',
  Cafe: 'Cafe',
  Hotel: 'Hotel',
  Tutor: 'Tutor',
  Influencer: 'Influencer',
  Other: 'Other'
};

export type BusinessType = (typeof BusinessType)[keyof typeof BusinessType]


export const MediaType: {
  VIDEO: 'VIDEO',
  IMAGE: 'IMAGE'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const ReactionType: {
  CREDIT: 'CREDIT',
  SPARK: 'SPARK',
  DISCREDIT: 'DISCREDIT'
};

export type ReactionType = (typeof ReactionType)[keyof typeof ReactionType]


export const Category: {
  Loan: 'Loan',
  Coaching: 'Coaching',
  OEM: 'OEM',
  MarketingAgency: 'MarketingAgency',
  Packaging: 'Packaging',
  accountant: 'accountant',
  Inventory: 'Inventory'
};

export type Category = (typeof Category)[keyof typeof Category]


export const ProductType: {
  Service: 'Service',
  Product: 'Product'
};

export type ProductType = (typeof ProductType)[keyof typeof ProductType]


export const OptionName: {
  Size: 'Size',
  Color: 'Color',
  Material: 'Material',
  Flavor: 'Flavor',
  CreditLimit: 'CreditLimit',
  QuantityLimit: 'QuantityLimit'
};

export type OptionName = (typeof OptionName)[keyof typeof OptionName]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type taxType = $Enums.taxType

export const taxType: typeof $Enums.taxType

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type Payment = $Enums.Payment

export const Payment: typeof $Enums.Payment

export type SocialMedia = $Enums.SocialMedia

export const SocialMedia: typeof $Enums.SocialMedia

export type IncomeChannel = $Enums.IncomeChannel

export const IncomeChannel: typeof $Enums.IncomeChannel

export type Bank = $Enums.Bank

export const Bank: typeof $Enums.Bank

export type BusinessType = $Enums.BusinessType

export const BusinessType: typeof $Enums.BusinessType

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type ReactionType = $Enums.ReactionType

export const ReactionType: typeof $Enums.ReactionType

export type Category = $Enums.Category

export const Category: typeof $Enums.Category

export type ProductType = $Enums.ProductType

export const ProductType: typeof $Enums.ProductType

export type OptionName = $Enums.OptionName

export const OptionName: typeof $Enums.OptionName

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.businessAcc`: Exposes CRUD operations for the **BusinessAcc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessAccs
    * const businessAccs = await prisma.businessAcc.findMany()
    * ```
    */
  get businessAcc(): Prisma.BusinessAccDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bill`: Exposes CRUD operations for the **Bill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bills
    * const bills = await prisma.bill.findMany()
    * ```
    */
  get bill(): Prisma.BillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adsCost`: Exposes CRUD operations for the **AdsCost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdsCosts
    * const adsCosts = await prisma.adsCost.findMany()
    * ```
    */
  get adsCost(): Prisma.AdsCostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platform`: Exposes CRUD operations for the **Platform** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Platforms
    * const platforms = await prisma.platform.findMany()
    * ```
    */
  get platform(): Prisma.PlatformDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.store`: Exposes CRUD operations for the **Store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.StoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.credit`: Exposes CRUD operations for the **Credit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credits
    * const credits = await prisma.credit.findMany()
    * ```
    */
  get credit(): Prisma.CreditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reaction`: Exposes CRUD operations for the **Reaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reactions
    * const reactions = await prisma.reaction.findMany()
    * ```
    */
  get reaction(): Prisma.ReactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inbox`: Exposes CRUD operations for the **Inbox** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inboxes
    * const inboxes = await prisma.inbox.findMany()
    * ```
    */
  get inbox(): Prisma.InboxDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shop`: Exposes CRUD operations for the **Shop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shops
    * const shops = await prisma.shop.findMany()
    * ```
    */
  get shop(): Prisma.ShopDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.option`: Exposes CRUD operations for the **Option** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Options
    * const options = await prisma.option.findMany()
    * ```
    */
  get option(): Prisma.OptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.optionValue`: Exposes CRUD operations for the **OptionValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OptionValues
    * const optionValues = await prisma.optionValue.findMany()
    * ```
    */
  get optionValue(): Prisma.OptionValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.CartDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Member: 'Member',
    BusinessAcc: 'BusinessAcc',
    Bill: 'Bill',
    AdsCost: 'AdsCost',
    Expense: 'Expense',
    Platform: 'Platform',
    Store: 'Store',
    Product: 'Product',
    Credit: 'Credit',
    Post: 'Post',
    Reaction: 'Reaction',
    Comment: 'Comment',
    Inbox: 'Inbox',
    Shop: 'Shop',
    Order: 'Order',
    Option: 'Option',
    OptionValue: 'OptionValue',
    Review: 'Review',
    Cart: 'Cart'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "member" | "businessAcc" | "bill" | "adsCost" | "expense" | "platform" | "store" | "product" | "credit" | "post" | "reaction" | "comment" | "inbox" | "shop" | "order" | "option" | "optionValue" | "review" | "cart"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      BusinessAcc: {
        payload: Prisma.$BusinessAccPayload<ExtArgs>
        fields: Prisma.BusinessAccFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessAccFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAccPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessAccFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAccPayload>
          }
          findFirst: {
            args: Prisma.BusinessAccFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAccPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessAccFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAccPayload>
          }
          findMany: {
            args: Prisma.BusinessAccFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAccPayload>[]
          }
          create: {
            args: Prisma.BusinessAccCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAccPayload>
          }
          createMany: {
            args: Prisma.BusinessAccCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessAccCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAccPayload>[]
          }
          delete: {
            args: Prisma.BusinessAccDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAccPayload>
          }
          update: {
            args: Prisma.BusinessAccUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAccPayload>
          }
          deleteMany: {
            args: Prisma.BusinessAccDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessAccUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessAccUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAccPayload>[]
          }
          upsert: {
            args: Prisma.BusinessAccUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAccPayload>
          }
          aggregate: {
            args: Prisma.BusinessAccAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessAcc>
          }
          groupBy: {
            args: Prisma.BusinessAccGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessAccGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessAccCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessAccCountAggregateOutputType> | number
          }
        }
      }
      Bill: {
        payload: Prisma.$BillPayload<ExtArgs>
        fields: Prisma.BillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findFirst: {
            args: Prisma.BillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findMany: {
            args: Prisma.BillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          create: {
            args: Prisma.BillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          createMany: {
            args: Prisma.BillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          delete: {
            args: Prisma.BillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          update: {
            args: Prisma.BillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          deleteMany: {
            args: Prisma.BillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          upsert: {
            args: Prisma.BillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          aggregate: {
            args: Prisma.BillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBill>
          }
          groupBy: {
            args: Prisma.BillGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillCountArgs<ExtArgs>
            result: $Utils.Optional<BillCountAggregateOutputType> | number
          }
        }
      }
      AdsCost: {
        payload: Prisma.$AdsCostPayload<ExtArgs>
        fields: Prisma.AdsCostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdsCostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsCostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdsCostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsCostPayload>
          }
          findFirst: {
            args: Prisma.AdsCostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsCostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdsCostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsCostPayload>
          }
          findMany: {
            args: Prisma.AdsCostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsCostPayload>[]
          }
          create: {
            args: Prisma.AdsCostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsCostPayload>
          }
          createMany: {
            args: Prisma.AdsCostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdsCostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsCostPayload>[]
          }
          delete: {
            args: Prisma.AdsCostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsCostPayload>
          }
          update: {
            args: Prisma.AdsCostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsCostPayload>
          }
          deleteMany: {
            args: Prisma.AdsCostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdsCostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdsCostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsCostPayload>[]
          }
          upsert: {
            args: Prisma.AdsCostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsCostPayload>
          }
          aggregate: {
            args: Prisma.AdsCostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdsCost>
          }
          groupBy: {
            args: Prisma.AdsCostGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdsCostGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdsCostCountArgs<ExtArgs>
            result: $Utils.Optional<AdsCostCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      Platform: {
        payload: Prisma.$PlatformPayload<ExtArgs>
        fields: Prisma.PlatformFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          findFirst: {
            args: Prisma.PlatformFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          findMany: {
            args: Prisma.PlatformFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>[]
          }
          create: {
            args: Prisma.PlatformCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          createMany: {
            args: Prisma.PlatformCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>[]
          }
          delete: {
            args: Prisma.PlatformDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          update: {
            args: Prisma.PlatformUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          deleteMany: {
            args: Prisma.PlatformDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlatformUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>[]
          }
          upsert: {
            args: Prisma.PlatformUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          aggregate: {
            args: Prisma.PlatformAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatform>
          }
          groupBy: {
            args: Prisma.PlatformGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformCountAggregateOutputType> | number
          }
        }
      }
      Store: {
        payload: Prisma.$StorePayload<ExtArgs>
        fields: Prisma.StoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findFirst: {
            args: Prisma.StoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findMany: {
            args: Prisma.StoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          create: {
            args: Prisma.StoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          createMany: {
            args: Prisma.StoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          delete: {
            args: Prisma.StoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          update: {
            args: Prisma.StoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          deleteMany: {
            args: Prisma.StoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          upsert: {
            args: Prisma.StoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          aggregate: {
            args: Prisma.StoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStore>
          }
          groupBy: {
            args: Prisma.StoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreCountArgs<ExtArgs>
            result: $Utils.Optional<StoreCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Credit: {
        payload: Prisma.$CreditPayload<ExtArgs>
        fields: Prisma.CreditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPayload>
          }
          findFirst: {
            args: Prisma.CreditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPayload>
          }
          findMany: {
            args: Prisma.CreditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPayload>[]
          }
          create: {
            args: Prisma.CreditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPayload>
          }
          createMany: {
            args: Prisma.CreditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPayload>[]
          }
          delete: {
            args: Prisma.CreditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPayload>
          }
          update: {
            args: Prisma.CreditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPayload>
          }
          deleteMany: {
            args: Prisma.CreditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPayload>[]
          }
          upsert: {
            args: Prisma.CreditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPayload>
          }
          aggregate: {
            args: Prisma.CreditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredit>
          }
          groupBy: {
            args: Prisma.CreditGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditCountArgs<ExtArgs>
            result: $Utils.Optional<CreditCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Reaction: {
        payload: Prisma.$ReactionPayload<ExtArgs>
        fields: Prisma.ReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          findFirst: {
            args: Prisma.ReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          findMany: {
            args: Prisma.ReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          create: {
            args: Prisma.ReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          createMany: {
            args: Prisma.ReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          delete: {
            args: Prisma.ReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          update: {
            args: Prisma.ReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          deleteMany: {
            args: Prisma.ReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          upsert: {
            args: Prisma.ReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          aggregate: {
            args: Prisma.ReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReaction>
          }
          groupBy: {
            args: Prisma.ReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReactionCountArgs<ExtArgs>
            result: $Utils.Optional<ReactionCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Inbox: {
        payload: Prisma.$InboxPayload<ExtArgs>
        fields: Prisma.InboxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InboxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InboxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboxPayload>
          }
          findFirst: {
            args: Prisma.InboxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InboxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboxPayload>
          }
          findMany: {
            args: Prisma.InboxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboxPayload>[]
          }
          create: {
            args: Prisma.InboxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboxPayload>
          }
          createMany: {
            args: Prisma.InboxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InboxCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboxPayload>[]
          }
          delete: {
            args: Prisma.InboxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboxPayload>
          }
          update: {
            args: Prisma.InboxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboxPayload>
          }
          deleteMany: {
            args: Prisma.InboxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InboxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InboxUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboxPayload>[]
          }
          upsert: {
            args: Prisma.InboxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboxPayload>
          }
          aggregate: {
            args: Prisma.InboxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInbox>
          }
          groupBy: {
            args: Prisma.InboxGroupByArgs<ExtArgs>
            result: $Utils.Optional<InboxGroupByOutputType>[]
          }
          count: {
            args: Prisma.InboxCountArgs<ExtArgs>
            result: $Utils.Optional<InboxCountAggregateOutputType> | number
          }
        }
      }
      Shop: {
        payload: Prisma.$ShopPayload<ExtArgs>
        fields: Prisma.ShopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findFirst: {
            args: Prisma.ShopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findMany: {
            args: Prisma.ShopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          create: {
            args: Prisma.ShopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          createMany: {
            args: Prisma.ShopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          delete: {
            args: Prisma.ShopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          update: {
            args: Prisma.ShopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          deleteMany: {
            args: Prisma.ShopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShopUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          upsert: {
            args: Prisma.ShopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          aggregate: {
            args: Prisma.ShopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShop>
          }
          groupBy: {
            args: Prisma.ShopGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopCountArgs<ExtArgs>
            result: $Utils.Optional<ShopCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Option: {
        payload: Prisma.$OptionPayload<ExtArgs>
        fields: Prisma.OptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          findFirst: {
            args: Prisma.OptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          findMany: {
            args: Prisma.OptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>[]
          }
          create: {
            args: Prisma.OptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          createMany: {
            args: Prisma.OptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>[]
          }
          delete: {
            args: Prisma.OptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          update: {
            args: Prisma.OptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          deleteMany: {
            args: Prisma.OptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>[]
          }
          upsert: {
            args: Prisma.OptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          aggregate: {
            args: Prisma.OptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOption>
          }
          groupBy: {
            args: Prisma.OptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OptionCountArgs<ExtArgs>
            result: $Utils.Optional<OptionCountAggregateOutputType> | number
          }
        }
      }
      OptionValue: {
        payload: Prisma.$OptionValuePayload<ExtArgs>
        fields: Prisma.OptionValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OptionValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OptionValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionValuePayload>
          }
          findFirst: {
            args: Prisma.OptionValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OptionValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionValuePayload>
          }
          findMany: {
            args: Prisma.OptionValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionValuePayload>[]
          }
          create: {
            args: Prisma.OptionValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionValuePayload>
          }
          createMany: {
            args: Prisma.OptionValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OptionValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionValuePayload>[]
          }
          delete: {
            args: Prisma.OptionValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionValuePayload>
          }
          update: {
            args: Prisma.OptionValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionValuePayload>
          }
          deleteMany: {
            args: Prisma.OptionValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OptionValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OptionValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionValuePayload>[]
          }
          upsert: {
            args: Prisma.OptionValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionValuePayload>
          }
          aggregate: {
            args: Prisma.OptionValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOptionValue>
          }
          groupBy: {
            args: Prisma.OptionValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<OptionValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.OptionValueCountArgs<ExtArgs>
            result: $Utils.Optional<OptionValueCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Cart: {
        payload: Prisma.$CartPayload<ExtArgs>
        fields: Prisma.CartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartCountArgs<ExtArgs>
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    member?: MemberOmit
    businessAcc?: BusinessAccOmit
    bill?: BillOmit
    adsCost?: AdsCostOmit
    expense?: ExpenseOmit
    platform?: PlatformOmit
    store?: StoreOmit
    product?: ProductOmit
    credit?: CreditOmit
    post?: PostOmit
    reaction?: ReactionOmit
    comment?: CommentOmit
    inbox?: InboxOmit
    shop?: ShopOmit
    order?: OrderOmit
    option?: OptionOmit
    optionValue?: OptionValueOmit
    review?: ReviewOmit
    cart?: CartOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    business: number
    member: number
    posts: number
    comments: number
    reactions: number
    sentMessages: number
    receivedMessages: number
    seller: number
    buyer: number
    Order: number
    review: number
    owner: number
    credit: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | UserCountOutputTypeCountBusinessArgs
    member?: boolean | UserCountOutputTypeCountMemberArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    reactions?: boolean | UserCountOutputTypeCountReactionsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    seller?: boolean | UserCountOutputTypeCountSellerArgs
    buyer?: boolean | UserCountOutputTypeCountBuyerArgs
    Order?: boolean | UserCountOutputTypeCountOrderArgs
    review?: boolean | UserCountOutputTypeCountReviewArgs
    owner?: boolean | UserCountOutputTypeCountOwnerArgs
    credit?: boolean | UserCountOutputTypeCountCreditArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBusinessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessAccWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InboxWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InboxWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSellerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBuyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditWhereInput
  }


  /**
   * Count Type MemberCountOutputType
   */

  export type MemberCountOutputType = {
    bill: number
    adsCost: number
    expense: number
    product: number
    platform: number
    store: number
  }

  export type MemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | MemberCountOutputTypeCountBillArgs
    adsCost?: boolean | MemberCountOutputTypeCountAdsCostArgs
    expense?: boolean | MemberCountOutputTypeCountExpenseArgs
    product?: boolean | MemberCountOutputTypeCountProductArgs
    platform?: boolean | MemberCountOutputTypeCountPlatformArgs
    store?: boolean | MemberCountOutputTypeCountStoreArgs
  }

  // Custom InputTypes
  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCountOutputType
     */
    select?: MemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountBillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountAdsCostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdsCostWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountPlatformArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
  }


  /**
   * Count Type BusinessAccCountOutputType
   */

  export type BusinessAccCountOutputType = {
    AllMember: number
    billRecord: number
    expenseRecord: number
    adsCostRecord: number
    platform: number
    storefront: number
    product: number
  }

  export type BusinessAccCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AllMember?: boolean | BusinessAccCountOutputTypeCountAllMemberArgs
    billRecord?: boolean | BusinessAccCountOutputTypeCountBillRecordArgs
    expenseRecord?: boolean | BusinessAccCountOutputTypeCountExpenseRecordArgs
    adsCostRecord?: boolean | BusinessAccCountOutputTypeCountAdsCostRecordArgs
    platform?: boolean | BusinessAccCountOutputTypeCountPlatformArgs
    storefront?: boolean | BusinessAccCountOutputTypeCountStorefrontArgs
    product?: boolean | BusinessAccCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * BusinessAccCountOutputType without action
   */
  export type BusinessAccCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAccCountOutputType
     */
    select?: BusinessAccCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessAccCountOutputType without action
   */
  export type BusinessAccCountOutputTypeCountAllMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * BusinessAccCountOutputType without action
   */
  export type BusinessAccCountOutputTypeCountBillRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }

  /**
   * BusinessAccCountOutputType without action
   */
  export type BusinessAccCountOutputTypeCountExpenseRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * BusinessAccCountOutputType without action
   */
  export type BusinessAccCountOutputTypeCountAdsCostRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdsCostWhereInput
  }

  /**
   * BusinessAccCountOutputType without action
   */
  export type BusinessAccCountOutputTypeCountPlatformArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformWhereInput
  }

  /**
   * BusinessAccCountOutputType without action
   */
  export type BusinessAccCountOutputTypeCountStorefrontArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
  }

  /**
   * BusinessAccCountOutputType without action
   */
  export type BusinessAccCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type PlatformCountOutputType
   */

  export type PlatformCountOutputType = {
    platformId: number
  }

  export type PlatformCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platformId?: boolean | PlatformCountOutputTypeCountPlatformIdArgs
  }

  // Custom InputTypes
  /**
   * PlatformCountOutputType without action
   */
  export type PlatformCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformCountOutputType
     */
    select?: PlatformCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlatformCountOutputType without action
   */
  export type PlatformCountOutputTypeCountPlatformIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdsCostWhereInput
  }


  /**
   * Count Type StoreCountOutputType
   */

  export type StoreCountOutputType = {
    storefrontId: number
  }

  export type StoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storefrontId?: boolean | StoreCountOutputTypeCountStorefrontIdArgs
  }

  // Custom InputTypes
  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCountOutputType
     */
    select?: StoreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountStorefrontIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    billRecord: number
    adsRecord: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billRecord?: boolean | ProductCountOutputTypeCountBillRecordArgs
    adsRecord?: boolean | ProductCountOutputTypeCountAdsRecordArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBillRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountAdsRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdsCostWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    reactions: number
    comments: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reactions?: boolean | PostCountOutputTypeCountReactionsArgs
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type ShopCountOutputType
   */

  export type ShopCountOutputType = {
    options: number
    review: number
  }

  export type ShopCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | ShopCountOutputTypeCountOptionsArgs
    review?: boolean | ShopCountOutputTypeCountReviewArgs
  }

  // Custom InputTypes
  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCountOutputType
     */
    select?: ShopCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptionWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type OptionCountOutputType
   */

  export type OptionCountOutputType = {
    values: number
  }

  export type OptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | OptionCountOutputTypeCountValuesArgs
  }

  // Custom InputTypes
  /**
   * OptionCountOutputType without action
   */
  export type OptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionCountOutputType
     */
    select?: OptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OptionCountOutputType without action
   */
  export type OptionCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptionValueWhereInput
  }


  /**
   * Count Type CartCountOutputType
   */

  export type CartCountOutputType = {
    order: number
  }

  export type CartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | CartCountOutputTypeCountOrderArgs
  }

  // Custom InputTypes
  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartCountOutputType
     */
    select?: CartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
    phone: string | null
    username: string | null
    bio: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
    phone: string | null
    username: string | null
    bio: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    avatar: number
    createdAt: number
    updatedAt: number
    phone: number
    username: number
    bio: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    phone?: true
    username?: true
    bio?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    phone?: true
    username?: true
    bio?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    phone?: true
    username?: true
    bio?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar: string | null
    createdAt: Date
    updatedAt: Date
    phone: string
    username: string | null
    bio: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phone?: boolean
    username?: boolean
    bio?: boolean
    business?: boolean | User$businessArgs<ExtArgs>
    member?: boolean | User$memberArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    reactions?: boolean | User$reactionsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    seller?: boolean | User$sellerArgs<ExtArgs>
    buyer?: boolean | User$buyerArgs<ExtArgs>
    Order?: boolean | User$OrderArgs<ExtArgs>
    review?: boolean | User$reviewArgs<ExtArgs>
    owner?: boolean | User$ownerArgs<ExtArgs>
    credit?: boolean | User$creditArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phone?: boolean
    username?: boolean
    bio?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phone?: boolean
    username?: boolean
    bio?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phone?: boolean
    username?: boolean
    bio?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "firstName" | "lastName" | "avatar" | "createdAt" | "updatedAt" | "phone" | "username" | "bio", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | User$businessArgs<ExtArgs>
    member?: boolean | User$memberArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    reactions?: boolean | User$reactionsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    seller?: boolean | User$sellerArgs<ExtArgs>
    buyer?: boolean | User$buyerArgs<ExtArgs>
    Order?: boolean | User$OrderArgs<ExtArgs>
    review?: boolean | User$reviewArgs<ExtArgs>
    owner?: boolean | User$ownerArgs<ExtArgs>
    credit?: boolean | User$creditArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      business: Prisma.$BusinessAccPayload<ExtArgs>[]
      member: Prisma.$MemberPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      reactions: Prisma.$ReactionPayload<ExtArgs>[]
      sentMessages: Prisma.$InboxPayload<ExtArgs>[]
      receivedMessages: Prisma.$InboxPayload<ExtArgs>[]
      seller: Prisma.$ShopPayload<ExtArgs>[]
      buyer: Prisma.$ShopPayload<ExtArgs>[]
      Order: Prisma.$OrderPayload<ExtArgs>[]
      review: Prisma.$ReviewPayload<ExtArgs>[]
      owner: Prisma.$CreditPayload<ExtArgs>[]
      credit: Prisma.$CreditPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      firstName: string
      lastName: string
      avatar: string | null
      createdAt: Date
      updatedAt: Date
      phone: string
      username: string | null
      bio: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends User$businessArgs<ExtArgs> = {}>(args?: Subset<T, User$businessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    member<T extends User$memberArgs<ExtArgs> = {}>(args?: Subset<T, User$memberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reactions<T extends User$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InboxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InboxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seller<T extends User$sellerArgs<ExtArgs> = {}>(args?: Subset<T, User$sellerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buyer<T extends User$buyerArgs<ExtArgs> = {}>(args?: Subset<T, User$buyerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Order<T extends User$OrderArgs<ExtArgs> = {}>(args?: Subset<T, User$OrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    review<T extends User$reviewArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    owner<T extends User$ownerArgs<ExtArgs> = {}>(args?: Subset<T, User$ownerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    credit<T extends User$creditArgs<ExtArgs> = {}>(args?: Subset<T, User$creditArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly phone: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.business
   */
  export type User$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAcc
     */
    select?: BusinessAccSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessAcc
     */
    omit?: BusinessAccOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAccInclude<ExtArgs> | null
    where?: BusinessAccWhereInput
    orderBy?: BusinessAccOrderByWithRelationInput | BusinessAccOrderByWithRelationInput[]
    cursor?: BusinessAccWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessAccScalarFieldEnum | BusinessAccScalarFieldEnum[]
  }

  /**
   * User.member
   */
  export type User$memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.reactions
   */
  export type User$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    cursor?: ReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inbox
     */
    select?: InboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inbox
     */
    omit?: InboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboxInclude<ExtArgs> | null
    where?: InboxWhereInput
    orderBy?: InboxOrderByWithRelationInput | InboxOrderByWithRelationInput[]
    cursor?: InboxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InboxScalarFieldEnum | InboxScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inbox
     */
    select?: InboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inbox
     */
    omit?: InboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboxInclude<ExtArgs> | null
    where?: InboxWhereInput
    orderBy?: InboxOrderByWithRelationInput | InboxOrderByWithRelationInput[]
    cursor?: InboxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InboxScalarFieldEnum | InboxScalarFieldEnum[]
  }

  /**
   * User.seller
   */
  export type User$sellerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    cursor?: ShopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * User.buyer
   */
  export type User$buyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    cursor?: ShopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * User.Order
   */
  export type User$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.review
   */
  export type User$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.owner
   */
  export type User$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credit
     */
    omit?: CreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditInclude<ExtArgs> | null
    where?: CreditWhereInput
    orderBy?: CreditOrderByWithRelationInput | CreditOrderByWithRelationInput[]
    cursor?: CreditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditScalarFieldEnum | CreditScalarFieldEnum[]
  }

  /**
   * User.credit
   */
  export type User$creditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credit
     */
    omit?: CreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditInclude<ExtArgs> | null
    where?: CreditWhereInput
    orderBy?: CreditOrderByWithRelationInput | CreditOrderByWithRelationInput[]
    cursor?: CreditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditScalarFieldEnum | CreditScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberAvgAggregateOutputType = {
    userId: number | null
    businessId: number | null
  }

  export type MemberSumAggregateOutputType = {
    userId: number | null
    businessId: number | null
  }

  export type MemberMinAggregateOutputType = {
    uniqueId: string | null
    role: $Enums.UserRole | null
    permission: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    businessId: number | null
  }

  export type MemberMaxAggregateOutputType = {
    uniqueId: string | null
    role: $Enums.UserRole | null
    permission: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    businessId: number | null
  }

  export type MemberCountAggregateOutputType = {
    uniqueId: number
    role: number
    permission: number
    createdAt: number
    updatedAt: number
    userId: number
    businessId: number
    _all: number
  }


  export type MemberAvgAggregateInputType = {
    userId?: true
    businessId?: true
  }

  export type MemberSumAggregateInputType = {
    userId?: true
    businessId?: true
  }

  export type MemberMinAggregateInputType = {
    uniqueId?: true
    role?: true
    permission?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    businessId?: true
  }

  export type MemberMaxAggregateInputType = {
    uniqueId?: true
    role?: true
    permission?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    businessId?: true
  }

  export type MemberCountAggregateInputType = {
    uniqueId?: true
    role?: true
    permission?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    businessId?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _avg?: MemberAvgAggregateInputType
    _sum?: MemberSumAggregateInputType
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    uniqueId: string
    role: $Enums.UserRole
    permission: string
    createdAt: Date
    updatedAt: Date
    userId: number
    businessId: number | null
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uniqueId?: boolean
    role?: boolean
    permission?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    businessId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    business?: boolean | Member$businessArgs<ExtArgs>
    bill?: boolean | Member$billArgs<ExtArgs>
    adsCost?: boolean | Member$adsCostArgs<ExtArgs>
    expense?: boolean | Member$expenseArgs<ExtArgs>
    product?: boolean | Member$productArgs<ExtArgs>
    platform?: boolean | Member$platformArgs<ExtArgs>
    store?: boolean | Member$storeArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uniqueId?: boolean
    role?: boolean
    permission?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    businessId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    business?: boolean | Member$businessArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uniqueId?: boolean
    role?: boolean
    permission?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    businessId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    business?: boolean | Member$businessArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    uniqueId?: boolean
    role?: boolean
    permission?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    businessId?: boolean
  }

  export type MemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uniqueId" | "role" | "permission" | "createdAt" | "updatedAt" | "userId" | "businessId", ExtArgs["result"]["member"]>
  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    business?: boolean | Member$businessArgs<ExtArgs>
    bill?: boolean | Member$billArgs<ExtArgs>
    adsCost?: boolean | Member$adsCostArgs<ExtArgs>
    expense?: boolean | Member$expenseArgs<ExtArgs>
    product?: boolean | Member$productArgs<ExtArgs>
    platform?: boolean | Member$platformArgs<ExtArgs>
    store?: boolean | Member$storeArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    business?: boolean | Member$businessArgs<ExtArgs>
  }
  export type MemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    business?: boolean | Member$businessArgs<ExtArgs>
  }

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      business: Prisma.$BusinessAccPayload<ExtArgs> | null
      bill: Prisma.$BillPayload<ExtArgs>[]
      adsCost: Prisma.$AdsCostPayload<ExtArgs>[]
      expense: Prisma.$ExpensePayload<ExtArgs>[]
      product: Prisma.$ProductPayload<ExtArgs>[]
      platform: Prisma.$PlatformPayload<ExtArgs>[]
      store: Prisma.$StorePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uniqueId: string
      role: $Enums.UserRole
      permission: string
      createdAt: Date
      updatedAt: Date
      userId: number
      businessId: number | null
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `uniqueId`
     * const memberWithUniqueIdOnly = await prisma.member.findMany({ select: { uniqueId: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `uniqueId`
     * const memberWithUniqueIdOnly = await prisma.member.createManyAndReturn({
     *   select: { uniqueId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members and returns the data updated in the database.
     * @param {MemberUpdateManyAndReturnArgs} args - Arguments to update many Members.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Members and only return the `uniqueId`
     * const memberWithUniqueIdOnly = await prisma.member.updateManyAndReturn({
     *   select: { uniqueId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    business<T extends Member$businessArgs<ExtArgs> = {}>(args?: Subset<T, Member$businessArgs<ExtArgs>>): Prisma__BusinessAccClient<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bill<T extends Member$billArgs<ExtArgs> = {}>(args?: Subset<T, Member$billArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adsCost<T extends Member$adsCostArgs<ExtArgs> = {}>(args?: Subset<T, Member$adsCostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expense<T extends Member$expenseArgs<ExtArgs> = {}>(args?: Subset<T, Member$expenseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    product<T extends Member$productArgs<ExtArgs> = {}>(args?: Subset<T, Member$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    platform<T extends Member$platformArgs<ExtArgs> = {}>(args?: Subset<T, Member$platformArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    store<T extends Member$storeArgs<ExtArgs> = {}>(args?: Subset<T, Member$storeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */
  interface MemberFieldRefs {
    readonly uniqueId: FieldRef<"Member", 'String'>
    readonly role: FieldRef<"Member", 'UserRole'>
    readonly permission: FieldRef<"Member", 'String'>
    readonly createdAt: FieldRef<"Member", 'DateTime'>
    readonly updatedAt: FieldRef<"Member", 'DateTime'>
    readonly userId: FieldRef<"Member", 'Int'>
    readonly businessId: FieldRef<"Member", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member updateManyAndReturn
   */
  export type MemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to delete.
     */
    limit?: number
  }

  /**
   * Member.business
   */
  export type Member$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAcc
     */
    select?: BusinessAccSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessAcc
     */
    omit?: BusinessAccOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAccInclude<ExtArgs> | null
    where?: BusinessAccWhereInput
  }

  /**
   * Member.bill
   */
  export type Member$billArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Member.adsCost
   */
  export type Member$adsCostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostInclude<ExtArgs> | null
    where?: AdsCostWhereInput
    orderBy?: AdsCostOrderByWithRelationInput | AdsCostOrderByWithRelationInput[]
    cursor?: AdsCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdsCostScalarFieldEnum | AdsCostScalarFieldEnum[]
  }

  /**
   * Member.expense
   */
  export type Member$expenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Member.product
   */
  export type Member$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Member.platform
   */
  export type Member$platformArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    where?: PlatformWhereInput
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    cursor?: PlatformWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Member.store
   */
  export type Member$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    cursor?: StoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model BusinessAcc
   */

  export type AggregateBusinessAcc = {
    _count: BusinessAccCountAggregateOutputType | null
    _avg: BusinessAccAvgAggregateOutputType | null
    _sum: BusinessAccSumAggregateOutputType | null
    _min: BusinessAccMinAggregateOutputType | null
    _max: BusinessAccMaxAggregateOutputType | null
  }

  export type BusinessAccAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type BusinessAccSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type BusinessAccMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    businessName: string | null
    businessUserName: string | null
    businessAvatar: string | null
    businessAddress: string | null
    vatId: string | null
    businessType: $Enums.BusinessType | null
    taxType: $Enums.taxType | null
    userId: number | null
    memberId: string | null
  }

  export type BusinessAccMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    businessName: string | null
    businessUserName: string | null
    businessAvatar: string | null
    businessAddress: string | null
    vatId: string | null
    businessType: $Enums.BusinessType | null
    taxType: $Enums.taxType | null
    userId: number | null
    memberId: string | null
  }

  export type BusinessAccCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    businessName: number
    businessUserName: number
    businessAvatar: number
    businessAddress: number
    vatId: number
    businessType: number
    taxType: number
    userId: number
    memberId: number
    _all: number
  }


  export type BusinessAccAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type BusinessAccSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type BusinessAccMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    businessName?: true
    businessUserName?: true
    businessAvatar?: true
    businessAddress?: true
    vatId?: true
    businessType?: true
    taxType?: true
    userId?: true
    memberId?: true
  }

  export type BusinessAccMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    businessName?: true
    businessUserName?: true
    businessAvatar?: true
    businessAddress?: true
    vatId?: true
    businessType?: true
    taxType?: true
    userId?: true
    memberId?: true
  }

  export type BusinessAccCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    businessName?: true
    businessUserName?: true
    businessAvatar?: true
    businessAddress?: true
    vatId?: true
    businessType?: true
    taxType?: true
    userId?: true
    memberId?: true
    _all?: true
  }

  export type BusinessAccAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessAcc to aggregate.
     */
    where?: BusinessAccWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessAccs to fetch.
     */
    orderBy?: BusinessAccOrderByWithRelationInput | BusinessAccOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessAccWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessAccs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessAccs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessAccs
    **/
    _count?: true | BusinessAccCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessAccAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessAccSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessAccMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessAccMaxAggregateInputType
  }

  export type GetBusinessAccAggregateType<T extends BusinessAccAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessAcc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessAcc[P]>
      : GetScalarType<T[P], AggregateBusinessAcc[P]>
  }




  export type BusinessAccGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessAccWhereInput
    orderBy?: BusinessAccOrderByWithAggregationInput | BusinessAccOrderByWithAggregationInput[]
    by: BusinessAccScalarFieldEnum[] | BusinessAccScalarFieldEnum
    having?: BusinessAccScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessAccCountAggregateInputType | true
    _avg?: BusinessAccAvgAggregateInputType
    _sum?: BusinessAccSumAggregateInputType
    _min?: BusinessAccMinAggregateInputType
    _max?: BusinessAccMaxAggregateInputType
  }

  export type BusinessAccGroupByOutputType = {
    id: number
    createdAt: Date | null
    updatedAt: Date | null
    businessName: string
    businessUserName: string | null
    businessAvatar: string | null
    businessAddress: string | null
    vatId: string
    businessType: $Enums.BusinessType
    taxType: $Enums.taxType
    userId: number
    memberId: string | null
    _count: BusinessAccCountAggregateOutputType | null
    _avg: BusinessAccAvgAggregateOutputType | null
    _sum: BusinessAccSumAggregateOutputType | null
    _min: BusinessAccMinAggregateOutputType | null
    _max: BusinessAccMaxAggregateOutputType | null
  }

  type GetBusinessAccGroupByPayload<T extends BusinessAccGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessAccGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessAccGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessAccGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessAccGroupByOutputType[P]>
        }
      >
    >


  export type BusinessAccSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessName?: boolean
    businessUserName?: boolean
    businessAvatar?: boolean
    businessAddress?: boolean
    vatId?: boolean
    businessType?: boolean
    taxType?: boolean
    userId?: boolean
    memberId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    AllMember?: boolean | BusinessAcc$AllMemberArgs<ExtArgs>
    billRecord?: boolean | BusinessAcc$billRecordArgs<ExtArgs>
    expenseRecord?: boolean | BusinessAcc$expenseRecordArgs<ExtArgs>
    adsCostRecord?: boolean | BusinessAcc$adsCostRecordArgs<ExtArgs>
    platform?: boolean | BusinessAcc$platformArgs<ExtArgs>
    storefront?: boolean | BusinessAcc$storefrontArgs<ExtArgs>
    product?: boolean | BusinessAcc$productArgs<ExtArgs>
    _count?: boolean | BusinessAccCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessAcc"]>

  export type BusinessAccSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessName?: boolean
    businessUserName?: boolean
    businessAvatar?: boolean
    businessAddress?: boolean
    vatId?: boolean
    businessType?: boolean
    taxType?: boolean
    userId?: boolean
    memberId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessAcc"]>

  export type BusinessAccSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessName?: boolean
    businessUserName?: boolean
    businessAvatar?: boolean
    businessAddress?: boolean
    vatId?: boolean
    businessType?: boolean
    taxType?: boolean
    userId?: boolean
    memberId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessAcc"]>

  export type BusinessAccSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessName?: boolean
    businessUserName?: boolean
    businessAvatar?: boolean
    businessAddress?: boolean
    vatId?: boolean
    businessType?: boolean
    taxType?: boolean
    userId?: boolean
    memberId?: boolean
  }

  export type BusinessAccOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "businessName" | "businessUserName" | "businessAvatar" | "businessAddress" | "vatId" | "businessType" | "taxType" | "userId" | "memberId", ExtArgs["result"]["businessAcc"]>
  export type BusinessAccInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    AllMember?: boolean | BusinessAcc$AllMemberArgs<ExtArgs>
    billRecord?: boolean | BusinessAcc$billRecordArgs<ExtArgs>
    expenseRecord?: boolean | BusinessAcc$expenseRecordArgs<ExtArgs>
    adsCostRecord?: boolean | BusinessAcc$adsCostRecordArgs<ExtArgs>
    platform?: boolean | BusinessAcc$platformArgs<ExtArgs>
    storefront?: boolean | BusinessAcc$storefrontArgs<ExtArgs>
    product?: boolean | BusinessAcc$productArgs<ExtArgs>
    _count?: boolean | BusinessAccCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessAccIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BusinessAccIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BusinessAccPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessAcc"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      AllMember: Prisma.$MemberPayload<ExtArgs>[]
      billRecord: Prisma.$BillPayload<ExtArgs>[]
      expenseRecord: Prisma.$ExpensePayload<ExtArgs>[]
      adsCostRecord: Prisma.$AdsCostPayload<ExtArgs>[]
      platform: Prisma.$PlatformPayload<ExtArgs>[]
      storefront: Prisma.$StorePayload<ExtArgs>[]
      product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date | null
      updatedAt: Date | null
      businessName: string
      businessUserName: string | null
      businessAvatar: string | null
      businessAddress: string | null
      vatId: string
      businessType: $Enums.BusinessType
      taxType: $Enums.taxType
      userId: number
      memberId: string | null
    }, ExtArgs["result"]["businessAcc"]>
    composites: {}
  }

  type BusinessAccGetPayload<S extends boolean | null | undefined | BusinessAccDefaultArgs> = $Result.GetResult<Prisma.$BusinessAccPayload, S>

  type BusinessAccCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessAccFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessAccCountAggregateInputType | true
    }

  export interface BusinessAccDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessAcc'], meta: { name: 'BusinessAcc' } }
    /**
     * Find zero or one BusinessAcc that matches the filter.
     * @param {BusinessAccFindUniqueArgs} args - Arguments to find a BusinessAcc
     * @example
     * // Get one BusinessAcc
     * const businessAcc = await prisma.businessAcc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessAccFindUniqueArgs>(args: SelectSubset<T, BusinessAccFindUniqueArgs<ExtArgs>>): Prisma__BusinessAccClient<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BusinessAcc that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessAccFindUniqueOrThrowArgs} args - Arguments to find a BusinessAcc
     * @example
     * // Get one BusinessAcc
     * const businessAcc = await prisma.businessAcc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessAccFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessAccFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessAccClient<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessAcc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAccFindFirstArgs} args - Arguments to find a BusinessAcc
     * @example
     * // Get one BusinessAcc
     * const businessAcc = await prisma.businessAcc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessAccFindFirstArgs>(args?: SelectSubset<T, BusinessAccFindFirstArgs<ExtArgs>>): Prisma__BusinessAccClient<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessAcc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAccFindFirstOrThrowArgs} args - Arguments to find a BusinessAcc
     * @example
     * // Get one BusinessAcc
     * const businessAcc = await prisma.businessAcc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessAccFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessAccFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessAccClient<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BusinessAccs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAccFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessAccs
     * const businessAccs = await prisma.businessAcc.findMany()
     * 
     * // Get first 10 BusinessAccs
     * const businessAccs = await prisma.businessAcc.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessAccWithIdOnly = await prisma.businessAcc.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessAccFindManyArgs>(args?: SelectSubset<T, BusinessAccFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BusinessAcc.
     * @param {BusinessAccCreateArgs} args - Arguments to create a BusinessAcc.
     * @example
     * // Create one BusinessAcc
     * const BusinessAcc = await prisma.businessAcc.create({
     *   data: {
     *     // ... data to create a BusinessAcc
     *   }
     * })
     * 
     */
    create<T extends BusinessAccCreateArgs>(args: SelectSubset<T, BusinessAccCreateArgs<ExtArgs>>): Prisma__BusinessAccClient<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BusinessAccs.
     * @param {BusinessAccCreateManyArgs} args - Arguments to create many BusinessAccs.
     * @example
     * // Create many BusinessAccs
     * const businessAcc = await prisma.businessAcc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessAccCreateManyArgs>(args?: SelectSubset<T, BusinessAccCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessAccs and returns the data saved in the database.
     * @param {BusinessAccCreateManyAndReturnArgs} args - Arguments to create many BusinessAccs.
     * @example
     * // Create many BusinessAccs
     * const businessAcc = await prisma.businessAcc.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessAccs and only return the `id`
     * const businessAccWithIdOnly = await prisma.businessAcc.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessAccCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessAccCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BusinessAcc.
     * @param {BusinessAccDeleteArgs} args - Arguments to delete one BusinessAcc.
     * @example
     * // Delete one BusinessAcc
     * const BusinessAcc = await prisma.businessAcc.delete({
     *   where: {
     *     // ... filter to delete one BusinessAcc
     *   }
     * })
     * 
     */
    delete<T extends BusinessAccDeleteArgs>(args: SelectSubset<T, BusinessAccDeleteArgs<ExtArgs>>): Prisma__BusinessAccClient<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BusinessAcc.
     * @param {BusinessAccUpdateArgs} args - Arguments to update one BusinessAcc.
     * @example
     * // Update one BusinessAcc
     * const businessAcc = await prisma.businessAcc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessAccUpdateArgs>(args: SelectSubset<T, BusinessAccUpdateArgs<ExtArgs>>): Prisma__BusinessAccClient<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BusinessAccs.
     * @param {BusinessAccDeleteManyArgs} args - Arguments to filter BusinessAccs to delete.
     * @example
     * // Delete a few BusinessAccs
     * const { count } = await prisma.businessAcc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessAccDeleteManyArgs>(args?: SelectSubset<T, BusinessAccDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessAccs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAccUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessAccs
     * const businessAcc = await prisma.businessAcc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessAccUpdateManyArgs>(args: SelectSubset<T, BusinessAccUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessAccs and returns the data updated in the database.
     * @param {BusinessAccUpdateManyAndReturnArgs} args - Arguments to update many BusinessAccs.
     * @example
     * // Update many BusinessAccs
     * const businessAcc = await prisma.businessAcc.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BusinessAccs and only return the `id`
     * const businessAccWithIdOnly = await prisma.businessAcc.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessAccUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessAccUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BusinessAcc.
     * @param {BusinessAccUpsertArgs} args - Arguments to update or create a BusinessAcc.
     * @example
     * // Update or create a BusinessAcc
     * const businessAcc = await prisma.businessAcc.upsert({
     *   create: {
     *     // ... data to create a BusinessAcc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessAcc we want to update
     *   }
     * })
     */
    upsert<T extends BusinessAccUpsertArgs>(args: SelectSubset<T, BusinessAccUpsertArgs<ExtArgs>>): Prisma__BusinessAccClient<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BusinessAccs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAccCountArgs} args - Arguments to filter BusinessAccs to count.
     * @example
     * // Count the number of BusinessAccs
     * const count = await prisma.businessAcc.count({
     *   where: {
     *     // ... the filter for the BusinessAccs we want to count
     *   }
     * })
    **/
    count<T extends BusinessAccCountArgs>(
      args?: Subset<T, BusinessAccCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessAccCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessAcc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAccAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessAccAggregateArgs>(args: Subset<T, BusinessAccAggregateArgs>): Prisma.PrismaPromise<GetBusinessAccAggregateType<T>>

    /**
     * Group by BusinessAcc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAccGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessAccGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessAccGroupByArgs['orderBy'] }
        : { orderBy?: BusinessAccGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessAccGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessAccGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessAcc model
   */
  readonly fields: BusinessAccFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessAcc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessAccClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    AllMember<T extends BusinessAcc$AllMemberArgs<ExtArgs> = {}>(args?: Subset<T, BusinessAcc$AllMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    billRecord<T extends BusinessAcc$billRecordArgs<ExtArgs> = {}>(args?: Subset<T, BusinessAcc$billRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expenseRecord<T extends BusinessAcc$expenseRecordArgs<ExtArgs> = {}>(args?: Subset<T, BusinessAcc$expenseRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adsCostRecord<T extends BusinessAcc$adsCostRecordArgs<ExtArgs> = {}>(args?: Subset<T, BusinessAcc$adsCostRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    platform<T extends BusinessAcc$platformArgs<ExtArgs> = {}>(args?: Subset<T, BusinessAcc$platformArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    storefront<T extends BusinessAcc$storefrontArgs<ExtArgs> = {}>(args?: Subset<T, BusinessAcc$storefrontArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    product<T extends BusinessAcc$productArgs<ExtArgs> = {}>(args?: Subset<T, BusinessAcc$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessAcc model
   */
  interface BusinessAccFieldRefs {
    readonly id: FieldRef<"BusinessAcc", 'Int'>
    readonly createdAt: FieldRef<"BusinessAcc", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessAcc", 'DateTime'>
    readonly businessName: FieldRef<"BusinessAcc", 'String'>
    readonly businessUserName: FieldRef<"BusinessAcc", 'String'>
    readonly businessAvatar: FieldRef<"BusinessAcc", 'String'>
    readonly businessAddress: FieldRef<"BusinessAcc", 'String'>
    readonly vatId: FieldRef<"BusinessAcc", 'String'>
    readonly businessType: FieldRef<"BusinessAcc", 'BusinessType'>
    readonly taxType: FieldRef<"BusinessAcc", 'taxType'>
    readonly userId: FieldRef<"BusinessAcc", 'Int'>
    readonly memberId: FieldRef<"BusinessAcc", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BusinessAcc findUnique
   */
  export type BusinessAccFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAcc
     */
    select?: BusinessAccSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessAcc
     */
    omit?: BusinessAccOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAccInclude<ExtArgs> | null
    /**
     * Filter, which BusinessAcc to fetch.
     */
    where: BusinessAccWhereUniqueInput
  }

  /**
   * BusinessAcc findUniqueOrThrow
   */
  export type BusinessAccFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAcc
     */
    select?: BusinessAccSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessAcc
     */
    omit?: BusinessAccOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAccInclude<ExtArgs> | null
    /**
     * Filter, which BusinessAcc to fetch.
     */
    where: BusinessAccWhereUniqueInput
  }

  /**
   * BusinessAcc findFirst
   */
  export type BusinessAccFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAcc
     */
    select?: BusinessAccSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessAcc
     */
    omit?: BusinessAccOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAccInclude<ExtArgs> | null
    /**
     * Filter, which BusinessAcc to fetch.
     */
    where?: BusinessAccWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessAccs to fetch.
     */
    orderBy?: BusinessAccOrderByWithRelationInput | BusinessAccOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessAccs.
     */
    cursor?: BusinessAccWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessAccs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessAccs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessAccs.
     */
    distinct?: BusinessAccScalarFieldEnum | BusinessAccScalarFieldEnum[]
  }

  /**
   * BusinessAcc findFirstOrThrow
   */
  export type BusinessAccFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAcc
     */
    select?: BusinessAccSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessAcc
     */
    omit?: BusinessAccOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAccInclude<ExtArgs> | null
    /**
     * Filter, which BusinessAcc to fetch.
     */
    where?: BusinessAccWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessAccs to fetch.
     */
    orderBy?: BusinessAccOrderByWithRelationInput | BusinessAccOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessAccs.
     */
    cursor?: BusinessAccWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessAccs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessAccs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessAccs.
     */
    distinct?: BusinessAccScalarFieldEnum | BusinessAccScalarFieldEnum[]
  }

  /**
   * BusinessAcc findMany
   */
  export type BusinessAccFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAcc
     */
    select?: BusinessAccSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessAcc
     */
    omit?: BusinessAccOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAccInclude<ExtArgs> | null
    /**
     * Filter, which BusinessAccs to fetch.
     */
    where?: BusinessAccWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessAccs to fetch.
     */
    orderBy?: BusinessAccOrderByWithRelationInput | BusinessAccOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessAccs.
     */
    cursor?: BusinessAccWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessAccs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessAccs.
     */
    skip?: number
    distinct?: BusinessAccScalarFieldEnum | BusinessAccScalarFieldEnum[]
  }

  /**
   * BusinessAcc create
   */
  export type BusinessAccCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAcc
     */
    select?: BusinessAccSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessAcc
     */
    omit?: BusinessAccOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAccInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessAcc.
     */
    data: XOR<BusinessAccCreateInput, BusinessAccUncheckedCreateInput>
  }

  /**
   * BusinessAcc createMany
   */
  export type BusinessAccCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessAccs.
     */
    data: BusinessAccCreateManyInput | BusinessAccCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessAcc createManyAndReturn
   */
  export type BusinessAccCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAcc
     */
    select?: BusinessAccSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessAcc
     */
    omit?: BusinessAccOmit<ExtArgs> | null
    /**
     * The data used to create many BusinessAccs.
     */
    data: BusinessAccCreateManyInput | BusinessAccCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAccIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessAcc update
   */
  export type BusinessAccUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAcc
     */
    select?: BusinessAccSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessAcc
     */
    omit?: BusinessAccOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAccInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessAcc.
     */
    data: XOR<BusinessAccUpdateInput, BusinessAccUncheckedUpdateInput>
    /**
     * Choose, which BusinessAcc to update.
     */
    where: BusinessAccWhereUniqueInput
  }

  /**
   * BusinessAcc updateMany
   */
  export type BusinessAccUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessAccs.
     */
    data: XOR<BusinessAccUpdateManyMutationInput, BusinessAccUncheckedUpdateManyInput>
    /**
     * Filter which BusinessAccs to update
     */
    where?: BusinessAccWhereInput
    /**
     * Limit how many BusinessAccs to update.
     */
    limit?: number
  }

  /**
   * BusinessAcc updateManyAndReturn
   */
  export type BusinessAccUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAcc
     */
    select?: BusinessAccSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessAcc
     */
    omit?: BusinessAccOmit<ExtArgs> | null
    /**
     * The data used to update BusinessAccs.
     */
    data: XOR<BusinessAccUpdateManyMutationInput, BusinessAccUncheckedUpdateManyInput>
    /**
     * Filter which BusinessAccs to update
     */
    where?: BusinessAccWhereInput
    /**
     * Limit how many BusinessAccs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAccIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessAcc upsert
   */
  export type BusinessAccUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAcc
     */
    select?: BusinessAccSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessAcc
     */
    omit?: BusinessAccOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAccInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessAcc to update in case it exists.
     */
    where: BusinessAccWhereUniqueInput
    /**
     * In case the BusinessAcc found by the `where` argument doesn't exist, create a new BusinessAcc with this data.
     */
    create: XOR<BusinessAccCreateInput, BusinessAccUncheckedCreateInput>
    /**
     * In case the BusinessAcc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessAccUpdateInput, BusinessAccUncheckedUpdateInput>
  }

  /**
   * BusinessAcc delete
   */
  export type BusinessAccDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAcc
     */
    select?: BusinessAccSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessAcc
     */
    omit?: BusinessAccOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAccInclude<ExtArgs> | null
    /**
     * Filter which BusinessAcc to delete.
     */
    where: BusinessAccWhereUniqueInput
  }

  /**
   * BusinessAcc deleteMany
   */
  export type BusinessAccDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessAccs to delete
     */
    where?: BusinessAccWhereInput
    /**
     * Limit how many BusinessAccs to delete.
     */
    limit?: number
  }

  /**
   * BusinessAcc.AllMember
   */
  export type BusinessAcc$AllMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * BusinessAcc.billRecord
   */
  export type BusinessAcc$billRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * BusinessAcc.expenseRecord
   */
  export type BusinessAcc$expenseRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * BusinessAcc.adsCostRecord
   */
  export type BusinessAcc$adsCostRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostInclude<ExtArgs> | null
    where?: AdsCostWhereInput
    orderBy?: AdsCostOrderByWithRelationInput | AdsCostOrderByWithRelationInput[]
    cursor?: AdsCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdsCostScalarFieldEnum | AdsCostScalarFieldEnum[]
  }

  /**
   * BusinessAcc.platform
   */
  export type BusinessAcc$platformArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    where?: PlatformWhereInput
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    cursor?: PlatformWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * BusinessAcc.storefront
   */
  export type BusinessAcc$storefrontArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    cursor?: StoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * BusinessAcc.product
   */
  export type BusinessAcc$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * BusinessAcc without action
   */
  export type BusinessAccDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAcc
     */
    select?: BusinessAccSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessAcc
     */
    omit?: BusinessAccOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAccInclude<ExtArgs> | null
  }


  /**
   * Model Bill
   */

  export type AggregateBill = {
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  export type BillAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    price: number | null
    businessAcc: number | null
    storeId: number | null
  }

  export type BillSumAggregateOutputType = {
    id: number | null
    amount: number | null
    price: number | null
    businessAcc: number | null
    storeId: number | null
  }

  export type BillMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    cName: string | null
    cLastName: string | null
    cPhone: string | null
    cGender: $Enums.Gender | null
    cAddress: string | null
    cProvince: string | null
    cPostId: string | null
    product: string | null
    payment: $Enums.Payment | null
    amount: number | null
    purchaseAt: Date | null
    platform: $Enums.IncomeChannel | null
    cashStatus: boolean | null
    price: number | null
    image: string | null
    deleted: boolean | null
    memberId: string | null
    businessAcc: number | null
    storeId: number | null
  }

  export type BillMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    cName: string | null
    cLastName: string | null
    cPhone: string | null
    cGender: $Enums.Gender | null
    cAddress: string | null
    cProvince: string | null
    cPostId: string | null
    product: string | null
    payment: $Enums.Payment | null
    amount: number | null
    purchaseAt: Date | null
    platform: $Enums.IncomeChannel | null
    cashStatus: boolean | null
    price: number | null
    image: string | null
    deleted: boolean | null
    memberId: string | null
    businessAcc: number | null
    storeId: number | null
  }

  export type BillCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    cName: number
    cLastName: number
    cPhone: number
    cGender: number
    cAddress: number
    cProvince: number
    cPostId: number
    product: number
    payment: number
    amount: number
    purchaseAt: number
    platform: number
    cashStatus: number
    price: number
    image: number
    deleted: number
    memberId: number
    businessAcc: number
    storeId: number
    _all: number
  }


  export type BillAvgAggregateInputType = {
    id?: true
    amount?: true
    price?: true
    businessAcc?: true
    storeId?: true
  }

  export type BillSumAggregateInputType = {
    id?: true
    amount?: true
    price?: true
    businessAcc?: true
    storeId?: true
  }

  export type BillMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    cName?: true
    cLastName?: true
    cPhone?: true
    cGender?: true
    cAddress?: true
    cProvince?: true
    cPostId?: true
    product?: true
    payment?: true
    amount?: true
    purchaseAt?: true
    platform?: true
    cashStatus?: true
    price?: true
    image?: true
    deleted?: true
    memberId?: true
    businessAcc?: true
    storeId?: true
  }

  export type BillMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    cName?: true
    cLastName?: true
    cPhone?: true
    cGender?: true
    cAddress?: true
    cProvince?: true
    cPostId?: true
    product?: true
    payment?: true
    amount?: true
    purchaseAt?: true
    platform?: true
    cashStatus?: true
    price?: true
    image?: true
    deleted?: true
    memberId?: true
    businessAcc?: true
    storeId?: true
  }

  export type BillCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    cName?: true
    cLastName?: true
    cPhone?: true
    cGender?: true
    cAddress?: true
    cProvince?: true
    cPostId?: true
    product?: true
    payment?: true
    amount?: true
    purchaseAt?: true
    platform?: true
    cashStatus?: true
    price?: true
    image?: true
    deleted?: true
    memberId?: true
    businessAcc?: true
    storeId?: true
    _all?: true
  }

  export type BillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bill to aggregate.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bills
    **/
    _count?: true | BillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillMaxAggregateInputType
  }

  export type GetBillAggregateType<T extends BillAggregateArgs> = {
        [P in keyof T & keyof AggregateBill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBill[P]>
      : GetScalarType<T[P], AggregateBill[P]>
  }




  export type BillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
    orderBy?: BillOrderByWithAggregationInput | BillOrderByWithAggregationInput[]
    by: BillScalarFieldEnum[] | BillScalarFieldEnum
    having?: BillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillCountAggregateInputType | true
    _avg?: BillAvgAggregateInputType
    _sum?: BillSumAggregateInputType
    _min?: BillMinAggregateInputType
    _max?: BillMaxAggregateInputType
  }

  export type BillGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    cName: string
    cLastName: string | null
    cPhone: string | null
    cGender: $Enums.Gender | null
    cAddress: string | null
    cProvince: string | null
    cPostId: string | null
    product: string
    payment: $Enums.Payment
    amount: number
    purchaseAt: Date
    platform: $Enums.IncomeChannel
    cashStatus: boolean
    price: number
    image: string | null
    deleted: boolean | null
    memberId: string
    businessAcc: number
    storeId: number
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  type GetBillGroupByPayload<T extends BillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillGroupByOutputType[P]>
            : GetScalarType<T[P], BillGroupByOutputType[P]>
        }
      >
    >


  export type BillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cName?: boolean
    cLastName?: boolean
    cPhone?: boolean
    cGender?: boolean
    cAddress?: boolean
    cProvince?: boolean
    cPostId?: boolean
    product?: boolean
    payment?: boolean
    amount?: boolean
    purchaseAt?: boolean
    platform?: boolean
    cashStatus?: boolean
    price?: boolean
    image?: boolean
    deleted?: boolean
    memberId?: boolean
    businessAcc?: boolean
    storeId?: boolean
    productList?: boolean | ProductDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>

  export type BillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cName?: boolean
    cLastName?: boolean
    cPhone?: boolean
    cGender?: boolean
    cAddress?: boolean
    cProvince?: boolean
    cPostId?: boolean
    product?: boolean
    payment?: boolean
    amount?: boolean
    purchaseAt?: boolean
    platform?: boolean
    cashStatus?: boolean
    price?: boolean
    image?: boolean
    deleted?: boolean
    memberId?: boolean
    businessAcc?: boolean
    storeId?: boolean
    productList?: boolean | ProductDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>

  export type BillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cName?: boolean
    cLastName?: boolean
    cPhone?: boolean
    cGender?: boolean
    cAddress?: boolean
    cProvince?: boolean
    cPostId?: boolean
    product?: boolean
    payment?: boolean
    amount?: boolean
    purchaseAt?: boolean
    platform?: boolean
    cashStatus?: boolean
    price?: boolean
    image?: boolean
    deleted?: boolean
    memberId?: boolean
    businessAcc?: boolean
    storeId?: boolean
    productList?: boolean | ProductDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>

  export type BillSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cName?: boolean
    cLastName?: boolean
    cPhone?: boolean
    cGender?: boolean
    cAddress?: boolean
    cProvince?: boolean
    cPostId?: boolean
    product?: boolean
    payment?: boolean
    amount?: boolean
    purchaseAt?: boolean
    platform?: boolean
    cashStatus?: boolean
    price?: boolean
    image?: boolean
    deleted?: boolean
    memberId?: boolean
    businessAcc?: boolean
    storeId?: boolean
  }

  export type BillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "cName" | "cLastName" | "cPhone" | "cGender" | "cAddress" | "cProvince" | "cPostId" | "product" | "payment" | "amount" | "purchaseAt" | "platform" | "cashStatus" | "price" | "image" | "deleted" | "memberId" | "businessAcc" | "storeId", ExtArgs["result"]["bill"]>
  export type BillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productList?: boolean | ProductDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type BillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productList?: boolean | ProductDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type BillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productList?: boolean | ProductDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $BillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bill"
    objects: {
      productList: Prisma.$ProductPayload<ExtArgs>
      member: Prisma.$MemberPayload<ExtArgs>
      businessId: Prisma.$BusinessAccPayload<ExtArgs>
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      cName: string
      cLastName: string | null
      cPhone: string | null
      cGender: $Enums.Gender | null
      cAddress: string | null
      cProvince: string | null
      cPostId: string | null
      product: string
      payment: $Enums.Payment
      amount: number
      purchaseAt: Date
      platform: $Enums.IncomeChannel
      cashStatus: boolean
      price: number
      image: string | null
      deleted: boolean | null
      memberId: string
      businessAcc: number
      storeId: number
    }, ExtArgs["result"]["bill"]>
    composites: {}
  }

  type BillGetPayload<S extends boolean | null | undefined | BillDefaultArgs> = $Result.GetResult<Prisma.$BillPayload, S>

  type BillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillCountAggregateInputType | true
    }

  export interface BillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bill'], meta: { name: 'Bill' } }
    /**
     * Find zero or one Bill that matches the filter.
     * @param {BillFindUniqueArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillFindUniqueArgs>(args: SelectSubset<T, BillFindUniqueArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillFindUniqueOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillFindUniqueOrThrowArgs>(args: SelectSubset<T, BillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillFindFirstArgs>(args?: SelectSubset<T, BillFindFirstArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillFindFirstOrThrowArgs>(args?: SelectSubset<T, BillFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bills
     * const bills = await prisma.bill.findMany()
     * 
     * // Get first 10 Bills
     * const bills = await prisma.bill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billWithIdOnly = await prisma.bill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillFindManyArgs>(args?: SelectSubset<T, BillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bill.
     * @param {BillCreateArgs} args - Arguments to create a Bill.
     * @example
     * // Create one Bill
     * const Bill = await prisma.bill.create({
     *   data: {
     *     // ... data to create a Bill
     *   }
     * })
     * 
     */
    create<T extends BillCreateArgs>(args: SelectSubset<T, BillCreateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bills.
     * @param {BillCreateManyArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bill = await prisma.bill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillCreateManyArgs>(args?: SelectSubset<T, BillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bills and returns the data saved in the database.
     * @param {BillCreateManyAndReturnArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bill = await prisma.bill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bills and only return the `id`
     * const billWithIdOnly = await prisma.bill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillCreateManyAndReturnArgs>(args?: SelectSubset<T, BillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bill.
     * @param {BillDeleteArgs} args - Arguments to delete one Bill.
     * @example
     * // Delete one Bill
     * const Bill = await prisma.bill.delete({
     *   where: {
     *     // ... filter to delete one Bill
     *   }
     * })
     * 
     */
    delete<T extends BillDeleteArgs>(args: SelectSubset<T, BillDeleteArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bill.
     * @param {BillUpdateArgs} args - Arguments to update one Bill.
     * @example
     * // Update one Bill
     * const bill = await prisma.bill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillUpdateArgs>(args: SelectSubset<T, BillUpdateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bills.
     * @param {BillDeleteManyArgs} args - Arguments to filter Bills to delete.
     * @example
     * // Delete a few Bills
     * const { count } = await prisma.bill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillDeleteManyArgs>(args?: SelectSubset<T, BillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bills
     * const bill = await prisma.bill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillUpdateManyArgs>(args: SelectSubset<T, BillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills and returns the data updated in the database.
     * @param {BillUpdateManyAndReturnArgs} args - Arguments to update many Bills.
     * @example
     * // Update many Bills
     * const bill = await prisma.bill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bills and only return the `id`
     * const billWithIdOnly = await prisma.bill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillUpdateManyAndReturnArgs>(args: SelectSubset<T, BillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bill.
     * @param {BillUpsertArgs} args - Arguments to update or create a Bill.
     * @example
     * // Update or create a Bill
     * const bill = await prisma.bill.upsert({
     *   create: {
     *     // ... data to create a Bill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bill we want to update
     *   }
     * })
     */
    upsert<T extends BillUpsertArgs>(args: SelectSubset<T, BillUpsertArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillCountArgs} args - Arguments to filter Bills to count.
     * @example
     * // Count the number of Bills
     * const count = await prisma.bill.count({
     *   where: {
     *     // ... the filter for the Bills we want to count
     *   }
     * })
    **/
    count<T extends BillCountArgs>(
      args?: Subset<T, BillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillAggregateArgs>(args: Subset<T, BillAggregateArgs>): Prisma.PrismaPromise<GetBillAggregateType<T>>

    /**
     * Group by Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillGroupByArgs['orderBy'] }
        : { orderBy?: BillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bill model
   */
  readonly fields: BillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productList<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    businessId<T extends BusinessAccDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessAccDefaultArgs<ExtArgs>>): Prisma__BusinessAccClient<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bill model
   */
  interface BillFieldRefs {
    readonly id: FieldRef<"Bill", 'Int'>
    readonly createdAt: FieldRef<"Bill", 'DateTime'>
    readonly updatedAt: FieldRef<"Bill", 'DateTime'>
    readonly cName: FieldRef<"Bill", 'String'>
    readonly cLastName: FieldRef<"Bill", 'String'>
    readonly cPhone: FieldRef<"Bill", 'String'>
    readonly cGender: FieldRef<"Bill", 'Gender'>
    readonly cAddress: FieldRef<"Bill", 'String'>
    readonly cProvince: FieldRef<"Bill", 'String'>
    readonly cPostId: FieldRef<"Bill", 'String'>
    readonly product: FieldRef<"Bill", 'String'>
    readonly payment: FieldRef<"Bill", 'Payment'>
    readonly amount: FieldRef<"Bill", 'Int'>
    readonly purchaseAt: FieldRef<"Bill", 'DateTime'>
    readonly platform: FieldRef<"Bill", 'IncomeChannel'>
    readonly cashStatus: FieldRef<"Bill", 'Boolean'>
    readonly price: FieldRef<"Bill", 'Int'>
    readonly image: FieldRef<"Bill", 'String'>
    readonly deleted: FieldRef<"Bill", 'Boolean'>
    readonly memberId: FieldRef<"Bill", 'String'>
    readonly businessAcc: FieldRef<"Bill", 'Int'>
    readonly storeId: FieldRef<"Bill", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Bill findUnique
   */
  export type BillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findUniqueOrThrow
   */
  export type BillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findFirst
   */
  export type BillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findFirstOrThrow
   */
  export type BillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findMany
   */
  export type BillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill create
   */
  export type BillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The data needed to create a Bill.
     */
    data: XOR<BillCreateInput, BillUncheckedCreateInput>
  }

  /**
   * Bill createMany
   */
  export type BillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bills.
     */
    data: BillCreateManyInput | BillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bill createManyAndReturn
   */
  export type BillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * The data used to create many Bills.
     */
    data: BillCreateManyInput | BillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bill update
   */
  export type BillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The data needed to update a Bill.
     */
    data: XOR<BillUpdateInput, BillUncheckedUpdateInput>
    /**
     * Choose, which Bill to update.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill updateMany
   */
  export type BillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bills.
     */
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyInput>
    /**
     * Filter which Bills to update
     */
    where?: BillWhereInput
    /**
     * Limit how many Bills to update.
     */
    limit?: number
  }

  /**
   * Bill updateManyAndReturn
   */
  export type BillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * The data used to update Bills.
     */
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyInput>
    /**
     * Filter which Bills to update
     */
    where?: BillWhereInput
    /**
     * Limit how many Bills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bill upsert
   */
  export type BillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The filter to search for the Bill to update in case it exists.
     */
    where: BillWhereUniqueInput
    /**
     * In case the Bill found by the `where` argument doesn't exist, create a new Bill with this data.
     */
    create: XOR<BillCreateInput, BillUncheckedCreateInput>
    /**
     * In case the Bill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillUpdateInput, BillUncheckedUpdateInput>
  }

  /**
   * Bill delete
   */
  export type BillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter which Bill to delete.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill deleteMany
   */
  export type BillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bills to delete
     */
    where?: BillWhereInput
    /**
     * Limit how many Bills to delete.
     */
    limit?: number
  }

  /**
   * Bill without action
   */
  export type BillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
  }


  /**
   * Model AdsCost
   */

  export type AggregateAdsCost = {
    _count: AdsCostCountAggregateOutputType | null
    _avg: AdsCostAvgAggregateOutputType | null
    _sum: AdsCostSumAggregateOutputType | null
    _min: AdsCostMinAggregateOutputType | null
    _max: AdsCostMaxAggregateOutputType | null
  }

  export type AdsCostAvgAggregateOutputType = {
    id: number | null
    adsCost: Decimal | null
    platformId: number | null
    businessAcc: number | null
  }

  export type AdsCostSumAggregateOutputType = {
    id: number | null
    adsCost: Decimal | null
    platformId: number | null
    businessAcc: number | null
  }

  export type AdsCostMinAggregateOutputType = {
    id: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    adsCost: Decimal | null
    memberId: string | null
    platformId: number | null
    product: string | null
    businessAcc: number | null
  }

  export type AdsCostMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    adsCost: Decimal | null
    memberId: string | null
    platformId: number | null
    product: string | null
    businessAcc: number | null
  }

  export type AdsCostCountAggregateOutputType = {
    id: number
    date: number
    createdAt: number
    updatedAt: number
    adsCost: number
    memberId: number
    platformId: number
    product: number
    businessAcc: number
    _all: number
  }


  export type AdsCostAvgAggregateInputType = {
    id?: true
    adsCost?: true
    platformId?: true
    businessAcc?: true
  }

  export type AdsCostSumAggregateInputType = {
    id?: true
    adsCost?: true
    platformId?: true
    businessAcc?: true
  }

  export type AdsCostMinAggregateInputType = {
    id?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    adsCost?: true
    memberId?: true
    platformId?: true
    product?: true
    businessAcc?: true
  }

  export type AdsCostMaxAggregateInputType = {
    id?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    adsCost?: true
    memberId?: true
    platformId?: true
    product?: true
    businessAcc?: true
  }

  export type AdsCostCountAggregateInputType = {
    id?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    adsCost?: true
    memberId?: true
    platformId?: true
    product?: true
    businessAcc?: true
    _all?: true
  }

  export type AdsCostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdsCost to aggregate.
     */
    where?: AdsCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsCosts to fetch.
     */
    orderBy?: AdsCostOrderByWithRelationInput | AdsCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdsCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdsCosts
    **/
    _count?: true | AdsCostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdsCostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdsCostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdsCostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdsCostMaxAggregateInputType
  }

  export type GetAdsCostAggregateType<T extends AdsCostAggregateArgs> = {
        [P in keyof T & keyof AggregateAdsCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdsCost[P]>
      : GetScalarType<T[P], AggregateAdsCost[P]>
  }




  export type AdsCostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdsCostWhereInput
    orderBy?: AdsCostOrderByWithAggregationInput | AdsCostOrderByWithAggregationInput[]
    by: AdsCostScalarFieldEnum[] | AdsCostScalarFieldEnum
    having?: AdsCostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdsCostCountAggregateInputType | true
    _avg?: AdsCostAvgAggregateInputType
    _sum?: AdsCostSumAggregateInputType
    _min?: AdsCostMinAggregateInputType
    _max?: AdsCostMaxAggregateInputType
  }

  export type AdsCostGroupByOutputType = {
    id: number
    date: Date
    createdAt: Date
    updatedAt: Date
    adsCost: Decimal
    memberId: string
    platformId: number
    product: string
    businessAcc: number
    _count: AdsCostCountAggregateOutputType | null
    _avg: AdsCostAvgAggregateOutputType | null
    _sum: AdsCostSumAggregateOutputType | null
    _min: AdsCostMinAggregateOutputType | null
    _max: AdsCostMaxAggregateOutputType | null
  }

  type GetAdsCostGroupByPayload<T extends AdsCostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdsCostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdsCostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdsCostGroupByOutputType[P]>
            : GetScalarType<T[P], AdsCostGroupByOutputType[P]>
        }
      >
    >


  export type AdsCostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adsCost?: boolean
    memberId?: boolean
    platformId?: boolean
    product?: boolean
    businessAcc?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    productList?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adsCost"]>

  export type AdsCostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adsCost?: boolean
    memberId?: boolean
    platformId?: boolean
    product?: boolean
    businessAcc?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    productList?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adsCost"]>

  export type AdsCostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adsCost?: boolean
    memberId?: boolean
    platformId?: boolean
    product?: boolean
    businessAcc?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    productList?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adsCost"]>

  export type AdsCostSelectScalar = {
    id?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adsCost?: boolean
    memberId?: boolean
    platformId?: boolean
    product?: boolean
    businessAcc?: boolean
  }

  export type AdsCostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "createdAt" | "updatedAt" | "adsCost" | "memberId" | "platformId" | "product" | "businessAcc", ExtArgs["result"]["adsCost"]>
  export type AdsCostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    productList?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type AdsCostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    productList?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type AdsCostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    productList?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $AdsCostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdsCost"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      platform: Prisma.$PlatformPayload<ExtArgs>
      businessId: Prisma.$BusinessAccPayload<ExtArgs>
      productList: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      createdAt: Date
      updatedAt: Date
      adsCost: Prisma.Decimal
      memberId: string
      platformId: number
      product: string
      businessAcc: number
    }, ExtArgs["result"]["adsCost"]>
    composites: {}
  }

  type AdsCostGetPayload<S extends boolean | null | undefined | AdsCostDefaultArgs> = $Result.GetResult<Prisma.$AdsCostPayload, S>

  type AdsCostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdsCostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdsCostCountAggregateInputType | true
    }

  export interface AdsCostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdsCost'], meta: { name: 'AdsCost' } }
    /**
     * Find zero or one AdsCost that matches the filter.
     * @param {AdsCostFindUniqueArgs} args - Arguments to find a AdsCost
     * @example
     * // Get one AdsCost
     * const adsCost = await prisma.adsCost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdsCostFindUniqueArgs>(args: SelectSubset<T, AdsCostFindUniqueArgs<ExtArgs>>): Prisma__AdsCostClient<$Result.GetResult<Prisma.$AdsCostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdsCost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdsCostFindUniqueOrThrowArgs} args - Arguments to find a AdsCost
     * @example
     * // Get one AdsCost
     * const adsCost = await prisma.adsCost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdsCostFindUniqueOrThrowArgs>(args: SelectSubset<T, AdsCostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdsCostClient<$Result.GetResult<Prisma.$AdsCostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdsCost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsCostFindFirstArgs} args - Arguments to find a AdsCost
     * @example
     * // Get one AdsCost
     * const adsCost = await prisma.adsCost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdsCostFindFirstArgs>(args?: SelectSubset<T, AdsCostFindFirstArgs<ExtArgs>>): Prisma__AdsCostClient<$Result.GetResult<Prisma.$AdsCostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdsCost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsCostFindFirstOrThrowArgs} args - Arguments to find a AdsCost
     * @example
     * // Get one AdsCost
     * const adsCost = await prisma.adsCost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdsCostFindFirstOrThrowArgs>(args?: SelectSubset<T, AdsCostFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdsCostClient<$Result.GetResult<Prisma.$AdsCostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdsCosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsCostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdsCosts
     * const adsCosts = await prisma.adsCost.findMany()
     * 
     * // Get first 10 AdsCosts
     * const adsCosts = await prisma.adsCost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adsCostWithIdOnly = await prisma.adsCost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdsCostFindManyArgs>(args?: SelectSubset<T, AdsCostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdsCost.
     * @param {AdsCostCreateArgs} args - Arguments to create a AdsCost.
     * @example
     * // Create one AdsCost
     * const AdsCost = await prisma.adsCost.create({
     *   data: {
     *     // ... data to create a AdsCost
     *   }
     * })
     * 
     */
    create<T extends AdsCostCreateArgs>(args: SelectSubset<T, AdsCostCreateArgs<ExtArgs>>): Prisma__AdsCostClient<$Result.GetResult<Prisma.$AdsCostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdsCosts.
     * @param {AdsCostCreateManyArgs} args - Arguments to create many AdsCosts.
     * @example
     * // Create many AdsCosts
     * const adsCost = await prisma.adsCost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdsCostCreateManyArgs>(args?: SelectSubset<T, AdsCostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdsCosts and returns the data saved in the database.
     * @param {AdsCostCreateManyAndReturnArgs} args - Arguments to create many AdsCosts.
     * @example
     * // Create many AdsCosts
     * const adsCost = await prisma.adsCost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdsCosts and only return the `id`
     * const adsCostWithIdOnly = await prisma.adsCost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdsCostCreateManyAndReturnArgs>(args?: SelectSubset<T, AdsCostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsCostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdsCost.
     * @param {AdsCostDeleteArgs} args - Arguments to delete one AdsCost.
     * @example
     * // Delete one AdsCost
     * const AdsCost = await prisma.adsCost.delete({
     *   where: {
     *     // ... filter to delete one AdsCost
     *   }
     * })
     * 
     */
    delete<T extends AdsCostDeleteArgs>(args: SelectSubset<T, AdsCostDeleteArgs<ExtArgs>>): Prisma__AdsCostClient<$Result.GetResult<Prisma.$AdsCostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdsCost.
     * @param {AdsCostUpdateArgs} args - Arguments to update one AdsCost.
     * @example
     * // Update one AdsCost
     * const adsCost = await prisma.adsCost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdsCostUpdateArgs>(args: SelectSubset<T, AdsCostUpdateArgs<ExtArgs>>): Prisma__AdsCostClient<$Result.GetResult<Prisma.$AdsCostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdsCosts.
     * @param {AdsCostDeleteManyArgs} args - Arguments to filter AdsCosts to delete.
     * @example
     * // Delete a few AdsCosts
     * const { count } = await prisma.adsCost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdsCostDeleteManyArgs>(args?: SelectSubset<T, AdsCostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdsCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsCostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdsCosts
     * const adsCost = await prisma.adsCost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdsCostUpdateManyArgs>(args: SelectSubset<T, AdsCostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdsCosts and returns the data updated in the database.
     * @param {AdsCostUpdateManyAndReturnArgs} args - Arguments to update many AdsCosts.
     * @example
     * // Update many AdsCosts
     * const adsCost = await prisma.adsCost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdsCosts and only return the `id`
     * const adsCostWithIdOnly = await prisma.adsCost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdsCostUpdateManyAndReturnArgs>(args: SelectSubset<T, AdsCostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsCostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdsCost.
     * @param {AdsCostUpsertArgs} args - Arguments to update or create a AdsCost.
     * @example
     * // Update or create a AdsCost
     * const adsCost = await prisma.adsCost.upsert({
     *   create: {
     *     // ... data to create a AdsCost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdsCost we want to update
     *   }
     * })
     */
    upsert<T extends AdsCostUpsertArgs>(args: SelectSubset<T, AdsCostUpsertArgs<ExtArgs>>): Prisma__AdsCostClient<$Result.GetResult<Prisma.$AdsCostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdsCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsCostCountArgs} args - Arguments to filter AdsCosts to count.
     * @example
     * // Count the number of AdsCosts
     * const count = await prisma.adsCost.count({
     *   where: {
     *     // ... the filter for the AdsCosts we want to count
     *   }
     * })
    **/
    count<T extends AdsCostCountArgs>(
      args?: Subset<T, AdsCostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdsCostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdsCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsCostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdsCostAggregateArgs>(args: Subset<T, AdsCostAggregateArgs>): Prisma.PrismaPromise<GetAdsCostAggregateType<T>>

    /**
     * Group by AdsCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsCostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdsCostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdsCostGroupByArgs['orderBy'] }
        : { orderBy?: AdsCostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdsCostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdsCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdsCost model
   */
  readonly fields: AdsCostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdsCost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdsCostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    platform<T extends PlatformDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlatformDefaultArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    businessId<T extends BusinessAccDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessAccDefaultArgs<ExtArgs>>): Prisma__BusinessAccClient<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productList<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdsCost model
   */
  interface AdsCostFieldRefs {
    readonly id: FieldRef<"AdsCost", 'Int'>
    readonly date: FieldRef<"AdsCost", 'DateTime'>
    readonly createdAt: FieldRef<"AdsCost", 'DateTime'>
    readonly updatedAt: FieldRef<"AdsCost", 'DateTime'>
    readonly adsCost: FieldRef<"AdsCost", 'Decimal'>
    readonly memberId: FieldRef<"AdsCost", 'String'>
    readonly platformId: FieldRef<"AdsCost", 'Int'>
    readonly product: FieldRef<"AdsCost", 'String'>
    readonly businessAcc: FieldRef<"AdsCost", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AdsCost findUnique
   */
  export type AdsCostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostInclude<ExtArgs> | null
    /**
     * Filter, which AdsCost to fetch.
     */
    where: AdsCostWhereUniqueInput
  }

  /**
   * AdsCost findUniqueOrThrow
   */
  export type AdsCostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostInclude<ExtArgs> | null
    /**
     * Filter, which AdsCost to fetch.
     */
    where: AdsCostWhereUniqueInput
  }

  /**
   * AdsCost findFirst
   */
  export type AdsCostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostInclude<ExtArgs> | null
    /**
     * Filter, which AdsCost to fetch.
     */
    where?: AdsCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsCosts to fetch.
     */
    orderBy?: AdsCostOrderByWithRelationInput | AdsCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdsCosts.
     */
    cursor?: AdsCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdsCosts.
     */
    distinct?: AdsCostScalarFieldEnum | AdsCostScalarFieldEnum[]
  }

  /**
   * AdsCost findFirstOrThrow
   */
  export type AdsCostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostInclude<ExtArgs> | null
    /**
     * Filter, which AdsCost to fetch.
     */
    where?: AdsCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsCosts to fetch.
     */
    orderBy?: AdsCostOrderByWithRelationInput | AdsCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdsCosts.
     */
    cursor?: AdsCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdsCosts.
     */
    distinct?: AdsCostScalarFieldEnum | AdsCostScalarFieldEnum[]
  }

  /**
   * AdsCost findMany
   */
  export type AdsCostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostInclude<ExtArgs> | null
    /**
     * Filter, which AdsCosts to fetch.
     */
    where?: AdsCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsCosts to fetch.
     */
    orderBy?: AdsCostOrderByWithRelationInput | AdsCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdsCosts.
     */
    cursor?: AdsCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsCosts.
     */
    skip?: number
    distinct?: AdsCostScalarFieldEnum | AdsCostScalarFieldEnum[]
  }

  /**
   * AdsCost create
   */
  export type AdsCostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostInclude<ExtArgs> | null
    /**
     * The data needed to create a AdsCost.
     */
    data: XOR<AdsCostCreateInput, AdsCostUncheckedCreateInput>
  }

  /**
   * AdsCost createMany
   */
  export type AdsCostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdsCosts.
     */
    data: AdsCostCreateManyInput | AdsCostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdsCost createManyAndReturn
   */
  export type AdsCostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * The data used to create many AdsCosts.
     */
    data: AdsCostCreateManyInput | AdsCostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdsCost update
   */
  export type AdsCostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostInclude<ExtArgs> | null
    /**
     * The data needed to update a AdsCost.
     */
    data: XOR<AdsCostUpdateInput, AdsCostUncheckedUpdateInput>
    /**
     * Choose, which AdsCost to update.
     */
    where: AdsCostWhereUniqueInput
  }

  /**
   * AdsCost updateMany
   */
  export type AdsCostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdsCosts.
     */
    data: XOR<AdsCostUpdateManyMutationInput, AdsCostUncheckedUpdateManyInput>
    /**
     * Filter which AdsCosts to update
     */
    where?: AdsCostWhereInput
    /**
     * Limit how many AdsCosts to update.
     */
    limit?: number
  }

  /**
   * AdsCost updateManyAndReturn
   */
  export type AdsCostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * The data used to update AdsCosts.
     */
    data: XOR<AdsCostUpdateManyMutationInput, AdsCostUncheckedUpdateManyInput>
    /**
     * Filter which AdsCosts to update
     */
    where?: AdsCostWhereInput
    /**
     * Limit how many AdsCosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdsCost upsert
   */
  export type AdsCostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostInclude<ExtArgs> | null
    /**
     * The filter to search for the AdsCost to update in case it exists.
     */
    where: AdsCostWhereUniqueInput
    /**
     * In case the AdsCost found by the `where` argument doesn't exist, create a new AdsCost with this data.
     */
    create: XOR<AdsCostCreateInput, AdsCostUncheckedCreateInput>
    /**
     * In case the AdsCost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdsCostUpdateInput, AdsCostUncheckedUpdateInput>
  }

  /**
   * AdsCost delete
   */
  export type AdsCostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostInclude<ExtArgs> | null
    /**
     * Filter which AdsCost to delete.
     */
    where: AdsCostWhereUniqueInput
  }

  /**
   * AdsCost deleteMany
   */
  export type AdsCostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdsCosts to delete
     */
    where?: AdsCostWhereInput
    /**
     * Limit how many AdsCosts to delete.
     */
    limit?: number
  }

  /**
   * AdsCost without action
   */
  export type AdsCostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    businessAcc: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    businessAcc: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    id: number | null
    amount: Decimal | null
    group: string | null
    image: string | null
    note: string | null
    desc: string | null
    deleted: boolean | null
    save: boolean | null
    channel: $Enums.Bank | null
    code: string | null
    businessAcc: number | null
    memberId: string | null
  }

  export type ExpenseMaxAggregateOutputType = {
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    id: number | null
    amount: Decimal | null
    group: string | null
    image: string | null
    note: string | null
    desc: string | null
    deleted: boolean | null
    save: boolean | null
    channel: $Enums.Bank | null
    code: string | null
    businessAcc: number | null
    memberId: string | null
  }

  export type ExpenseCountAggregateOutputType = {
    date: number
    createdAt: number
    updatedAt: number
    id: number
    amount: number
    group: number
    image: number
    note: number
    desc: number
    deleted: number
    save: number
    channel: number
    code: number
    businessAcc: number
    memberId: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    id?: true
    amount?: true
    businessAcc?: true
  }

  export type ExpenseSumAggregateInputType = {
    id?: true
    amount?: true
    businessAcc?: true
  }

  export type ExpenseMinAggregateInputType = {
    date?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    amount?: true
    group?: true
    image?: true
    note?: true
    desc?: true
    deleted?: true
    save?: true
    channel?: true
    code?: true
    businessAcc?: true
    memberId?: true
  }

  export type ExpenseMaxAggregateInputType = {
    date?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    amount?: true
    group?: true
    image?: true
    note?: true
    desc?: true
    deleted?: true
    save?: true
    channel?: true
    code?: true
    businessAcc?: true
    memberId?: true
  }

  export type ExpenseCountAggregateInputType = {
    date?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    amount?: true
    group?: true
    image?: true
    note?: true
    desc?: true
    deleted?: true
    save?: true
    channel?: true
    code?: true
    businessAcc?: true
    memberId?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    date: Date
    createdAt: Date
    updatedAt: Date
    id: number
    amount: Decimal
    group: string | null
    image: string | null
    note: string | null
    desc: string | null
    deleted: boolean | null
    save: boolean | null
    channel: $Enums.Bank | null
    code: string | null
    businessAcc: number
    memberId: string
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    amount?: boolean
    group?: boolean
    image?: boolean
    note?: boolean
    desc?: boolean
    deleted?: boolean
    save?: boolean
    channel?: boolean
    code?: boolean
    businessAcc?: boolean
    memberId?: boolean
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    amount?: boolean
    group?: boolean
    image?: boolean
    note?: boolean
    desc?: boolean
    deleted?: boolean
    save?: boolean
    channel?: boolean
    code?: boolean
    businessAcc?: boolean
    memberId?: boolean
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    amount?: boolean
    group?: boolean
    image?: boolean
    note?: boolean
    desc?: boolean
    deleted?: boolean
    save?: boolean
    channel?: boolean
    code?: boolean
    businessAcc?: boolean
    memberId?: boolean
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    amount?: boolean
    group?: boolean
    image?: boolean
    note?: boolean
    desc?: boolean
    deleted?: boolean
    save?: boolean
    channel?: boolean
    code?: boolean
    businessAcc?: boolean
    memberId?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"date" | "createdAt" | "updatedAt" | "id" | "amount" | "group" | "image" | "note" | "desc" | "deleted" | "save" | "channel" | "code" | "businessAcc" | "memberId", ExtArgs["result"]["expense"]>
  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      businessId: Prisma.$BusinessAccPayload<ExtArgs>
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      date: Date
      createdAt: Date
      updatedAt: Date
      id: number
      amount: Prisma.Decimal
      group: string | null
      image: string | null
      note: string | null
      desc: string | null
      deleted: boolean | null
      save: boolean | null
      channel: $Enums.Bank | null
      code: string | null
      businessAcc: number
      memberId: string
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `date`
     * const expenseWithDateOnly = await prisma.expense.findMany({ select: { date: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `date`
     * const expenseWithDateOnly = await prisma.expense.createManyAndReturn({
     *   select: { date: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses and returns the data updated in the database.
     * @param {ExpenseUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expenses and only return the `date`
     * const expenseWithDateOnly = await prisma.expense.updateManyAndReturn({
     *   select: { date: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessId<T extends BusinessAccDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessAccDefaultArgs<ExtArgs>>): Prisma__BusinessAccClient<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
    readonly id: FieldRef<"Expense", 'Int'>
    readonly amount: FieldRef<"Expense", 'Decimal'>
    readonly group: FieldRef<"Expense", 'String'>
    readonly image: FieldRef<"Expense", 'String'>
    readonly note: FieldRef<"Expense", 'String'>
    readonly desc: FieldRef<"Expense", 'String'>
    readonly deleted: FieldRef<"Expense", 'Boolean'>
    readonly save: FieldRef<"Expense", 'Boolean'>
    readonly channel: FieldRef<"Expense", 'Bank'>
    readonly code: FieldRef<"Expense", 'String'>
    readonly businessAcc: FieldRef<"Expense", 'Int'>
    readonly memberId: FieldRef<"Expense", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense updateManyAndReturn
   */
  export type ExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model Platform
   */

  export type AggregatePlatform = {
    _count: PlatformCountAggregateOutputType | null
    _avg: PlatformAvgAggregateOutputType | null
    _sum: PlatformSumAggregateOutputType | null
    _min: PlatformMinAggregateOutputType | null
    _max: PlatformMaxAggregateOutputType | null
  }

  export type PlatformAvgAggregateOutputType = {
    id: number | null
    businessAcc: number | null
  }

  export type PlatformSumAggregateOutputType = {
    id: number | null
    businessAcc: number | null
  }

  export type PlatformMinAggregateOutputType = {
    id: number | null
    platform: $Enums.SocialMedia | null
    accName: string | null
    accId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    businessAcc: number | null
    memberId: string | null
    deleted: boolean | null
  }

  export type PlatformMaxAggregateOutputType = {
    id: number | null
    platform: $Enums.SocialMedia | null
    accName: string | null
    accId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    businessAcc: number | null
    memberId: string | null
    deleted: boolean | null
  }

  export type PlatformCountAggregateOutputType = {
    id: number
    platform: number
    accName: number
    accId: number
    createdAt: number
    updatedAt: number
    businessAcc: number
    memberId: number
    deleted: number
    _all: number
  }


  export type PlatformAvgAggregateInputType = {
    id?: true
    businessAcc?: true
  }

  export type PlatformSumAggregateInputType = {
    id?: true
    businessAcc?: true
  }

  export type PlatformMinAggregateInputType = {
    id?: true
    platform?: true
    accName?: true
    accId?: true
    createdAt?: true
    updatedAt?: true
    businessAcc?: true
    memberId?: true
    deleted?: true
  }

  export type PlatformMaxAggregateInputType = {
    id?: true
    platform?: true
    accName?: true
    accId?: true
    createdAt?: true
    updatedAt?: true
    businessAcc?: true
    memberId?: true
    deleted?: true
  }

  export type PlatformCountAggregateInputType = {
    id?: true
    platform?: true
    accName?: true
    accId?: true
    createdAt?: true
    updatedAt?: true
    businessAcc?: true
    memberId?: true
    deleted?: true
    _all?: true
  }

  export type PlatformAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Platform to aggregate.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Platforms
    **/
    _count?: true | PlatformCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlatformAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlatformSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformMaxAggregateInputType
  }

  export type GetPlatformAggregateType<T extends PlatformAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatform]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatform[P]>
      : GetScalarType<T[P], AggregatePlatform[P]>
  }




  export type PlatformGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformWhereInput
    orderBy?: PlatformOrderByWithAggregationInput | PlatformOrderByWithAggregationInput[]
    by: PlatformScalarFieldEnum[] | PlatformScalarFieldEnum
    having?: PlatformScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformCountAggregateInputType | true
    _avg?: PlatformAvgAggregateInputType
    _sum?: PlatformSumAggregateInputType
    _min?: PlatformMinAggregateInputType
    _max?: PlatformMaxAggregateInputType
  }

  export type PlatformGroupByOutputType = {
    id: number
    platform: $Enums.SocialMedia
    accName: string
    accId: string
    createdAt: Date
    updatedAt: Date
    businessAcc: number
    memberId: string
    deleted: boolean | null
    _count: PlatformCountAggregateOutputType | null
    _avg: PlatformAvgAggregateOutputType | null
    _sum: PlatformSumAggregateOutputType | null
    _min: PlatformMinAggregateOutputType | null
    _max: PlatformMaxAggregateOutputType | null
  }

  type GetPlatformGroupByPayload<T extends PlatformGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformGroupByOutputType[P]>
        }
      >
    >


  export type PlatformSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    accName?: boolean
    accId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessAcc?: boolean
    memberId?: boolean
    deleted?: boolean
    platformId?: boolean | Platform$platformIdArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
    _count?: boolean | PlatformCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platform"]>

  export type PlatformSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    accName?: boolean
    accId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessAcc?: boolean
    memberId?: boolean
    deleted?: boolean
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platform"]>

  export type PlatformSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    accName?: boolean
    accId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessAcc?: boolean
    memberId?: boolean
    deleted?: boolean
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platform"]>

  export type PlatformSelectScalar = {
    id?: boolean
    platform?: boolean
    accName?: boolean
    accId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessAcc?: boolean
    memberId?: boolean
    deleted?: boolean
  }

  export type PlatformOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "platform" | "accName" | "accId" | "createdAt" | "updatedAt" | "businessAcc" | "memberId" | "deleted", ExtArgs["result"]["platform"]>
  export type PlatformInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platformId?: boolean | Platform$platformIdArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
    _count?: boolean | PlatformCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlatformIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type PlatformIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $PlatformPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Platform"
    objects: {
      platformId: Prisma.$AdsCostPayload<ExtArgs>[]
      businessId: Prisma.$BusinessAccPayload<ExtArgs>
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      platform: $Enums.SocialMedia
      accName: string
      accId: string
      createdAt: Date
      updatedAt: Date
      businessAcc: number
      memberId: string
      deleted: boolean | null
    }, ExtArgs["result"]["platform"]>
    composites: {}
  }

  type PlatformGetPayload<S extends boolean | null | undefined | PlatformDefaultArgs> = $Result.GetResult<Prisma.$PlatformPayload, S>

  type PlatformCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlatformFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformCountAggregateInputType | true
    }

  export interface PlatformDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Platform'], meta: { name: 'Platform' } }
    /**
     * Find zero or one Platform that matches the filter.
     * @param {PlatformFindUniqueArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformFindUniqueArgs>(args: SelectSubset<T, PlatformFindUniqueArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Platform that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlatformFindUniqueOrThrowArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Platform that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindFirstArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformFindFirstArgs>(args?: SelectSubset<T, PlatformFindFirstArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Platform that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindFirstOrThrowArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Platforms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Platforms
     * const platforms = await prisma.platform.findMany()
     * 
     * // Get first 10 Platforms
     * const platforms = await prisma.platform.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformWithIdOnly = await prisma.platform.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformFindManyArgs>(args?: SelectSubset<T, PlatformFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Platform.
     * @param {PlatformCreateArgs} args - Arguments to create a Platform.
     * @example
     * // Create one Platform
     * const Platform = await prisma.platform.create({
     *   data: {
     *     // ... data to create a Platform
     *   }
     * })
     * 
     */
    create<T extends PlatformCreateArgs>(args: SelectSubset<T, PlatformCreateArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Platforms.
     * @param {PlatformCreateManyArgs} args - Arguments to create many Platforms.
     * @example
     * // Create many Platforms
     * const platform = await prisma.platform.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformCreateManyArgs>(args?: SelectSubset<T, PlatformCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Platforms and returns the data saved in the database.
     * @param {PlatformCreateManyAndReturnArgs} args - Arguments to create many Platforms.
     * @example
     * // Create many Platforms
     * const platform = await prisma.platform.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Platforms and only return the `id`
     * const platformWithIdOnly = await prisma.platform.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Platform.
     * @param {PlatformDeleteArgs} args - Arguments to delete one Platform.
     * @example
     * // Delete one Platform
     * const Platform = await prisma.platform.delete({
     *   where: {
     *     // ... filter to delete one Platform
     *   }
     * })
     * 
     */
    delete<T extends PlatformDeleteArgs>(args: SelectSubset<T, PlatformDeleteArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Platform.
     * @param {PlatformUpdateArgs} args - Arguments to update one Platform.
     * @example
     * // Update one Platform
     * const platform = await prisma.platform.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformUpdateArgs>(args: SelectSubset<T, PlatformUpdateArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Platforms.
     * @param {PlatformDeleteManyArgs} args - Arguments to filter Platforms to delete.
     * @example
     * // Delete a few Platforms
     * const { count } = await prisma.platform.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformDeleteManyArgs>(args?: SelectSubset<T, PlatformDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Platforms
     * const platform = await prisma.platform.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformUpdateManyArgs>(args: SelectSubset<T, PlatformUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Platforms and returns the data updated in the database.
     * @param {PlatformUpdateManyAndReturnArgs} args - Arguments to update many Platforms.
     * @example
     * // Update many Platforms
     * const platform = await prisma.platform.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Platforms and only return the `id`
     * const platformWithIdOnly = await prisma.platform.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlatformUpdateManyAndReturnArgs>(args: SelectSubset<T, PlatformUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Platform.
     * @param {PlatformUpsertArgs} args - Arguments to update or create a Platform.
     * @example
     * // Update or create a Platform
     * const platform = await prisma.platform.upsert({
     *   create: {
     *     // ... data to create a Platform
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Platform we want to update
     *   }
     * })
     */
    upsert<T extends PlatformUpsertArgs>(args: SelectSubset<T, PlatformUpsertArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformCountArgs} args - Arguments to filter Platforms to count.
     * @example
     * // Count the number of Platforms
     * const count = await prisma.platform.count({
     *   where: {
     *     // ... the filter for the Platforms we want to count
     *   }
     * })
    **/
    count<T extends PlatformCountArgs>(
      args?: Subset<T, PlatformCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Platform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformAggregateArgs>(args: Subset<T, PlatformAggregateArgs>): Prisma.PrismaPromise<GetPlatformAggregateType<T>>

    /**
     * Group by Platform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformGroupByArgs['orderBy'] }
        : { orderBy?: PlatformGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Platform model
   */
  readonly fields: PlatformFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Platform.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    platformId<T extends Platform$platformIdArgs<ExtArgs> = {}>(args?: Subset<T, Platform$platformIdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessId<T extends BusinessAccDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessAccDefaultArgs<ExtArgs>>): Prisma__BusinessAccClient<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Platform model
   */
  interface PlatformFieldRefs {
    readonly id: FieldRef<"Platform", 'Int'>
    readonly platform: FieldRef<"Platform", 'SocialMedia'>
    readonly accName: FieldRef<"Platform", 'String'>
    readonly accId: FieldRef<"Platform", 'String'>
    readonly createdAt: FieldRef<"Platform", 'DateTime'>
    readonly updatedAt: FieldRef<"Platform", 'DateTime'>
    readonly businessAcc: FieldRef<"Platform", 'Int'>
    readonly memberId: FieldRef<"Platform", 'String'>
    readonly deleted: FieldRef<"Platform", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Platform findUnique
   */
  export type PlatformFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform findUniqueOrThrow
   */
  export type PlatformFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform findFirst
   */
  export type PlatformFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Platforms.
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Platforms.
     */
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Platform findFirstOrThrow
   */
  export type PlatformFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Platforms.
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Platforms.
     */
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Platform findMany
   */
  export type PlatformFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platforms to fetch.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Platforms.
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Platform create
   */
  export type PlatformCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * The data needed to create a Platform.
     */
    data: XOR<PlatformCreateInput, PlatformUncheckedCreateInput>
  }

  /**
   * Platform createMany
   */
  export type PlatformCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Platforms.
     */
    data: PlatformCreateManyInput | PlatformCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Platform createManyAndReturn
   */
  export type PlatformCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * The data used to create many Platforms.
     */
    data: PlatformCreateManyInput | PlatformCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Platform update
   */
  export type PlatformUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * The data needed to update a Platform.
     */
    data: XOR<PlatformUpdateInput, PlatformUncheckedUpdateInput>
    /**
     * Choose, which Platform to update.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform updateMany
   */
  export type PlatformUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Platforms.
     */
    data: XOR<PlatformUpdateManyMutationInput, PlatformUncheckedUpdateManyInput>
    /**
     * Filter which Platforms to update
     */
    where?: PlatformWhereInput
    /**
     * Limit how many Platforms to update.
     */
    limit?: number
  }

  /**
   * Platform updateManyAndReturn
   */
  export type PlatformUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * The data used to update Platforms.
     */
    data: XOR<PlatformUpdateManyMutationInput, PlatformUncheckedUpdateManyInput>
    /**
     * Filter which Platforms to update
     */
    where?: PlatformWhereInput
    /**
     * Limit how many Platforms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Platform upsert
   */
  export type PlatformUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * The filter to search for the Platform to update in case it exists.
     */
    where: PlatformWhereUniqueInput
    /**
     * In case the Platform found by the `where` argument doesn't exist, create a new Platform with this data.
     */
    create: XOR<PlatformCreateInput, PlatformUncheckedCreateInput>
    /**
     * In case the Platform was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformUpdateInput, PlatformUncheckedUpdateInput>
  }

  /**
   * Platform delete
   */
  export type PlatformDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter which Platform to delete.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform deleteMany
   */
  export type PlatformDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Platforms to delete
     */
    where?: PlatformWhereInput
    /**
     * Limit how many Platforms to delete.
     */
    limit?: number
  }

  /**
   * Platform.platformId
   */
  export type Platform$platformIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostInclude<ExtArgs> | null
    where?: AdsCostWhereInput
    orderBy?: AdsCostOrderByWithRelationInput | AdsCostOrderByWithRelationInput[]
    cursor?: AdsCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdsCostScalarFieldEnum | AdsCostScalarFieldEnum[]
  }

  /**
   * Platform without action
   */
  export type PlatformDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
  }


  /**
   * Model Store
   */

  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreAvgAggregateOutputType = {
    id: number | null
    businessAcc: number | null
  }

  export type StoreSumAggregateOutputType = {
    id: number | null
    businessAcc: number | null
  }

  export type StoreMinAggregateOutputType = {
    id: number | null
    platform: $Enums.IncomeChannel | null
    accName: string | null
    accId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    businessAcc: number | null
    memberId: string | null
    deleted: boolean | null
  }

  export type StoreMaxAggregateOutputType = {
    id: number | null
    platform: $Enums.IncomeChannel | null
    accName: string | null
    accId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    businessAcc: number | null
    memberId: string | null
    deleted: boolean | null
  }

  export type StoreCountAggregateOutputType = {
    id: number
    platform: number
    accName: number
    accId: number
    createdAt: number
    updatedAt: number
    businessAcc: number
    memberId: number
    deleted: number
    _all: number
  }


  export type StoreAvgAggregateInputType = {
    id?: true
    businessAcc?: true
  }

  export type StoreSumAggregateInputType = {
    id?: true
    businessAcc?: true
  }

  export type StoreMinAggregateInputType = {
    id?: true
    platform?: true
    accName?: true
    accId?: true
    createdAt?: true
    updatedAt?: true
    businessAcc?: true
    memberId?: true
    deleted?: true
  }

  export type StoreMaxAggregateInputType = {
    id?: true
    platform?: true
    accName?: true
    accId?: true
    createdAt?: true
    updatedAt?: true
    businessAcc?: true
    memberId?: true
    deleted?: true
  }

  export type StoreCountAggregateInputType = {
    id?: true
    platform?: true
    accName?: true
    accId?: true
    createdAt?: true
    updatedAt?: true
    businessAcc?: true
    memberId?: true
    deleted?: true
    _all?: true
  }

  export type StoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Store to aggregate.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type StoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithAggregationInput | StoreOrderByWithAggregationInput[]
    by: StoreScalarFieldEnum[] | StoreScalarFieldEnum
    having?: StoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _avg?: StoreAvgAggregateInputType
    _sum?: StoreSumAggregateInputType
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }

  export type StoreGroupByOutputType = {
    id: number
    platform: $Enums.IncomeChannel
    accName: string
    accId: string
    createdAt: Date
    updatedAt: Date
    businessAcc: number
    memberId: string
    deleted: boolean | null
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends StoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type StoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    accName?: boolean
    accId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessAcc?: boolean
    memberId?: boolean
    deleted?: boolean
    storefrontId?: boolean | Store$storefrontIdArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    accName?: boolean
    accId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessAcc?: boolean
    memberId?: boolean
    deleted?: boolean
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    accName?: boolean
    accId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessAcc?: boolean
    memberId?: boolean
    deleted?: boolean
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectScalar = {
    id?: boolean
    platform?: boolean
    accName?: boolean
    accId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessAcc?: boolean
    memberId?: boolean
    deleted?: boolean
  }

  export type StoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "platform" | "accName" | "accId" | "createdAt" | "updatedAt" | "businessAcc" | "memberId" | "deleted", ExtArgs["result"]["store"]>
  export type StoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storefrontId?: boolean | Store$storefrontIdArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type StoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $StorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Store"
    objects: {
      storefrontId: Prisma.$BillPayload<ExtArgs>[]
      businessId: Prisma.$BusinessAccPayload<ExtArgs>
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      platform: $Enums.IncomeChannel
      accName: string
      accId: string
      createdAt: Date
      updatedAt: Date
      businessAcc: number
      memberId: string
      deleted: boolean | null
    }, ExtArgs["result"]["store"]>
    composites: {}
  }

  type StoreGetPayload<S extends boolean | null | undefined | StoreDefaultArgs> = $Result.GetResult<Prisma.$StorePayload, S>

  type StoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface StoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Store'], meta: { name: 'Store' } }
    /**
     * Find zero or one Store that matches the filter.
     * @param {StoreFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreFindUniqueArgs>(args: SelectSubset<T, StoreFindUniqueArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Store that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoreFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreFindFirstArgs>(args?: SelectSubset<T, StoreFindFirstArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeWithIdOnly = await prisma.store.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreFindManyArgs>(args?: SelectSubset<T, StoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Store.
     * @param {StoreCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
     */
    create<T extends StoreCreateArgs>(args: SelectSubset<T, StoreCreateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stores.
     * @param {StoreCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreCreateManyArgs>(args?: SelectSubset<T, StoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {StoreCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Store.
     * @param {StoreDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
     */
    delete<T extends StoreDeleteArgs>(args: SelectSubset<T, StoreDeleteArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Store.
     * @param {StoreUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreUpdateArgs>(args: SelectSubset<T, StoreUpdateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stores.
     * @param {StoreDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreDeleteManyArgs>(args?: SelectSubset<T, StoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreUpdateManyArgs>(args: SelectSubset<T, StoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores and returns the data updated in the database.
     * @param {StoreUpdateManyAndReturnArgs} args - Arguments to update many Stores.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoreUpdateManyAndReturnArgs>(args: SelectSubset<T, StoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Store.
     * @param {StoreUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
     */
    upsert<T extends StoreUpsertArgs>(args: SelectSubset<T, StoreUpsertArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoreCountArgs>(
      args?: Subset<T, StoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreGroupByArgs['orderBy'] }
        : { orderBy?: StoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Store model
   */
  readonly fields: StoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    storefrontId<T extends Store$storefrontIdArgs<ExtArgs> = {}>(args?: Subset<T, Store$storefrontIdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessId<T extends BusinessAccDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessAccDefaultArgs<ExtArgs>>): Prisma__BusinessAccClient<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Store model
   */
  interface StoreFieldRefs {
    readonly id: FieldRef<"Store", 'Int'>
    readonly platform: FieldRef<"Store", 'IncomeChannel'>
    readonly accName: FieldRef<"Store", 'String'>
    readonly accId: FieldRef<"Store", 'String'>
    readonly createdAt: FieldRef<"Store", 'DateTime'>
    readonly updatedAt: FieldRef<"Store", 'DateTime'>
    readonly businessAcc: FieldRef<"Store", 'Int'>
    readonly memberId: FieldRef<"Store", 'String'>
    readonly deleted: FieldRef<"Store", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Store findUnique
   */
  export type StoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findUniqueOrThrow
   */
  export type StoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findFirst
   */
  export type StoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findFirstOrThrow
   */
  export type StoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findMany
   */
  export type StoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store create
   */
  export type StoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Store.
     */
    data: XOR<StoreCreateInput, StoreUncheckedCreateInput>
  }

  /**
   * Store createMany
   */
  export type StoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Store createManyAndReturn
   */
  export type StoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Store update
   */
  export type StoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Store.
     */
    data: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
    /**
     * Choose, which Store to update.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store updateMany
   */
  export type StoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
  }

  /**
   * Store updateManyAndReturn
   */
  export type StoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Store upsert
   */
  export type StoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Store to update in case it exists.
     */
    where: StoreWhereUniqueInput
    /**
     * In case the Store found by the `where` argument doesn't exist, create a new Store with this data.
     */
    create: XOR<StoreCreateInput, StoreUncheckedCreateInput>
    /**
     * In case the Store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
  }

  /**
   * Store delete
   */
  export type StoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter which Store to delete.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store deleteMany
   */
  export type StoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to delete.
     */
    limit?: number
  }

  /**
   * Store.storefrontId
   */
  export type Store$storefrontIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Store without action
   */
  export type StoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    stock: number | null
    price: number | null
    categoryId: number | null
    statusId: number | null
    businessAcc: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    stock: number | null
    price: number | null
    categoryId: number | null
    statusId: number | null
    businessAcc: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    barcode: string | null
    image: string | null
    stock: number | null
    price: number | null
    categoryId: number | null
    memberId: string | null
    statusId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted: boolean | null
    businessAcc: number | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    barcode: string | null
    image: string | null
    stock: number | null
    price: number | null
    categoryId: number | null
    memberId: string | null
    statusId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted: boolean | null
    businessAcc: number | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    barcode: number
    image: number
    stock: number
    price: number
    categoryId: number
    memberId: number
    statusId: number
    createdAt: number
    updatedAt: number
    deleted: number
    businessAcc: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    stock?: true
    price?: true
    categoryId?: true
    statusId?: true
    businessAcc?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    stock?: true
    price?: true
    categoryId?: true
    statusId?: true
    businessAcc?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    barcode?: true
    image?: true
    stock?: true
    price?: true
    categoryId?: true
    memberId?: true
    statusId?: true
    createdAt?: true
    updatedAt?: true
    deleted?: true
    businessAcc?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    barcode?: true
    image?: true
    stock?: true
    price?: true
    categoryId?: true
    memberId?: true
    statusId?: true
    createdAt?: true
    updatedAt?: true
    deleted?: true
    businessAcc?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    barcode?: true
    image?: true
    stock?: true
    price?: true
    categoryId?: true
    memberId?: true
    statusId?: true
    createdAt?: true
    updatedAt?: true
    deleted?: true
    businessAcc?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    description: string | null
    barcode: string
    image: string | null
    stock: number
    price: number
    categoryId: number | null
    memberId: string
    statusId: number | null
    createdAt: Date
    updatedAt: Date
    deleted: boolean | null
    businessAcc: number
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    barcode?: boolean
    image?: boolean
    stock?: boolean
    price?: boolean
    categoryId?: boolean
    memberId?: boolean
    statusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted?: boolean
    businessAcc?: boolean
    billRecord?: boolean | Product$billRecordArgs<ExtArgs>
    adsRecord?: boolean | Product$adsRecordArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    barcode?: boolean
    image?: boolean
    stock?: boolean
    price?: boolean
    categoryId?: boolean
    memberId?: boolean
    statusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted?: boolean
    businessAcc?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    barcode?: boolean
    image?: boolean
    stock?: boolean
    price?: boolean
    categoryId?: boolean
    memberId?: boolean
    statusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted?: boolean
    businessAcc?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    barcode?: boolean
    image?: boolean
    stock?: boolean
    price?: boolean
    categoryId?: boolean
    memberId?: boolean
    statusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted?: boolean
    businessAcc?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "barcode" | "image" | "stock" | "price" | "categoryId" | "memberId" | "statusId" | "createdAt" | "updatedAt" | "deleted" | "businessAcc", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billRecord?: boolean | Product$billRecordArgs<ExtArgs>
    adsRecord?: boolean | Product$adsRecordArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    businessId?: boolean | BusinessAccDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      billRecord: Prisma.$BillPayload<ExtArgs>[]
      adsRecord: Prisma.$AdsCostPayload<ExtArgs>[]
      member: Prisma.$MemberPayload<ExtArgs>
      businessId: Prisma.$BusinessAccPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      barcode: string
      image: string | null
      stock: number
      price: number
      categoryId: number | null
      memberId: string
      statusId: number | null
      createdAt: Date
      updatedAt: Date
      deleted: boolean | null
      businessAcc: number
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    billRecord<T extends Product$billRecordArgs<ExtArgs> = {}>(args?: Subset<T, Product$billRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adsRecord<T extends Product$adsRecordArgs<ExtArgs> = {}>(args?: Subset<T, Product$adsRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    businessId<T extends BusinessAccDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessAccDefaultArgs<ExtArgs>>): Prisma__BusinessAccClient<$Result.GetResult<Prisma.$BusinessAccPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly barcode: FieldRef<"Product", 'String'>
    readonly image: FieldRef<"Product", 'String'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly price: FieldRef<"Product", 'Int'>
    readonly categoryId: FieldRef<"Product", 'Int'>
    readonly memberId: FieldRef<"Product", 'String'>
    readonly statusId: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly deleted: FieldRef<"Product", 'Boolean'>
    readonly businessAcc: FieldRef<"Product", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.billRecord
   */
  export type Product$billRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Product.adsRecord
   */
  export type Product$adsRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsCost
     */
    select?: AdsCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsCost
     */
    omit?: AdsCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsCostInclude<ExtArgs> | null
    where?: AdsCostWhereInput
    orderBy?: AdsCostOrderByWithRelationInput | AdsCostOrderByWithRelationInput[]
    cursor?: AdsCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdsCostScalarFieldEnum | AdsCostScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Credit
   */

  export type AggregateCredit = {
    _count: CreditCountAggregateOutputType | null
    _avg: CreditAvgAggregateOutputType | null
    _sum: CreditSumAggregateOutputType | null
    _min: CreditMinAggregateOutputType | null
    _max: CreditMaxAggregateOutputType | null
  }

  export type CreditAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
    creditorId: number | null
  }

  export type CreditSumAggregateOutputType = {
    id: number | null
    ownerId: number | null
    creditorId: number | null
  }

  export type CreditMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    ownerId: number | null
    creditorId: number | null
  }

  export type CreditMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    ownerId: number | null
    creditorId: number | null
  }

  export type CreditCountAggregateOutputType = {
    id: number
    createdAt: number
    ownerId: number
    creditorId: number
    _all: number
  }


  export type CreditAvgAggregateInputType = {
    id?: true
    ownerId?: true
    creditorId?: true
  }

  export type CreditSumAggregateInputType = {
    id?: true
    ownerId?: true
    creditorId?: true
  }

  export type CreditMinAggregateInputType = {
    id?: true
    createdAt?: true
    ownerId?: true
    creditorId?: true
  }

  export type CreditMaxAggregateInputType = {
    id?: true
    createdAt?: true
    ownerId?: true
    creditorId?: true
  }

  export type CreditCountAggregateInputType = {
    id?: true
    createdAt?: true
    ownerId?: true
    creditorId?: true
    _all?: true
  }

  export type CreditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credit to aggregate.
     */
    where?: CreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credits to fetch.
     */
    orderBy?: CreditOrderByWithRelationInput | CreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Credits
    **/
    _count?: true | CreditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditMaxAggregateInputType
  }

  export type GetCreditAggregateType<T extends CreditAggregateArgs> = {
        [P in keyof T & keyof AggregateCredit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredit[P]>
      : GetScalarType<T[P], AggregateCredit[P]>
  }




  export type CreditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditWhereInput
    orderBy?: CreditOrderByWithAggregationInput | CreditOrderByWithAggregationInput[]
    by: CreditScalarFieldEnum[] | CreditScalarFieldEnum
    having?: CreditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditCountAggregateInputType | true
    _avg?: CreditAvgAggregateInputType
    _sum?: CreditSumAggregateInputType
    _min?: CreditMinAggregateInputType
    _max?: CreditMaxAggregateInputType
  }

  export type CreditGroupByOutputType = {
    id: number
    createdAt: Date
    ownerId: number
    creditorId: number
    _count: CreditCountAggregateOutputType | null
    _avg: CreditAvgAggregateOutputType | null
    _sum: CreditSumAggregateOutputType | null
    _min: CreditMinAggregateOutputType | null
    _max: CreditMaxAggregateOutputType | null
  }

  type GetCreditGroupByPayload<T extends CreditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditGroupByOutputType[P]>
            : GetScalarType<T[P], CreditGroupByOutputType[P]>
        }
      >
    >


  export type CreditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    ownerId?: boolean
    creditorId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    creditor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credit"]>

  export type CreditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    ownerId?: boolean
    creditorId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    creditor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credit"]>

  export type CreditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    ownerId?: boolean
    creditorId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    creditor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credit"]>

  export type CreditSelectScalar = {
    id?: boolean
    createdAt?: boolean
    ownerId?: boolean
    creditorId?: boolean
  }

  export type CreditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "ownerId" | "creditorId", ExtArgs["result"]["credit"]>
  export type CreditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    creditor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CreditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    creditor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CreditIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    creditor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CreditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Credit"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      creditor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      ownerId: number
      creditorId: number
    }, ExtArgs["result"]["credit"]>
    composites: {}
  }

  type CreditGetPayload<S extends boolean | null | undefined | CreditDefaultArgs> = $Result.GetResult<Prisma.$CreditPayload, S>

  type CreditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditCountAggregateInputType | true
    }

  export interface CreditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Credit'], meta: { name: 'Credit' } }
    /**
     * Find zero or one Credit that matches the filter.
     * @param {CreditFindUniqueArgs} args - Arguments to find a Credit
     * @example
     * // Get one Credit
     * const credit = await prisma.credit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditFindUniqueArgs>(args: SelectSubset<T, CreditFindUniqueArgs<ExtArgs>>): Prisma__CreditClient<$Result.GetResult<Prisma.$CreditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Credit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditFindUniqueOrThrowArgs} args - Arguments to find a Credit
     * @example
     * // Get one Credit
     * const credit = await prisma.credit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditClient<$Result.GetResult<Prisma.$CreditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditFindFirstArgs} args - Arguments to find a Credit
     * @example
     * // Get one Credit
     * const credit = await prisma.credit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditFindFirstArgs>(args?: SelectSubset<T, CreditFindFirstArgs<ExtArgs>>): Prisma__CreditClient<$Result.GetResult<Prisma.$CreditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditFindFirstOrThrowArgs} args - Arguments to find a Credit
     * @example
     * // Get one Credit
     * const credit = await prisma.credit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditClient<$Result.GetResult<Prisma.$CreditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Credits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credits
     * const credits = await prisma.credit.findMany()
     * 
     * // Get first 10 Credits
     * const credits = await prisma.credit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditWithIdOnly = await prisma.credit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditFindManyArgs>(args?: SelectSubset<T, CreditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Credit.
     * @param {CreditCreateArgs} args - Arguments to create a Credit.
     * @example
     * // Create one Credit
     * const Credit = await prisma.credit.create({
     *   data: {
     *     // ... data to create a Credit
     *   }
     * })
     * 
     */
    create<T extends CreditCreateArgs>(args: SelectSubset<T, CreditCreateArgs<ExtArgs>>): Prisma__CreditClient<$Result.GetResult<Prisma.$CreditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Credits.
     * @param {CreditCreateManyArgs} args - Arguments to create many Credits.
     * @example
     * // Create many Credits
     * const credit = await prisma.credit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditCreateManyArgs>(args?: SelectSubset<T, CreditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Credits and returns the data saved in the database.
     * @param {CreditCreateManyAndReturnArgs} args - Arguments to create many Credits.
     * @example
     * // Create many Credits
     * const credit = await prisma.credit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Credits and only return the `id`
     * const creditWithIdOnly = await prisma.credit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Credit.
     * @param {CreditDeleteArgs} args - Arguments to delete one Credit.
     * @example
     * // Delete one Credit
     * const Credit = await prisma.credit.delete({
     *   where: {
     *     // ... filter to delete one Credit
     *   }
     * })
     * 
     */
    delete<T extends CreditDeleteArgs>(args: SelectSubset<T, CreditDeleteArgs<ExtArgs>>): Prisma__CreditClient<$Result.GetResult<Prisma.$CreditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Credit.
     * @param {CreditUpdateArgs} args - Arguments to update one Credit.
     * @example
     * // Update one Credit
     * const credit = await prisma.credit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditUpdateArgs>(args: SelectSubset<T, CreditUpdateArgs<ExtArgs>>): Prisma__CreditClient<$Result.GetResult<Prisma.$CreditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Credits.
     * @param {CreditDeleteManyArgs} args - Arguments to filter Credits to delete.
     * @example
     * // Delete a few Credits
     * const { count } = await prisma.credit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditDeleteManyArgs>(args?: SelectSubset<T, CreditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credits
     * const credit = await prisma.credit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditUpdateManyArgs>(args: SelectSubset<T, CreditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credits and returns the data updated in the database.
     * @param {CreditUpdateManyAndReturnArgs} args - Arguments to update many Credits.
     * @example
     * // Update many Credits
     * const credit = await prisma.credit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Credits and only return the `id`
     * const creditWithIdOnly = await prisma.credit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Credit.
     * @param {CreditUpsertArgs} args - Arguments to update or create a Credit.
     * @example
     * // Update or create a Credit
     * const credit = await prisma.credit.upsert({
     *   create: {
     *     // ... data to create a Credit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credit we want to update
     *   }
     * })
     */
    upsert<T extends CreditUpsertArgs>(args: SelectSubset<T, CreditUpsertArgs<ExtArgs>>): Prisma__CreditClient<$Result.GetResult<Prisma.$CreditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Credits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditCountArgs} args - Arguments to filter Credits to count.
     * @example
     * // Count the number of Credits
     * const count = await prisma.credit.count({
     *   where: {
     *     // ... the filter for the Credits we want to count
     *   }
     * })
    **/
    count<T extends CreditCountArgs>(
      args?: Subset<T, CreditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditAggregateArgs>(args: Subset<T, CreditAggregateArgs>): Prisma.PrismaPromise<GetCreditAggregateType<T>>

    /**
     * Group by Credit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditGroupByArgs['orderBy'] }
        : { orderBy?: CreditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Credit model
   */
  readonly fields: CreditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Credit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creditor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Credit model
   */
  interface CreditFieldRefs {
    readonly id: FieldRef<"Credit", 'Int'>
    readonly createdAt: FieldRef<"Credit", 'DateTime'>
    readonly ownerId: FieldRef<"Credit", 'Int'>
    readonly creditorId: FieldRef<"Credit", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Credit findUnique
   */
  export type CreditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credit
     */
    omit?: CreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * Filter, which Credit to fetch.
     */
    where: CreditWhereUniqueInput
  }

  /**
   * Credit findUniqueOrThrow
   */
  export type CreditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credit
     */
    omit?: CreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * Filter, which Credit to fetch.
     */
    where: CreditWhereUniqueInput
  }

  /**
   * Credit findFirst
   */
  export type CreditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credit
     */
    omit?: CreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * Filter, which Credit to fetch.
     */
    where?: CreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credits to fetch.
     */
    orderBy?: CreditOrderByWithRelationInput | CreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credits.
     */
    cursor?: CreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credits.
     */
    distinct?: CreditScalarFieldEnum | CreditScalarFieldEnum[]
  }

  /**
   * Credit findFirstOrThrow
   */
  export type CreditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credit
     */
    omit?: CreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * Filter, which Credit to fetch.
     */
    where?: CreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credits to fetch.
     */
    orderBy?: CreditOrderByWithRelationInput | CreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credits.
     */
    cursor?: CreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credits.
     */
    distinct?: CreditScalarFieldEnum | CreditScalarFieldEnum[]
  }

  /**
   * Credit findMany
   */
  export type CreditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credit
     */
    omit?: CreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * Filter, which Credits to fetch.
     */
    where?: CreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credits to fetch.
     */
    orderBy?: CreditOrderByWithRelationInput | CreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Credits.
     */
    cursor?: CreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credits.
     */
    skip?: number
    distinct?: CreditScalarFieldEnum | CreditScalarFieldEnum[]
  }

  /**
   * Credit create
   */
  export type CreditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credit
     */
    omit?: CreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * The data needed to create a Credit.
     */
    data: XOR<CreditCreateInput, CreditUncheckedCreateInput>
  }

  /**
   * Credit createMany
   */
  export type CreditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Credits.
     */
    data: CreditCreateManyInput | CreditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Credit createManyAndReturn
   */
  export type CreditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Credit
     */
    omit?: CreditOmit<ExtArgs> | null
    /**
     * The data used to create many Credits.
     */
    data: CreditCreateManyInput | CreditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Credit update
   */
  export type CreditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credit
     */
    omit?: CreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * The data needed to update a Credit.
     */
    data: XOR<CreditUpdateInput, CreditUncheckedUpdateInput>
    /**
     * Choose, which Credit to update.
     */
    where: CreditWhereUniqueInput
  }

  /**
   * Credit updateMany
   */
  export type CreditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Credits.
     */
    data: XOR<CreditUpdateManyMutationInput, CreditUncheckedUpdateManyInput>
    /**
     * Filter which Credits to update
     */
    where?: CreditWhereInput
    /**
     * Limit how many Credits to update.
     */
    limit?: number
  }

  /**
   * Credit updateManyAndReturn
   */
  export type CreditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Credit
     */
    omit?: CreditOmit<ExtArgs> | null
    /**
     * The data used to update Credits.
     */
    data: XOR<CreditUpdateManyMutationInput, CreditUncheckedUpdateManyInput>
    /**
     * Filter which Credits to update
     */
    where?: CreditWhereInput
    /**
     * Limit how many Credits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Credit upsert
   */
  export type CreditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credit
     */
    omit?: CreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * The filter to search for the Credit to update in case it exists.
     */
    where: CreditWhereUniqueInput
    /**
     * In case the Credit found by the `where` argument doesn't exist, create a new Credit with this data.
     */
    create: XOR<CreditCreateInput, CreditUncheckedCreateInput>
    /**
     * In case the Credit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditUpdateInput, CreditUncheckedUpdateInput>
  }

  /**
   * Credit delete
   */
  export type CreditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credit
     */
    omit?: CreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * Filter which Credit to delete.
     */
    where: CreditWhereUniqueInput
  }

  /**
   * Credit deleteMany
   */
  export type CreditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credits to delete
     */
    where?: CreditWhereInput
    /**
     * Limit how many Credits to delete.
     */
    limit?: number
  }

  /**
   * Credit without action
   */
  export type CreditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credit
     */
    omit?: CreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
    authorId: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    mediaUrl: string | null
    mediaType: $Enums.MediaType | null
    published: boolean | null
    authorId: number | null
    deleted: boolean | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    mediaUrl: string | null
    mediaType: $Enums.MediaType | null
    published: boolean | null
    authorId: number | null
    deleted: boolean | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    hashtag: number
    content: number
    mediaUrl: number
    mediaType: number
    published: number
    authorId: number
    deleted: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
    authorId?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
    authorId?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    mediaUrl?: true
    mediaType?: true
    published?: true
    authorId?: true
    deleted?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    mediaUrl?: true
    mediaType?: true
    published?: true
    authorId?: true
    deleted?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    hashtag?: true
    content?: true
    mediaUrl?: true
    mediaType?: true
    published?: true
    authorId?: true
    deleted?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    hashtag: string[]
    content: string | null
    mediaUrl: string | null
    mediaType: $Enums.MediaType | null
    published: boolean
    authorId: number
    deleted: boolean | null
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hashtag?: boolean
    content?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    published?: boolean
    authorId?: boolean
    deleted?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    reactions?: boolean | Post$reactionsArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hashtag?: boolean
    content?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    published?: boolean
    authorId?: boolean
    deleted?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hashtag?: boolean
    content?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    published?: boolean
    authorId?: boolean
    deleted?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hashtag?: boolean
    content?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    published?: boolean
    authorId?: boolean
    deleted?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "hashtag" | "content" | "mediaUrl" | "mediaType" | "published" | "authorId" | "deleted", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    reactions?: boolean | Post$reactionsArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      reactions: Prisma.$ReactionPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      hashtag: string[]
      content: string | null
      mediaUrl: string | null
      mediaType: $Enums.MediaType | null
      published: boolean
      authorId: number
      deleted: boolean | null
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reactions<T extends Post$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, Post$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'Int'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
    readonly hashtag: FieldRef<"Post", 'String[]'>
    readonly content: FieldRef<"Post", 'String'>
    readonly mediaUrl: FieldRef<"Post", 'String'>
    readonly mediaType: FieldRef<"Post", 'MediaType'>
    readonly published: FieldRef<"Post", 'Boolean'>
    readonly authorId: FieldRef<"Post", 'Int'>
    readonly deleted: FieldRef<"Post", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.reactions
   */
  export type Post$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    cursor?: ReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Reaction
   */

  export type AggregateReaction = {
    _count: ReactionCountAggregateOutputType | null
    _avg: ReactionAvgAggregateOutputType | null
    _sum: ReactionSumAggregateOutputType | null
    _min: ReactionMinAggregateOutputType | null
    _max: ReactionMaxAggregateOutputType | null
  }

  export type ReactionAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type ReactionSumAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type ReactionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    type: $Enums.ReactionType | null
    postId: number | null
    userId: number | null
  }

  export type ReactionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    type: $Enums.ReactionType | null
    postId: number | null
    userId: number | null
  }

  export type ReactionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    type: number
    postId: number
    userId: number
    _all: number
  }


  export type ReactionAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type ReactionSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type ReactionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    postId?: true
    userId?: true
  }

  export type ReactionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    postId?: true
    userId?: true
  }

  export type ReactionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    postId?: true
    userId?: true
    _all?: true
  }

  export type ReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reaction to aggregate.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reactions
    **/
    _count?: true | ReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReactionMaxAggregateInputType
  }

  export type GetReactionAggregateType<T extends ReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReaction[P]>
      : GetScalarType<T[P], AggregateReaction[P]>
  }




  export type ReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithAggregationInput | ReactionOrderByWithAggregationInput[]
    by: ReactionScalarFieldEnum[] | ReactionScalarFieldEnum
    having?: ReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReactionCountAggregateInputType | true
    _avg?: ReactionAvgAggregateInputType
    _sum?: ReactionSumAggregateInputType
    _min?: ReactionMinAggregateInputType
    _max?: ReactionMaxAggregateInputType
  }

  export type ReactionGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    type: $Enums.ReactionType
    postId: number
    userId: number
    _count: ReactionCountAggregateOutputType | null
    _avg: ReactionAvgAggregateOutputType | null
    _sum: ReactionSumAggregateOutputType | null
    _min: ReactionMinAggregateOutputType | null
    _max: ReactionMaxAggregateOutputType | null
  }

  type GetReactionGroupByPayload<T extends ReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReactionGroupByOutputType[P]>
            : GetScalarType<T[P], ReactionGroupByOutputType[P]>
        }
      >
    >


  export type ReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    postId?: boolean
    userId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>

  export type ReactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    postId?: boolean
    userId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>

  export type ReactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    postId?: boolean
    userId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>

  export type ReactionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    postId?: boolean
    userId?: boolean
  }

  export type ReactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "type" | "postId" | "userId", ExtArgs["result"]["reaction"]>
  export type ReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reaction"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      type: $Enums.ReactionType
      postId: number
      userId: number
    }, ExtArgs["result"]["reaction"]>
    composites: {}
  }

  type ReactionGetPayload<S extends boolean | null | undefined | ReactionDefaultArgs> = $Result.GetResult<Prisma.$ReactionPayload, S>

  type ReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReactionCountAggregateInputType | true
    }

  export interface ReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reaction'], meta: { name: 'Reaction' } }
    /**
     * Find zero or one Reaction that matches the filter.
     * @param {ReactionFindUniqueArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReactionFindUniqueArgs>(args: SelectSubset<T, ReactionFindUniqueArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReactionFindUniqueOrThrowArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindFirstArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReactionFindFirstArgs>(args?: SelectSubset<T, ReactionFindFirstArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindFirstOrThrowArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reactions
     * const reactions = await prisma.reaction.findMany()
     * 
     * // Get first 10 Reactions
     * const reactions = await prisma.reaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reactionWithIdOnly = await prisma.reaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReactionFindManyArgs>(args?: SelectSubset<T, ReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reaction.
     * @param {ReactionCreateArgs} args - Arguments to create a Reaction.
     * @example
     * // Create one Reaction
     * const Reaction = await prisma.reaction.create({
     *   data: {
     *     // ... data to create a Reaction
     *   }
     * })
     * 
     */
    create<T extends ReactionCreateArgs>(args: SelectSubset<T, ReactionCreateArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reactions.
     * @param {ReactionCreateManyArgs} args - Arguments to create many Reactions.
     * @example
     * // Create many Reactions
     * const reaction = await prisma.reaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReactionCreateManyArgs>(args?: SelectSubset<T, ReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reactions and returns the data saved in the database.
     * @param {ReactionCreateManyAndReturnArgs} args - Arguments to create many Reactions.
     * @example
     * // Create many Reactions
     * const reaction = await prisma.reaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reactions and only return the `id`
     * const reactionWithIdOnly = await prisma.reaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ReactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reaction.
     * @param {ReactionDeleteArgs} args - Arguments to delete one Reaction.
     * @example
     * // Delete one Reaction
     * const Reaction = await prisma.reaction.delete({
     *   where: {
     *     // ... filter to delete one Reaction
     *   }
     * })
     * 
     */
    delete<T extends ReactionDeleteArgs>(args: SelectSubset<T, ReactionDeleteArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reaction.
     * @param {ReactionUpdateArgs} args - Arguments to update one Reaction.
     * @example
     * // Update one Reaction
     * const reaction = await prisma.reaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReactionUpdateArgs>(args: SelectSubset<T, ReactionUpdateArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reactions.
     * @param {ReactionDeleteManyArgs} args - Arguments to filter Reactions to delete.
     * @example
     * // Delete a few Reactions
     * const { count } = await prisma.reaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReactionDeleteManyArgs>(args?: SelectSubset<T, ReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reactions
     * const reaction = await prisma.reaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReactionUpdateManyArgs>(args: SelectSubset<T, ReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reactions and returns the data updated in the database.
     * @param {ReactionUpdateManyAndReturnArgs} args - Arguments to update many Reactions.
     * @example
     * // Update many Reactions
     * const reaction = await prisma.reaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reactions and only return the `id`
     * const reactionWithIdOnly = await prisma.reaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReactionUpdateManyAndReturnArgs>(args: SelectSubset<T, ReactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reaction.
     * @param {ReactionUpsertArgs} args - Arguments to update or create a Reaction.
     * @example
     * // Update or create a Reaction
     * const reaction = await prisma.reaction.upsert({
     *   create: {
     *     // ... data to create a Reaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reaction we want to update
     *   }
     * })
     */
    upsert<T extends ReactionUpsertArgs>(args: SelectSubset<T, ReactionUpsertArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionCountArgs} args - Arguments to filter Reactions to count.
     * @example
     * // Count the number of Reactions
     * const count = await prisma.reaction.count({
     *   where: {
     *     // ... the filter for the Reactions we want to count
     *   }
     * })
    **/
    count<T extends ReactionCountArgs>(
      args?: Subset<T, ReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReactionAggregateArgs>(args: Subset<T, ReactionAggregateArgs>): Prisma.PrismaPromise<GetReactionAggregateType<T>>

    /**
     * Group by Reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReactionGroupByArgs['orderBy'] }
        : { orderBy?: ReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reaction model
   */
  readonly fields: ReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reaction model
   */
  interface ReactionFieldRefs {
    readonly id: FieldRef<"Reaction", 'Int'>
    readonly createdAt: FieldRef<"Reaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Reaction", 'DateTime'>
    readonly type: FieldRef<"Reaction", 'ReactionType'>
    readonly postId: FieldRef<"Reaction", 'Int'>
    readonly userId: FieldRef<"Reaction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Reaction findUnique
   */
  export type ReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction findUniqueOrThrow
   */
  export type ReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction findFirst
   */
  export type ReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reactions.
     */
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction findFirstOrThrow
   */
  export type ReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reactions.
     */
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction findMany
   */
  export type ReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reactions to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction create
   */
  export type ReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Reaction.
     */
    data: XOR<ReactionCreateInput, ReactionUncheckedCreateInput>
  }

  /**
   * Reaction createMany
   */
  export type ReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reactions.
     */
    data: ReactionCreateManyInput | ReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reaction createManyAndReturn
   */
  export type ReactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * The data used to create many Reactions.
     */
    data: ReactionCreateManyInput | ReactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reaction update
   */
  export type ReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Reaction.
     */
    data: XOR<ReactionUpdateInput, ReactionUncheckedUpdateInput>
    /**
     * Choose, which Reaction to update.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction updateMany
   */
  export type ReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reactions.
     */
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyInput>
    /**
     * Filter which Reactions to update
     */
    where?: ReactionWhereInput
    /**
     * Limit how many Reactions to update.
     */
    limit?: number
  }

  /**
   * Reaction updateManyAndReturn
   */
  export type ReactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * The data used to update Reactions.
     */
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyInput>
    /**
     * Filter which Reactions to update
     */
    where?: ReactionWhereInput
    /**
     * Limit how many Reactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reaction upsert
   */
  export type ReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Reaction to update in case it exists.
     */
    where: ReactionWhereUniqueInput
    /**
     * In case the Reaction found by the `where` argument doesn't exist, create a new Reaction with this data.
     */
    create: XOR<ReactionCreateInput, ReactionUncheckedCreateInput>
    /**
     * In case the Reaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReactionUpdateInput, ReactionUncheckedUpdateInput>
  }

  /**
   * Reaction delete
   */
  export type ReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter which Reaction to delete.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction deleteMany
   */
  export type ReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reactions to delete
     */
    where?: ReactionWhereInput
    /**
     * Limit how many Reactions to delete.
     */
    limit?: number
  }

  /**
   * Reaction without action
   */
  export type ReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    postId: number | null
    userId: number | null
    deleted: boolean | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    postId: number | null
    userId: number | null
    deleted: boolean | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    content: number
    postId: number
    userId: number
    deleted: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    postId?: true
    userId?: true
    deleted?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    postId?: true
    userId?: true
    deleted?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    postId?: true
    userId?: true
    deleted?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    content: string
    postId: number
    userId: number
    deleted: boolean | null
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    postId?: boolean
    userId?: boolean
    deleted?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    postId?: boolean
    userId?: boolean
    deleted?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    postId?: boolean
    userId?: boolean
    deleted?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    postId?: boolean
    userId?: boolean
    deleted?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "content" | "postId" | "userId" | "deleted", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      content: string
      postId: number
      userId: number
      deleted: boolean | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'Int'>
    readonly userId: FieldRef<"Comment", 'Int'>
    readonly deleted: FieldRef<"Comment", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Inbox
   */

  export type AggregateInbox = {
    _count: InboxCountAggregateOutputType | null
    _avg: InboxAvgAggregateOutputType | null
    _sum: InboxSumAggregateOutputType | null
    _min: InboxMinAggregateOutputType | null
    _max: InboxMaxAggregateOutputType | null
  }

  export type InboxAvgAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
  }

  export type InboxSumAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
  }

  export type InboxMinAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    read: boolean | null
    unsent: boolean | null
    deleted: boolean | null
  }

  export type InboxMaxAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    read: boolean | null
    unsent: boolean | null
    deleted: boolean | null
  }

  export type InboxCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    message: number
    createdAt: number
    updatedAt: number
    read: number
    unsent: number
    deleted: number
    _all: number
  }


  export type InboxAvgAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
  }

  export type InboxSumAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
  }

  export type InboxMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    read?: true
    unsent?: true
    deleted?: true
  }

  export type InboxMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    read?: true
    unsent?: true
    deleted?: true
  }

  export type InboxCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    read?: true
    unsent?: true
    deleted?: true
    _all?: true
  }

  export type InboxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inbox to aggregate.
     */
    where?: InboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inboxes to fetch.
     */
    orderBy?: InboxOrderByWithRelationInput | InboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inboxes
    **/
    _count?: true | InboxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InboxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InboxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InboxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InboxMaxAggregateInputType
  }

  export type GetInboxAggregateType<T extends InboxAggregateArgs> = {
        [P in keyof T & keyof AggregateInbox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInbox[P]>
      : GetScalarType<T[P], AggregateInbox[P]>
  }




  export type InboxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InboxWhereInput
    orderBy?: InboxOrderByWithAggregationInput | InboxOrderByWithAggregationInput[]
    by: InboxScalarFieldEnum[] | InboxScalarFieldEnum
    having?: InboxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InboxCountAggregateInputType | true
    _avg?: InboxAvgAggregateInputType
    _sum?: InboxSumAggregateInputType
    _min?: InboxMinAggregateInputType
    _max?: InboxMaxAggregateInputType
  }

  export type InboxGroupByOutputType = {
    id: number
    senderId: number
    receiverId: number
    message: string
    createdAt: Date
    updatedAt: Date
    read: boolean
    unsent: boolean
    deleted: boolean | null
    _count: InboxCountAggregateOutputType | null
    _avg: InboxAvgAggregateOutputType | null
    _sum: InboxSumAggregateOutputType | null
    _min: InboxMinAggregateOutputType | null
    _max: InboxMaxAggregateOutputType | null
  }

  type GetInboxGroupByPayload<T extends InboxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InboxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InboxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InboxGroupByOutputType[P]>
            : GetScalarType<T[P], InboxGroupByOutputType[P]>
        }
      >
    >


  export type InboxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    read?: boolean
    unsent?: boolean
    deleted?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inbox"]>

  export type InboxSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    read?: boolean
    unsent?: boolean
    deleted?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inbox"]>

  export type InboxSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    read?: boolean
    unsent?: boolean
    deleted?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inbox"]>

  export type InboxSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    read?: boolean
    unsent?: boolean
    deleted?: boolean
  }

  export type InboxOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "receiverId" | "message" | "createdAt" | "updatedAt" | "read" | "unsent" | "deleted", ExtArgs["result"]["inbox"]>
  export type InboxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InboxIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InboxIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InboxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inbox"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      senderId: number
      receiverId: number
      message: string
      createdAt: Date
      updatedAt: Date
      read: boolean
      unsent: boolean
      deleted: boolean | null
    }, ExtArgs["result"]["inbox"]>
    composites: {}
  }

  type InboxGetPayload<S extends boolean | null | undefined | InboxDefaultArgs> = $Result.GetResult<Prisma.$InboxPayload, S>

  type InboxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InboxFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InboxCountAggregateInputType | true
    }

  export interface InboxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inbox'], meta: { name: 'Inbox' } }
    /**
     * Find zero or one Inbox that matches the filter.
     * @param {InboxFindUniqueArgs} args - Arguments to find a Inbox
     * @example
     * // Get one Inbox
     * const inbox = await prisma.inbox.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InboxFindUniqueArgs>(args: SelectSubset<T, InboxFindUniqueArgs<ExtArgs>>): Prisma__InboxClient<$Result.GetResult<Prisma.$InboxPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inbox that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InboxFindUniqueOrThrowArgs} args - Arguments to find a Inbox
     * @example
     * // Get one Inbox
     * const inbox = await prisma.inbox.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InboxFindUniqueOrThrowArgs>(args: SelectSubset<T, InboxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InboxClient<$Result.GetResult<Prisma.$InboxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inbox that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InboxFindFirstArgs} args - Arguments to find a Inbox
     * @example
     * // Get one Inbox
     * const inbox = await prisma.inbox.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InboxFindFirstArgs>(args?: SelectSubset<T, InboxFindFirstArgs<ExtArgs>>): Prisma__InboxClient<$Result.GetResult<Prisma.$InboxPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inbox that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InboxFindFirstOrThrowArgs} args - Arguments to find a Inbox
     * @example
     * // Get one Inbox
     * const inbox = await prisma.inbox.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InboxFindFirstOrThrowArgs>(args?: SelectSubset<T, InboxFindFirstOrThrowArgs<ExtArgs>>): Prisma__InboxClient<$Result.GetResult<Prisma.$InboxPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inboxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InboxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inboxes
     * const inboxes = await prisma.inbox.findMany()
     * 
     * // Get first 10 Inboxes
     * const inboxes = await prisma.inbox.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inboxWithIdOnly = await prisma.inbox.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InboxFindManyArgs>(args?: SelectSubset<T, InboxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InboxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inbox.
     * @param {InboxCreateArgs} args - Arguments to create a Inbox.
     * @example
     * // Create one Inbox
     * const Inbox = await prisma.inbox.create({
     *   data: {
     *     // ... data to create a Inbox
     *   }
     * })
     * 
     */
    create<T extends InboxCreateArgs>(args: SelectSubset<T, InboxCreateArgs<ExtArgs>>): Prisma__InboxClient<$Result.GetResult<Prisma.$InboxPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inboxes.
     * @param {InboxCreateManyArgs} args - Arguments to create many Inboxes.
     * @example
     * // Create many Inboxes
     * const inbox = await prisma.inbox.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InboxCreateManyArgs>(args?: SelectSubset<T, InboxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inboxes and returns the data saved in the database.
     * @param {InboxCreateManyAndReturnArgs} args - Arguments to create many Inboxes.
     * @example
     * // Create many Inboxes
     * const inbox = await prisma.inbox.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inboxes and only return the `id`
     * const inboxWithIdOnly = await prisma.inbox.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InboxCreateManyAndReturnArgs>(args?: SelectSubset<T, InboxCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InboxPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inbox.
     * @param {InboxDeleteArgs} args - Arguments to delete one Inbox.
     * @example
     * // Delete one Inbox
     * const Inbox = await prisma.inbox.delete({
     *   where: {
     *     // ... filter to delete one Inbox
     *   }
     * })
     * 
     */
    delete<T extends InboxDeleteArgs>(args: SelectSubset<T, InboxDeleteArgs<ExtArgs>>): Prisma__InboxClient<$Result.GetResult<Prisma.$InboxPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inbox.
     * @param {InboxUpdateArgs} args - Arguments to update one Inbox.
     * @example
     * // Update one Inbox
     * const inbox = await prisma.inbox.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InboxUpdateArgs>(args: SelectSubset<T, InboxUpdateArgs<ExtArgs>>): Prisma__InboxClient<$Result.GetResult<Prisma.$InboxPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inboxes.
     * @param {InboxDeleteManyArgs} args - Arguments to filter Inboxes to delete.
     * @example
     * // Delete a few Inboxes
     * const { count } = await prisma.inbox.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InboxDeleteManyArgs>(args?: SelectSubset<T, InboxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InboxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inboxes
     * const inbox = await prisma.inbox.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InboxUpdateManyArgs>(args: SelectSubset<T, InboxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inboxes and returns the data updated in the database.
     * @param {InboxUpdateManyAndReturnArgs} args - Arguments to update many Inboxes.
     * @example
     * // Update many Inboxes
     * const inbox = await prisma.inbox.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inboxes and only return the `id`
     * const inboxWithIdOnly = await prisma.inbox.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InboxUpdateManyAndReturnArgs>(args: SelectSubset<T, InboxUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InboxPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inbox.
     * @param {InboxUpsertArgs} args - Arguments to update or create a Inbox.
     * @example
     * // Update or create a Inbox
     * const inbox = await prisma.inbox.upsert({
     *   create: {
     *     // ... data to create a Inbox
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inbox we want to update
     *   }
     * })
     */
    upsert<T extends InboxUpsertArgs>(args: SelectSubset<T, InboxUpsertArgs<ExtArgs>>): Prisma__InboxClient<$Result.GetResult<Prisma.$InboxPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InboxCountArgs} args - Arguments to filter Inboxes to count.
     * @example
     * // Count the number of Inboxes
     * const count = await prisma.inbox.count({
     *   where: {
     *     // ... the filter for the Inboxes we want to count
     *   }
     * })
    **/
    count<T extends InboxCountArgs>(
      args?: Subset<T, InboxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InboxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InboxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InboxAggregateArgs>(args: Subset<T, InboxAggregateArgs>): Prisma.PrismaPromise<GetInboxAggregateType<T>>

    /**
     * Group by Inbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InboxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InboxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InboxGroupByArgs['orderBy'] }
        : { orderBy?: InboxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InboxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInboxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inbox model
   */
  readonly fields: InboxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inbox.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InboxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inbox model
   */
  interface InboxFieldRefs {
    readonly id: FieldRef<"Inbox", 'Int'>
    readonly senderId: FieldRef<"Inbox", 'Int'>
    readonly receiverId: FieldRef<"Inbox", 'Int'>
    readonly message: FieldRef<"Inbox", 'String'>
    readonly createdAt: FieldRef<"Inbox", 'DateTime'>
    readonly updatedAt: FieldRef<"Inbox", 'DateTime'>
    readonly read: FieldRef<"Inbox", 'Boolean'>
    readonly unsent: FieldRef<"Inbox", 'Boolean'>
    readonly deleted: FieldRef<"Inbox", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Inbox findUnique
   */
  export type InboxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inbox
     */
    select?: InboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inbox
     */
    omit?: InboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboxInclude<ExtArgs> | null
    /**
     * Filter, which Inbox to fetch.
     */
    where: InboxWhereUniqueInput
  }

  /**
   * Inbox findUniqueOrThrow
   */
  export type InboxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inbox
     */
    select?: InboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inbox
     */
    omit?: InboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboxInclude<ExtArgs> | null
    /**
     * Filter, which Inbox to fetch.
     */
    where: InboxWhereUniqueInput
  }

  /**
   * Inbox findFirst
   */
  export type InboxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inbox
     */
    select?: InboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inbox
     */
    omit?: InboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboxInclude<ExtArgs> | null
    /**
     * Filter, which Inbox to fetch.
     */
    where?: InboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inboxes to fetch.
     */
    orderBy?: InboxOrderByWithRelationInput | InboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inboxes.
     */
    cursor?: InboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inboxes.
     */
    distinct?: InboxScalarFieldEnum | InboxScalarFieldEnum[]
  }

  /**
   * Inbox findFirstOrThrow
   */
  export type InboxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inbox
     */
    select?: InboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inbox
     */
    omit?: InboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboxInclude<ExtArgs> | null
    /**
     * Filter, which Inbox to fetch.
     */
    where?: InboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inboxes to fetch.
     */
    orderBy?: InboxOrderByWithRelationInput | InboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inboxes.
     */
    cursor?: InboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inboxes.
     */
    distinct?: InboxScalarFieldEnum | InboxScalarFieldEnum[]
  }

  /**
   * Inbox findMany
   */
  export type InboxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inbox
     */
    select?: InboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inbox
     */
    omit?: InboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboxInclude<ExtArgs> | null
    /**
     * Filter, which Inboxes to fetch.
     */
    where?: InboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inboxes to fetch.
     */
    orderBy?: InboxOrderByWithRelationInput | InboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inboxes.
     */
    cursor?: InboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inboxes.
     */
    skip?: number
    distinct?: InboxScalarFieldEnum | InboxScalarFieldEnum[]
  }

  /**
   * Inbox create
   */
  export type InboxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inbox
     */
    select?: InboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inbox
     */
    omit?: InboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboxInclude<ExtArgs> | null
    /**
     * The data needed to create a Inbox.
     */
    data: XOR<InboxCreateInput, InboxUncheckedCreateInput>
  }

  /**
   * Inbox createMany
   */
  export type InboxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inboxes.
     */
    data: InboxCreateManyInput | InboxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inbox createManyAndReturn
   */
  export type InboxCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inbox
     */
    select?: InboxSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inbox
     */
    omit?: InboxOmit<ExtArgs> | null
    /**
     * The data used to create many Inboxes.
     */
    data: InboxCreateManyInput | InboxCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboxIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inbox update
   */
  export type InboxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inbox
     */
    select?: InboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inbox
     */
    omit?: InboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboxInclude<ExtArgs> | null
    /**
     * The data needed to update a Inbox.
     */
    data: XOR<InboxUpdateInput, InboxUncheckedUpdateInput>
    /**
     * Choose, which Inbox to update.
     */
    where: InboxWhereUniqueInput
  }

  /**
   * Inbox updateMany
   */
  export type InboxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inboxes.
     */
    data: XOR<InboxUpdateManyMutationInput, InboxUncheckedUpdateManyInput>
    /**
     * Filter which Inboxes to update
     */
    where?: InboxWhereInput
    /**
     * Limit how many Inboxes to update.
     */
    limit?: number
  }

  /**
   * Inbox updateManyAndReturn
   */
  export type InboxUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inbox
     */
    select?: InboxSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inbox
     */
    omit?: InboxOmit<ExtArgs> | null
    /**
     * The data used to update Inboxes.
     */
    data: XOR<InboxUpdateManyMutationInput, InboxUncheckedUpdateManyInput>
    /**
     * Filter which Inboxes to update
     */
    where?: InboxWhereInput
    /**
     * Limit how many Inboxes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboxIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inbox upsert
   */
  export type InboxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inbox
     */
    select?: InboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inbox
     */
    omit?: InboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboxInclude<ExtArgs> | null
    /**
     * The filter to search for the Inbox to update in case it exists.
     */
    where: InboxWhereUniqueInput
    /**
     * In case the Inbox found by the `where` argument doesn't exist, create a new Inbox with this data.
     */
    create: XOR<InboxCreateInput, InboxUncheckedCreateInput>
    /**
     * In case the Inbox was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InboxUpdateInput, InboxUncheckedUpdateInput>
  }

  /**
   * Inbox delete
   */
  export type InboxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inbox
     */
    select?: InboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inbox
     */
    omit?: InboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboxInclude<ExtArgs> | null
    /**
     * Filter which Inbox to delete.
     */
    where: InboxWhereUniqueInput
  }

  /**
   * Inbox deleteMany
   */
  export type InboxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inboxes to delete
     */
    where?: InboxWhereInput
    /**
     * Limit how many Inboxes to delete.
     */
    limit?: number
  }

  /**
   * Inbox without action
   */
  export type InboxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inbox
     */
    select?: InboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inbox
     */
    omit?: InboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboxInclude<ExtArgs> | null
  }


  /**
   * Model Shop
   */

  export type AggregateShop = {
    _count: ShopCountAggregateOutputType | null
    _avg: ShopAvgAggregateOutputType | null
    _sum: ShopSumAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  export type ShopAvgAggregateOutputType = {
    id: number | null
    sellerId: number | null
    buyerId: number | null
  }

  export type ShopSumAggregateOutputType = {
    id: number | null
    sellerId: number | null
    buyerId: number | null
  }

  export type ShopMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    productType: $Enums.ProductType | null
    createdAt: Date | null
    updatedAt: Date | null
    category: $Enums.Category | null
    sellerId: number | null
    buyerId: number | null
    deleted: boolean | null
  }

  export type ShopMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    productType: $Enums.ProductType | null
    createdAt: Date | null
    updatedAt: Date | null
    category: $Enums.Category | null
    sellerId: number | null
    buyerId: number | null
    deleted: boolean | null
  }

  export type ShopCountAggregateOutputType = {
    id: number
    name: number
    description: number
    productType: number
    createdAt: number
    updatedAt: number
    category: number
    sellerId: number
    buyerId: number
    deleted: number
    _all: number
  }


  export type ShopAvgAggregateInputType = {
    id?: true
    sellerId?: true
    buyerId?: true
  }

  export type ShopSumAggregateInputType = {
    id?: true
    sellerId?: true
    buyerId?: true
  }

  export type ShopMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    productType?: true
    createdAt?: true
    updatedAt?: true
    category?: true
    sellerId?: true
    buyerId?: true
    deleted?: true
  }

  export type ShopMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    productType?: true
    createdAt?: true
    updatedAt?: true
    category?: true
    sellerId?: true
    buyerId?: true
    deleted?: true
  }

  export type ShopCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    productType?: true
    createdAt?: true
    updatedAt?: true
    category?: true
    sellerId?: true
    buyerId?: true
    deleted?: true
    _all?: true
  }

  export type ShopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shop to aggregate.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shops
    **/
    _count?: true | ShopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopMaxAggregateInputType
  }

  export type GetShopAggregateType<T extends ShopAggregateArgs> = {
        [P in keyof T & keyof AggregateShop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShop[P]>
      : GetScalarType<T[P], AggregateShop[P]>
  }




  export type ShopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithAggregationInput | ShopOrderByWithAggregationInput[]
    by: ShopScalarFieldEnum[] | ShopScalarFieldEnum
    having?: ShopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopCountAggregateInputType | true
    _avg?: ShopAvgAggregateInputType
    _sum?: ShopSumAggregateInputType
    _min?: ShopMinAggregateInputType
    _max?: ShopMaxAggregateInputType
  }

  export type ShopGroupByOutputType = {
    id: number
    name: string
    description: string | null
    productType: $Enums.ProductType
    createdAt: Date
    updatedAt: Date
    category: $Enums.Category
    sellerId: number
    buyerId: number
    deleted: boolean | null
    _count: ShopCountAggregateOutputType | null
    _avg: ShopAvgAggregateOutputType | null
    _sum: ShopSumAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  type GetShopGroupByPayload<T extends ShopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopGroupByOutputType[P]>
            : GetScalarType<T[P], ShopGroupByOutputType[P]>
        }
      >
    >


  export type ShopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    productType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean
    sellerId?: boolean
    buyerId?: boolean
    deleted?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | Shop$ordersArgs<ExtArgs>
    options?: boolean | Shop$optionsArgs<ExtArgs>
    review?: boolean | Shop$reviewArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shop"]>

  export type ShopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    productType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean
    sellerId?: boolean
    buyerId?: boolean
    deleted?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shop"]>

  export type ShopSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    productType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean
    sellerId?: boolean
    buyerId?: boolean
    deleted?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shop"]>

  export type ShopSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    productType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean
    sellerId?: boolean
    buyerId?: boolean
    deleted?: boolean
  }

  export type ShopOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "productType" | "createdAt" | "updatedAt" | "category" | "sellerId" | "buyerId" | "deleted", ExtArgs["result"]["shop"]>
  export type ShopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | Shop$ordersArgs<ExtArgs>
    options?: boolean | Shop$optionsArgs<ExtArgs>
    review?: boolean | Shop$reviewArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ShopIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ShopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shop"
    objects: {
      seller: Prisma.$UserPayload<ExtArgs>
      buyer: Prisma.$UserPayload<ExtArgs>
      orders: Prisma.$OrderPayload<ExtArgs> | null
      options: Prisma.$OptionPayload<ExtArgs>[]
      review: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      productType: $Enums.ProductType
      createdAt: Date
      updatedAt: Date
      category: $Enums.Category
      sellerId: number
      buyerId: number
      deleted: boolean | null
    }, ExtArgs["result"]["shop"]>
    composites: {}
  }

  type ShopGetPayload<S extends boolean | null | undefined | ShopDefaultArgs> = $Result.GetResult<Prisma.$ShopPayload, S>

  type ShopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopCountAggregateInputType | true
    }

  export interface ShopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shop'], meta: { name: 'Shop' } }
    /**
     * Find zero or one Shop that matches the filter.
     * @param {ShopFindUniqueArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopFindUniqueArgs>(args: SelectSubset<T, ShopFindUniqueArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopFindUniqueOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopFindFirstArgs>(args?: SelectSubset<T, ShopFindFirstArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shops
     * const shops = await prisma.shop.findMany()
     * 
     * // Get first 10 Shops
     * const shops = await prisma.shop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopWithIdOnly = await prisma.shop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopFindManyArgs>(args?: SelectSubset<T, ShopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shop.
     * @param {ShopCreateArgs} args - Arguments to create a Shop.
     * @example
     * // Create one Shop
     * const Shop = await prisma.shop.create({
     *   data: {
     *     // ... data to create a Shop
     *   }
     * })
     * 
     */
    create<T extends ShopCreateArgs>(args: SelectSubset<T, ShopCreateArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shops.
     * @param {ShopCreateManyArgs} args - Arguments to create many Shops.
     * @example
     * // Create many Shops
     * const shop = await prisma.shop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopCreateManyArgs>(args?: SelectSubset<T, ShopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shops and returns the data saved in the database.
     * @param {ShopCreateManyAndReturnArgs} args - Arguments to create many Shops.
     * @example
     * // Create many Shops
     * const shop = await prisma.shop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shops and only return the `id`
     * const shopWithIdOnly = await prisma.shop.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShopCreateManyAndReturnArgs>(args?: SelectSubset<T, ShopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shop.
     * @param {ShopDeleteArgs} args - Arguments to delete one Shop.
     * @example
     * // Delete one Shop
     * const Shop = await prisma.shop.delete({
     *   where: {
     *     // ... filter to delete one Shop
     *   }
     * })
     * 
     */
    delete<T extends ShopDeleteArgs>(args: SelectSubset<T, ShopDeleteArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shop.
     * @param {ShopUpdateArgs} args - Arguments to update one Shop.
     * @example
     * // Update one Shop
     * const shop = await prisma.shop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopUpdateArgs>(args: SelectSubset<T, ShopUpdateArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shops.
     * @param {ShopDeleteManyArgs} args - Arguments to filter Shops to delete.
     * @example
     * // Delete a few Shops
     * const { count } = await prisma.shop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopDeleteManyArgs>(args?: SelectSubset<T, ShopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shops
     * const shop = await prisma.shop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopUpdateManyArgs>(args: SelectSubset<T, ShopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shops and returns the data updated in the database.
     * @param {ShopUpdateManyAndReturnArgs} args - Arguments to update many Shops.
     * @example
     * // Update many Shops
     * const shop = await prisma.shop.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shops and only return the `id`
     * const shopWithIdOnly = await prisma.shop.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShopUpdateManyAndReturnArgs>(args: SelectSubset<T, ShopUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shop.
     * @param {ShopUpsertArgs} args - Arguments to update or create a Shop.
     * @example
     * // Update or create a Shop
     * const shop = await prisma.shop.upsert({
     *   create: {
     *     // ... data to create a Shop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shop we want to update
     *   }
     * })
     */
    upsert<T extends ShopUpsertArgs>(args: SelectSubset<T, ShopUpsertArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCountArgs} args - Arguments to filter Shops to count.
     * @example
     * // Count the number of Shops
     * const count = await prisma.shop.count({
     *   where: {
     *     // ... the filter for the Shops we want to count
     *   }
     * })
    **/
    count<T extends ShopCountArgs>(
      args?: Subset<T, ShopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopAggregateArgs>(args: Subset<T, ShopAggregateArgs>): Prisma.PrismaPromise<GetShopAggregateType<T>>

    /**
     * Group by Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopGroupByArgs['orderBy'] }
        : { orderBy?: ShopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shop model
   */
  readonly fields: ShopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    buyer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends Shop$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Shop$ordersArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    options<T extends Shop$optionsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    review<T extends Shop$reviewArgs<ExtArgs> = {}>(args?: Subset<T, Shop$reviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shop model
   */
  interface ShopFieldRefs {
    readonly id: FieldRef<"Shop", 'Int'>
    readonly name: FieldRef<"Shop", 'String'>
    readonly description: FieldRef<"Shop", 'String'>
    readonly productType: FieldRef<"Shop", 'ProductType'>
    readonly createdAt: FieldRef<"Shop", 'DateTime'>
    readonly updatedAt: FieldRef<"Shop", 'DateTime'>
    readonly category: FieldRef<"Shop", 'Category'>
    readonly sellerId: FieldRef<"Shop", 'Int'>
    readonly buyerId: FieldRef<"Shop", 'Int'>
    readonly deleted: FieldRef<"Shop", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Shop findUnique
   */
  export type ShopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop findUniqueOrThrow
   */
  export type ShopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop findFirst
   */
  export type ShopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop findFirstOrThrow
   */
  export type ShopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop findMany
   */
  export type ShopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shops to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop create
   */
  export type ShopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to create a Shop.
     */
    data: XOR<ShopCreateInput, ShopUncheckedCreateInput>
  }

  /**
   * Shop createMany
   */
  export type ShopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shops.
     */
    data: ShopCreateManyInput | ShopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shop createManyAndReturn
   */
  export type ShopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * The data used to create many Shops.
     */
    data: ShopCreateManyInput | ShopCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shop update
   */
  export type ShopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to update a Shop.
     */
    data: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
    /**
     * Choose, which Shop to update.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop updateMany
   */
  export type ShopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shops.
     */
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyInput>
    /**
     * Filter which Shops to update
     */
    where?: ShopWhereInput
    /**
     * Limit how many Shops to update.
     */
    limit?: number
  }

  /**
   * Shop updateManyAndReturn
   */
  export type ShopUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * The data used to update Shops.
     */
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyInput>
    /**
     * Filter which Shops to update
     */
    where?: ShopWhereInput
    /**
     * Limit how many Shops to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shop upsert
   */
  export type ShopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The filter to search for the Shop to update in case it exists.
     */
    where: ShopWhereUniqueInput
    /**
     * In case the Shop found by the `where` argument doesn't exist, create a new Shop with this data.
     */
    create: XOR<ShopCreateInput, ShopUncheckedCreateInput>
    /**
     * In case the Shop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
  }

  /**
   * Shop delete
   */
  export type ShopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter which Shop to delete.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop deleteMany
   */
  export type ShopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shops to delete
     */
    where?: ShopWhereInput
    /**
     * Limit how many Shops to delete.
     */
    limit?: number
  }

  /**
   * Shop.orders
   */
  export type Shop$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Shop.options
   */
  export type Shop$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    where?: OptionWhereInput
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    cursor?: OptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * Shop.review
   */
  export type Shop$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Shop without action
   */
  export type ShopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    shopId: number | null
    buyerId: number | null
    sellerId: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    shopId: number | null
    buyerId: number | null
    sellerId: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    quantity: number | null
    shopId: number | null
    buyerId: number | null
    sellerId: number | null
    deleted: boolean | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    quantity: number | null
    shopId: number | null
    buyerId: number | null
    sellerId: number | null
    deleted: boolean | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    quantity: number
    shopId: number
    buyerId: number
    sellerId: number
    deleted: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    quantity?: true
    shopId?: true
    buyerId?: true
    sellerId?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    quantity?: true
    shopId?: true
    buyerId?: true
    sellerId?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    quantity?: true
    shopId?: true
    buyerId?: true
    sellerId?: true
    deleted?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    quantity?: true
    shopId?: true
    buyerId?: true
    sellerId?: true
    deleted?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    quantity?: true
    shopId?: true
    buyerId?: true
    sellerId?: true
    deleted?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    quantity: number
    shopId: number
    buyerId: number
    sellerId: number
    deleted: boolean | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quantity?: boolean
    shopId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    deleted?: boolean
    seller?: boolean | ShopDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    review?: boolean | Order$reviewArgs<ExtArgs>
    cart?: boolean | CartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quantity?: boolean
    shopId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    deleted?: boolean
    seller?: boolean | ShopDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    cart?: boolean | CartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quantity?: boolean
    shopId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    deleted?: boolean
    seller?: boolean | ShopDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    cart?: boolean | CartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quantity?: boolean
    shopId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    deleted?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "quantity" | "shopId" | "buyerId" | "sellerId" | "deleted", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | ShopDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    review?: boolean | Order$reviewArgs<ExtArgs>
    cart?: boolean | CartDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | ShopDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    cart?: boolean | CartDefaultArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | ShopDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    cart?: boolean | CartDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      seller: Prisma.$ShopPayload<ExtArgs>
      buyer: Prisma.$UserPayload<ExtArgs>
      review: Prisma.$ReviewPayload<ExtArgs> | null
      cart: Prisma.$CartPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      quantity: number
      shopId: number
      buyerId: number
      sellerId: number
      deleted: boolean | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seller<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    buyer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    review<T extends Order$reviewArgs<ExtArgs> = {}>(args?: Subset<T, Order$reviewArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cart<T extends CartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartDefaultArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly quantity: FieldRef<"Order", 'Int'>
    readonly shopId: FieldRef<"Order", 'Int'>
    readonly buyerId: FieldRef<"Order", 'Int'>
    readonly sellerId: FieldRef<"Order", 'Int'>
    readonly deleted: FieldRef<"Order", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.review
   */
  export type Order$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Option
   */

  export type AggregateOption = {
    _count: OptionCountAggregateOutputType | null
    _avg: OptionAvgAggregateOutputType | null
    _sum: OptionSumAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  export type OptionAvgAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type OptionSumAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type OptionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: $Enums.OptionName | null
    shopId: number | null
  }

  export type OptionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: $Enums.OptionName | null
    shopId: number | null
  }

  export type OptionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    shopId: number
    _all: number
  }


  export type OptionAvgAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type OptionSumAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type OptionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    shopId?: true
  }

  export type OptionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    shopId?: true
  }

  export type OptionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    shopId?: true
    _all?: true
  }

  export type OptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Option to aggregate.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Options
    **/
    _count?: true | OptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptionMaxAggregateInputType
  }

  export type GetOptionAggregateType<T extends OptionAggregateArgs> = {
        [P in keyof T & keyof AggregateOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOption[P]>
      : GetScalarType<T[P], AggregateOption[P]>
  }




  export type OptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptionWhereInput
    orderBy?: OptionOrderByWithAggregationInput | OptionOrderByWithAggregationInput[]
    by: OptionScalarFieldEnum[] | OptionScalarFieldEnum
    having?: OptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptionCountAggregateInputType | true
    _avg?: OptionAvgAggregateInputType
    _sum?: OptionSumAggregateInputType
    _min?: OptionMinAggregateInputType
    _max?: OptionMaxAggregateInputType
  }

  export type OptionGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    name: $Enums.OptionName
    shopId: number
    _count: OptionCountAggregateOutputType | null
    _avg: OptionAvgAggregateOutputType | null
    _sum: OptionSumAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  type GetOptionGroupByPayload<T extends OptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptionGroupByOutputType[P]>
            : GetScalarType<T[P], OptionGroupByOutputType[P]>
        }
      >
    >


  export type OptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    shopId?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    values?: boolean | Option$valuesArgs<ExtArgs>
    _count?: boolean | OptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option"]>

  export type OptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    shopId?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option"]>

  export type OptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    shopId?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option"]>

  export type OptionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    shopId?: boolean
  }

  export type OptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "shopId", ExtArgs["result"]["option"]>
  export type OptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    values?: boolean | Option$valuesArgs<ExtArgs>
    _count?: boolean | OptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type OptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $OptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Option"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
      values: Prisma.$OptionValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      name: $Enums.OptionName
      shopId: number
    }, ExtArgs["result"]["option"]>
    composites: {}
  }

  type OptionGetPayload<S extends boolean | null | undefined | OptionDefaultArgs> = $Result.GetResult<Prisma.$OptionPayload, S>

  type OptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OptionCountAggregateInputType | true
    }

  export interface OptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Option'], meta: { name: 'Option' } }
    /**
     * Find zero or one Option that matches the filter.
     * @param {OptionFindUniqueArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OptionFindUniqueArgs>(args: SelectSubset<T, OptionFindUniqueArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Option that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OptionFindUniqueOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OptionFindUniqueOrThrowArgs>(args: SelectSubset<T, OptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Option that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindFirstArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OptionFindFirstArgs>(args?: SelectSubset<T, OptionFindFirstArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Option that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindFirstOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OptionFindFirstOrThrowArgs>(args?: SelectSubset<T, OptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Options
     * const options = await prisma.option.findMany()
     * 
     * // Get first 10 Options
     * const options = await prisma.option.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optionWithIdOnly = await prisma.option.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OptionFindManyArgs>(args?: SelectSubset<T, OptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Option.
     * @param {OptionCreateArgs} args - Arguments to create a Option.
     * @example
     * // Create one Option
     * const Option = await prisma.option.create({
     *   data: {
     *     // ... data to create a Option
     *   }
     * })
     * 
     */
    create<T extends OptionCreateArgs>(args: SelectSubset<T, OptionCreateArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Options.
     * @param {OptionCreateManyArgs} args - Arguments to create many Options.
     * @example
     * // Create many Options
     * const option = await prisma.option.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OptionCreateManyArgs>(args?: SelectSubset<T, OptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Options and returns the data saved in the database.
     * @param {OptionCreateManyAndReturnArgs} args - Arguments to create many Options.
     * @example
     * // Create many Options
     * const option = await prisma.option.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Options and only return the `id`
     * const optionWithIdOnly = await prisma.option.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OptionCreateManyAndReturnArgs>(args?: SelectSubset<T, OptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Option.
     * @param {OptionDeleteArgs} args - Arguments to delete one Option.
     * @example
     * // Delete one Option
     * const Option = await prisma.option.delete({
     *   where: {
     *     // ... filter to delete one Option
     *   }
     * })
     * 
     */
    delete<T extends OptionDeleteArgs>(args: SelectSubset<T, OptionDeleteArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Option.
     * @param {OptionUpdateArgs} args - Arguments to update one Option.
     * @example
     * // Update one Option
     * const option = await prisma.option.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OptionUpdateArgs>(args: SelectSubset<T, OptionUpdateArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Options.
     * @param {OptionDeleteManyArgs} args - Arguments to filter Options to delete.
     * @example
     * // Delete a few Options
     * const { count } = await prisma.option.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OptionDeleteManyArgs>(args?: SelectSubset<T, OptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Options
     * const option = await prisma.option.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OptionUpdateManyArgs>(args: SelectSubset<T, OptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Options and returns the data updated in the database.
     * @param {OptionUpdateManyAndReturnArgs} args - Arguments to update many Options.
     * @example
     * // Update many Options
     * const option = await prisma.option.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Options and only return the `id`
     * const optionWithIdOnly = await prisma.option.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OptionUpdateManyAndReturnArgs>(args: SelectSubset<T, OptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Option.
     * @param {OptionUpsertArgs} args - Arguments to update or create a Option.
     * @example
     * // Update or create a Option
     * const option = await prisma.option.upsert({
     *   create: {
     *     // ... data to create a Option
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Option we want to update
     *   }
     * })
     */
    upsert<T extends OptionUpsertArgs>(args: SelectSubset<T, OptionUpsertArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionCountArgs} args - Arguments to filter Options to count.
     * @example
     * // Count the number of Options
     * const count = await prisma.option.count({
     *   where: {
     *     // ... the filter for the Options we want to count
     *   }
     * })
    **/
    count<T extends OptionCountArgs>(
      args?: Subset<T, OptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptionAggregateArgs>(args: Subset<T, OptionAggregateArgs>): Prisma.PrismaPromise<GetOptionAggregateType<T>>

    /**
     * Group by Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptionGroupByArgs['orderBy'] }
        : { orderBy?: OptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Option model
   */
  readonly fields: OptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Option.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    values<T extends Option$valuesArgs<ExtArgs> = {}>(args?: Subset<T, Option$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Option model
   */
  interface OptionFieldRefs {
    readonly id: FieldRef<"Option", 'Int'>
    readonly createdAt: FieldRef<"Option", 'DateTime'>
    readonly updatedAt: FieldRef<"Option", 'DateTime'>
    readonly name: FieldRef<"Option", 'OptionName'>
    readonly shopId: FieldRef<"Option", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Option findUnique
   */
  export type OptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option findUniqueOrThrow
   */
  export type OptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option findFirst
   */
  export type OptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Options.
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Options.
     */
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * Option findFirstOrThrow
   */
  export type OptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Options.
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Options.
     */
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * Option findMany
   */
  export type OptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Options to fetch.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Options.
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * Option create
   */
  export type OptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Option.
     */
    data: XOR<OptionCreateInput, OptionUncheckedCreateInput>
  }

  /**
   * Option createMany
   */
  export type OptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Options.
     */
    data: OptionCreateManyInput | OptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Option createManyAndReturn
   */
  export type OptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * The data used to create many Options.
     */
    data: OptionCreateManyInput | OptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Option update
   */
  export type OptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Option.
     */
    data: XOR<OptionUpdateInput, OptionUncheckedUpdateInput>
    /**
     * Choose, which Option to update.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option updateMany
   */
  export type OptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Options.
     */
    data: XOR<OptionUpdateManyMutationInput, OptionUncheckedUpdateManyInput>
    /**
     * Filter which Options to update
     */
    where?: OptionWhereInput
    /**
     * Limit how many Options to update.
     */
    limit?: number
  }

  /**
   * Option updateManyAndReturn
   */
  export type OptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * The data used to update Options.
     */
    data: XOR<OptionUpdateManyMutationInput, OptionUncheckedUpdateManyInput>
    /**
     * Filter which Options to update
     */
    where?: OptionWhereInput
    /**
     * Limit how many Options to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Option upsert
   */
  export type OptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Option to update in case it exists.
     */
    where: OptionWhereUniqueInput
    /**
     * In case the Option found by the `where` argument doesn't exist, create a new Option with this data.
     */
    create: XOR<OptionCreateInput, OptionUncheckedCreateInput>
    /**
     * In case the Option was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OptionUpdateInput, OptionUncheckedUpdateInput>
  }

  /**
   * Option delete
   */
  export type OptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter which Option to delete.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option deleteMany
   */
  export type OptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Options to delete
     */
    where?: OptionWhereInput
    /**
     * Limit how many Options to delete.
     */
    limit?: number
  }

  /**
   * Option.values
   */
  export type Option$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionValue
     */
    select?: OptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionValue
     */
    omit?: OptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionValueInclude<ExtArgs> | null
    where?: OptionValueWhereInput
    orderBy?: OptionValueOrderByWithRelationInput | OptionValueOrderByWithRelationInput[]
    cursor?: OptionValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OptionValueScalarFieldEnum | OptionValueScalarFieldEnum[]
  }

  /**
   * Option without action
   */
  export type OptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
  }


  /**
   * Model OptionValue
   */

  export type AggregateOptionValue = {
    _count: OptionValueCountAggregateOutputType | null
    _avg: OptionValueAvgAggregateOutputType | null
    _sum: OptionValueSumAggregateOutputType | null
    _min: OptionValueMinAggregateOutputType | null
    _max: OptionValueMaxAggregateOutputType | null
  }

  export type OptionValueAvgAggregateOutputType = {
    id: number | null
    price: number | null
    interest: number | null
    duration: number | null
    optionId: number | null
  }

  export type OptionValueSumAggregateOutputType = {
    id: number | null
    price: number | null
    interest: number | null
    duration: number | null
    optionId: number | null
  }

  export type OptionValueMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    value: string | null
    price: number | null
    interest: number | null
    duration: number | null
    optionId: number | null
  }

  export type OptionValueMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    value: string | null
    price: number | null
    interest: number | null
    duration: number | null
    optionId: number | null
  }

  export type OptionValueCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    value: number
    price: number
    interest: number
    duration: number
    optionId: number
    _all: number
  }


  export type OptionValueAvgAggregateInputType = {
    id?: true
    price?: true
    interest?: true
    duration?: true
    optionId?: true
  }

  export type OptionValueSumAggregateInputType = {
    id?: true
    price?: true
    interest?: true
    duration?: true
    optionId?: true
  }

  export type OptionValueMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    value?: true
    price?: true
    interest?: true
    duration?: true
    optionId?: true
  }

  export type OptionValueMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    value?: true
    price?: true
    interest?: true
    duration?: true
    optionId?: true
  }

  export type OptionValueCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    value?: true
    price?: true
    interest?: true
    duration?: true
    optionId?: true
    _all?: true
  }

  export type OptionValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptionValue to aggregate.
     */
    where?: OptionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionValues to fetch.
     */
    orderBy?: OptionValueOrderByWithRelationInput | OptionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OptionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OptionValues
    **/
    _count?: true | OptionValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OptionValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OptionValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptionValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptionValueMaxAggregateInputType
  }

  export type GetOptionValueAggregateType<T extends OptionValueAggregateArgs> = {
        [P in keyof T & keyof AggregateOptionValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOptionValue[P]>
      : GetScalarType<T[P], AggregateOptionValue[P]>
  }




  export type OptionValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptionValueWhereInput
    orderBy?: OptionValueOrderByWithAggregationInput | OptionValueOrderByWithAggregationInput[]
    by: OptionValueScalarFieldEnum[] | OptionValueScalarFieldEnum
    having?: OptionValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptionValueCountAggregateInputType | true
    _avg?: OptionValueAvgAggregateInputType
    _sum?: OptionValueSumAggregateInputType
    _min?: OptionValueMinAggregateInputType
    _max?: OptionValueMaxAggregateInputType
  }

  export type OptionValueGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    value: string
    price: number | null
    interest: number | null
    duration: number | null
    optionId: number
    _count: OptionValueCountAggregateOutputType | null
    _avg: OptionValueAvgAggregateOutputType | null
    _sum: OptionValueSumAggregateOutputType | null
    _min: OptionValueMinAggregateOutputType | null
    _max: OptionValueMaxAggregateOutputType | null
  }

  type GetOptionValueGroupByPayload<T extends OptionValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptionValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptionValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptionValueGroupByOutputType[P]>
            : GetScalarType<T[P], OptionValueGroupByOutputType[P]>
        }
      >
    >


  export type OptionValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    value?: boolean
    price?: boolean
    interest?: boolean
    duration?: boolean
    optionId?: boolean
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optionValue"]>

  export type OptionValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    value?: boolean
    price?: boolean
    interest?: boolean
    duration?: boolean
    optionId?: boolean
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optionValue"]>

  export type OptionValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    value?: boolean
    price?: boolean
    interest?: boolean
    duration?: boolean
    optionId?: boolean
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optionValue"]>

  export type OptionValueSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    value?: boolean
    price?: boolean
    interest?: boolean
    duration?: boolean
    optionId?: boolean
  }

  export type OptionValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "value" | "price" | "interest" | "duration" | "optionId", ExtArgs["result"]["optionValue"]>
  export type OptionValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }
  export type OptionValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }
  export type OptionValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option?: boolean | OptionDefaultArgs<ExtArgs>
  }

  export type $OptionValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OptionValue"
    objects: {
      option: Prisma.$OptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      value: string
      price: number | null
      interest: number | null
      duration: number | null
      optionId: number
    }, ExtArgs["result"]["optionValue"]>
    composites: {}
  }

  type OptionValueGetPayload<S extends boolean | null | undefined | OptionValueDefaultArgs> = $Result.GetResult<Prisma.$OptionValuePayload, S>

  type OptionValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OptionValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OptionValueCountAggregateInputType | true
    }

  export interface OptionValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OptionValue'], meta: { name: 'OptionValue' } }
    /**
     * Find zero or one OptionValue that matches the filter.
     * @param {OptionValueFindUniqueArgs} args - Arguments to find a OptionValue
     * @example
     * // Get one OptionValue
     * const optionValue = await prisma.optionValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OptionValueFindUniqueArgs>(args: SelectSubset<T, OptionValueFindUniqueArgs<ExtArgs>>): Prisma__OptionValueClient<$Result.GetResult<Prisma.$OptionValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OptionValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OptionValueFindUniqueOrThrowArgs} args - Arguments to find a OptionValue
     * @example
     * // Get one OptionValue
     * const optionValue = await prisma.optionValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OptionValueFindUniqueOrThrowArgs>(args: SelectSubset<T, OptionValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OptionValueClient<$Result.GetResult<Prisma.$OptionValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OptionValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionValueFindFirstArgs} args - Arguments to find a OptionValue
     * @example
     * // Get one OptionValue
     * const optionValue = await prisma.optionValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OptionValueFindFirstArgs>(args?: SelectSubset<T, OptionValueFindFirstArgs<ExtArgs>>): Prisma__OptionValueClient<$Result.GetResult<Prisma.$OptionValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OptionValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionValueFindFirstOrThrowArgs} args - Arguments to find a OptionValue
     * @example
     * // Get one OptionValue
     * const optionValue = await prisma.optionValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OptionValueFindFirstOrThrowArgs>(args?: SelectSubset<T, OptionValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__OptionValueClient<$Result.GetResult<Prisma.$OptionValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OptionValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OptionValues
     * const optionValues = await prisma.optionValue.findMany()
     * 
     * // Get first 10 OptionValues
     * const optionValues = await prisma.optionValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optionValueWithIdOnly = await prisma.optionValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OptionValueFindManyArgs>(args?: SelectSubset<T, OptionValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OptionValue.
     * @param {OptionValueCreateArgs} args - Arguments to create a OptionValue.
     * @example
     * // Create one OptionValue
     * const OptionValue = await prisma.optionValue.create({
     *   data: {
     *     // ... data to create a OptionValue
     *   }
     * })
     * 
     */
    create<T extends OptionValueCreateArgs>(args: SelectSubset<T, OptionValueCreateArgs<ExtArgs>>): Prisma__OptionValueClient<$Result.GetResult<Prisma.$OptionValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OptionValues.
     * @param {OptionValueCreateManyArgs} args - Arguments to create many OptionValues.
     * @example
     * // Create many OptionValues
     * const optionValue = await prisma.optionValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OptionValueCreateManyArgs>(args?: SelectSubset<T, OptionValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OptionValues and returns the data saved in the database.
     * @param {OptionValueCreateManyAndReturnArgs} args - Arguments to create many OptionValues.
     * @example
     * // Create many OptionValues
     * const optionValue = await prisma.optionValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OptionValues and only return the `id`
     * const optionValueWithIdOnly = await prisma.optionValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OptionValueCreateManyAndReturnArgs>(args?: SelectSubset<T, OptionValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OptionValue.
     * @param {OptionValueDeleteArgs} args - Arguments to delete one OptionValue.
     * @example
     * // Delete one OptionValue
     * const OptionValue = await prisma.optionValue.delete({
     *   where: {
     *     // ... filter to delete one OptionValue
     *   }
     * })
     * 
     */
    delete<T extends OptionValueDeleteArgs>(args: SelectSubset<T, OptionValueDeleteArgs<ExtArgs>>): Prisma__OptionValueClient<$Result.GetResult<Prisma.$OptionValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OptionValue.
     * @param {OptionValueUpdateArgs} args - Arguments to update one OptionValue.
     * @example
     * // Update one OptionValue
     * const optionValue = await prisma.optionValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OptionValueUpdateArgs>(args: SelectSubset<T, OptionValueUpdateArgs<ExtArgs>>): Prisma__OptionValueClient<$Result.GetResult<Prisma.$OptionValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OptionValues.
     * @param {OptionValueDeleteManyArgs} args - Arguments to filter OptionValues to delete.
     * @example
     * // Delete a few OptionValues
     * const { count } = await prisma.optionValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OptionValueDeleteManyArgs>(args?: SelectSubset<T, OptionValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OptionValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OptionValues
     * const optionValue = await prisma.optionValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OptionValueUpdateManyArgs>(args: SelectSubset<T, OptionValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OptionValues and returns the data updated in the database.
     * @param {OptionValueUpdateManyAndReturnArgs} args - Arguments to update many OptionValues.
     * @example
     * // Update many OptionValues
     * const optionValue = await prisma.optionValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OptionValues and only return the `id`
     * const optionValueWithIdOnly = await prisma.optionValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OptionValueUpdateManyAndReturnArgs>(args: SelectSubset<T, OptionValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OptionValue.
     * @param {OptionValueUpsertArgs} args - Arguments to update or create a OptionValue.
     * @example
     * // Update or create a OptionValue
     * const optionValue = await prisma.optionValue.upsert({
     *   create: {
     *     // ... data to create a OptionValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OptionValue we want to update
     *   }
     * })
     */
    upsert<T extends OptionValueUpsertArgs>(args: SelectSubset<T, OptionValueUpsertArgs<ExtArgs>>): Prisma__OptionValueClient<$Result.GetResult<Prisma.$OptionValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OptionValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionValueCountArgs} args - Arguments to filter OptionValues to count.
     * @example
     * // Count the number of OptionValues
     * const count = await prisma.optionValue.count({
     *   where: {
     *     // ... the filter for the OptionValues we want to count
     *   }
     * })
    **/
    count<T extends OptionValueCountArgs>(
      args?: Subset<T, OptionValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptionValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OptionValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptionValueAggregateArgs>(args: Subset<T, OptionValueAggregateArgs>): Prisma.PrismaPromise<GetOptionValueAggregateType<T>>

    /**
     * Group by OptionValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptionValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptionValueGroupByArgs['orderBy'] }
        : { orderBy?: OptionValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptionValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptionValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OptionValue model
   */
  readonly fields: OptionValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OptionValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OptionValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    option<T extends OptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OptionDefaultArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OptionValue model
   */
  interface OptionValueFieldRefs {
    readonly id: FieldRef<"OptionValue", 'Int'>
    readonly createdAt: FieldRef<"OptionValue", 'DateTime'>
    readonly updatedAt: FieldRef<"OptionValue", 'DateTime'>
    readonly value: FieldRef<"OptionValue", 'String'>
    readonly price: FieldRef<"OptionValue", 'Float'>
    readonly interest: FieldRef<"OptionValue", 'Float'>
    readonly duration: FieldRef<"OptionValue", 'Int'>
    readonly optionId: FieldRef<"OptionValue", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OptionValue findUnique
   */
  export type OptionValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionValue
     */
    select?: OptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionValue
     */
    omit?: OptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionValueInclude<ExtArgs> | null
    /**
     * Filter, which OptionValue to fetch.
     */
    where: OptionValueWhereUniqueInput
  }

  /**
   * OptionValue findUniqueOrThrow
   */
  export type OptionValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionValue
     */
    select?: OptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionValue
     */
    omit?: OptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionValueInclude<ExtArgs> | null
    /**
     * Filter, which OptionValue to fetch.
     */
    where: OptionValueWhereUniqueInput
  }

  /**
   * OptionValue findFirst
   */
  export type OptionValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionValue
     */
    select?: OptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionValue
     */
    omit?: OptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionValueInclude<ExtArgs> | null
    /**
     * Filter, which OptionValue to fetch.
     */
    where?: OptionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionValues to fetch.
     */
    orderBy?: OptionValueOrderByWithRelationInput | OptionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptionValues.
     */
    cursor?: OptionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptionValues.
     */
    distinct?: OptionValueScalarFieldEnum | OptionValueScalarFieldEnum[]
  }

  /**
   * OptionValue findFirstOrThrow
   */
  export type OptionValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionValue
     */
    select?: OptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionValue
     */
    omit?: OptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionValueInclude<ExtArgs> | null
    /**
     * Filter, which OptionValue to fetch.
     */
    where?: OptionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionValues to fetch.
     */
    orderBy?: OptionValueOrderByWithRelationInput | OptionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptionValues.
     */
    cursor?: OptionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptionValues.
     */
    distinct?: OptionValueScalarFieldEnum | OptionValueScalarFieldEnum[]
  }

  /**
   * OptionValue findMany
   */
  export type OptionValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionValue
     */
    select?: OptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionValue
     */
    omit?: OptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionValueInclude<ExtArgs> | null
    /**
     * Filter, which OptionValues to fetch.
     */
    where?: OptionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionValues to fetch.
     */
    orderBy?: OptionValueOrderByWithRelationInput | OptionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OptionValues.
     */
    cursor?: OptionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionValues.
     */
    skip?: number
    distinct?: OptionValueScalarFieldEnum | OptionValueScalarFieldEnum[]
  }

  /**
   * OptionValue create
   */
  export type OptionValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionValue
     */
    select?: OptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionValue
     */
    omit?: OptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionValueInclude<ExtArgs> | null
    /**
     * The data needed to create a OptionValue.
     */
    data: XOR<OptionValueCreateInput, OptionValueUncheckedCreateInput>
  }

  /**
   * OptionValue createMany
   */
  export type OptionValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OptionValues.
     */
    data: OptionValueCreateManyInput | OptionValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OptionValue createManyAndReturn
   */
  export type OptionValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionValue
     */
    select?: OptionValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OptionValue
     */
    omit?: OptionValueOmit<ExtArgs> | null
    /**
     * The data used to create many OptionValues.
     */
    data: OptionValueCreateManyInput | OptionValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OptionValue update
   */
  export type OptionValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionValue
     */
    select?: OptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionValue
     */
    omit?: OptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionValueInclude<ExtArgs> | null
    /**
     * The data needed to update a OptionValue.
     */
    data: XOR<OptionValueUpdateInput, OptionValueUncheckedUpdateInput>
    /**
     * Choose, which OptionValue to update.
     */
    where: OptionValueWhereUniqueInput
  }

  /**
   * OptionValue updateMany
   */
  export type OptionValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OptionValues.
     */
    data: XOR<OptionValueUpdateManyMutationInput, OptionValueUncheckedUpdateManyInput>
    /**
     * Filter which OptionValues to update
     */
    where?: OptionValueWhereInput
    /**
     * Limit how many OptionValues to update.
     */
    limit?: number
  }

  /**
   * OptionValue updateManyAndReturn
   */
  export type OptionValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionValue
     */
    select?: OptionValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OptionValue
     */
    omit?: OptionValueOmit<ExtArgs> | null
    /**
     * The data used to update OptionValues.
     */
    data: XOR<OptionValueUpdateManyMutationInput, OptionValueUncheckedUpdateManyInput>
    /**
     * Filter which OptionValues to update
     */
    where?: OptionValueWhereInput
    /**
     * Limit how many OptionValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OptionValue upsert
   */
  export type OptionValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionValue
     */
    select?: OptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionValue
     */
    omit?: OptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionValueInclude<ExtArgs> | null
    /**
     * The filter to search for the OptionValue to update in case it exists.
     */
    where: OptionValueWhereUniqueInput
    /**
     * In case the OptionValue found by the `where` argument doesn't exist, create a new OptionValue with this data.
     */
    create: XOR<OptionValueCreateInput, OptionValueUncheckedCreateInput>
    /**
     * In case the OptionValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OptionValueUpdateInput, OptionValueUncheckedUpdateInput>
  }

  /**
   * OptionValue delete
   */
  export type OptionValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionValue
     */
    select?: OptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionValue
     */
    omit?: OptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionValueInclude<ExtArgs> | null
    /**
     * Filter which OptionValue to delete.
     */
    where: OptionValueWhereUniqueInput
  }

  /**
   * OptionValue deleteMany
   */
  export type OptionValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptionValues to delete
     */
    where?: OptionValueWhereInput
    /**
     * Limit how many OptionValues to delete.
     */
    limit?: number
  }

  /**
   * OptionValue without action
   */
  export type OptionValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionValue
     */
    select?: OptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptionValue
     */
    omit?: OptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionValueInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    id: number | null
    rating: number | null
    shopId: number | null
    userId: number | null
    orderId: number | null
  }

  export type ReviewSumAggregateOutputType = {
    id: number | null
    rating: number | null
    shopId: number | null
    userId: number | null
    orderId: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    rating: number | null
    shopId: number | null
    userId: number | null
    orderId: number | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    rating: number | null
    shopId: number | null
    userId: number | null
    orderId: number | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    content: number
    rating: number
    shopId: number
    userId: number
    orderId: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    id?: true
    rating?: true
    shopId?: true
    userId?: true
    orderId?: true
  }

  export type ReviewSumAggregateInputType = {
    id?: true
    rating?: true
    shopId?: true
    userId?: true
    orderId?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    rating?: true
    shopId?: true
    userId?: true
    orderId?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    rating?: true
    shopId?: true
    userId?: true
    orderId?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    rating?: true
    shopId?: true
    userId?: true
    orderId?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    content: string
    rating: number
    shopId: number
    userId: number
    orderId: number
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    rating?: boolean
    shopId?: boolean
    userId?: boolean
    orderId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    rating?: boolean
    shopId?: boolean
    userId?: boolean
    orderId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    rating?: boolean
    shopId?: boolean
    userId?: boolean
    orderId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    rating?: boolean
    shopId?: boolean
    userId?: boolean
    orderId?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "content" | "rating" | "shopId" | "userId" | "orderId", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      content: string
      rating: number
      shopId: number
      userId: number
      orderId: number
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'Int'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
    readonly content: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly shopId: FieldRef<"Review", 'Int'>
    readonly userId: FieldRef<"Review", 'Int'>
    readonly orderId: FieldRef<"Review", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    total: number | null
  }

  export type CartSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    total: number | null
  }

  export type CartMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    orderId: number | null
    payment: $Enums.Payment | null
    status: string | null
    total: number | null
  }

  export type CartMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    orderId: number | null
    payment: $Enums.Payment | null
    status: string | null
    total: number | null
  }

  export type CartCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    orderId: number
    payment: number
    status: number
    total: number
    _all: number
  }


  export type CartAvgAggregateInputType = {
    id?: true
    orderId?: true
    total?: true
  }

  export type CartSumAggregateInputType = {
    id?: true
    orderId?: true
    total?: true
  }

  export type CartMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orderId?: true
    payment?: true
    status?: true
    total?: true
  }

  export type CartMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orderId?: true
    payment?: true
    status?: true
    total?: true
  }

  export type CartCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orderId?: true
    payment?: true
    status?: true
    total?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type CartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
    orderBy?: CartOrderByWithAggregationInput | CartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: CartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _avg?: CartAvgAggregateInputType
    _sum?: CartSumAggregateInputType
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    orderId: number
    payment: $Enums.Payment
    status: string
    total: number
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type CartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderId?: boolean
    payment?: boolean
    status?: boolean
    total?: boolean
    order?: boolean | Cart$orderArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderId?: boolean
    payment?: boolean
    status?: boolean
    total?: boolean
  }, ExtArgs["result"]["cart"]>

  export type CartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderId?: boolean
    payment?: boolean
    status?: boolean
    total?: boolean
  }, ExtArgs["result"]["cart"]>

  export type CartSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderId?: boolean
    payment?: boolean
    status?: boolean
    total?: boolean
  }

  export type CartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "orderId" | "payment" | "status" | "total", ExtArgs["result"]["cart"]>
  export type CartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Cart$orderArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cart"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      orderId: number
      payment: $Enums.Payment
      status: string
      total: number
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }

  type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> = $Result.GetResult<Prisma.$CartPayload, S>

  type CartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface CartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart'], meta: { name: 'Cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartFindUniqueArgs>(args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartFindFirstArgs>(args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartFindManyArgs>(args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
     */
    create<T extends CartCreateArgs>(args: SelectSubset<T, CartCreateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carts.
     * @param {CartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartCreateManyArgs>(args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carts and returns the data saved in the database.
     * @param {CartCreateManyAndReturnArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartCreateManyAndReturnArgs>(args?: SelectSubset<T, CartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
     */
    delete<T extends CartDeleteArgs>(args: SelectSubset<T, CartDeleteArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartUpdateArgs>(args: SelectSubset<T, CartUpdateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartDeleteManyArgs>(args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartUpdateManyArgs>(args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts and returns the data updated in the database.
     * @param {CartUpdateManyAndReturnArgs} args - Arguments to update many Carts.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartUpdateManyAndReturnArgs>(args: SelectSubset<T, CartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends CartUpsertArgs>(args: SelectSubset<T, CartUpsertArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs['orderBy'] }
        : { orderBy?: CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cart model
   */
  readonly fields: CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends Cart$orderArgs<ExtArgs> = {}>(args?: Subset<T, Cart$orderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cart model
   */
  interface CartFieldRefs {
    readonly id: FieldRef<"Cart", 'Int'>
    readonly createdAt: FieldRef<"Cart", 'DateTime'>
    readonly updatedAt: FieldRef<"Cart", 'DateTime'>
    readonly orderId: FieldRef<"Cart", 'Int'>
    readonly payment: FieldRef<"Cart", 'Payment'>
    readonly status: FieldRef<"Cart", 'String'>
    readonly total: FieldRef<"Cart", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Cart findUnique
   */
  export type CartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findFirst
   */
  export type CartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findMany
   */
  export type CartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart create
   */
  export type CartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to create a Cart.
     */
    data: XOR<CartCreateInput, CartUncheckedCreateInput>
  }

  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cart createManyAndReturn
   */
  export type CartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cart update
   */
  export type CartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
  }

  /**
   * Cart updateManyAndReturn
   */
  export type CartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
  }

  /**
   * Cart upsert
   */
  export type CartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>
  }

  /**
   * Cart delete
   */
  export type CartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to delete.
     */
    limit?: number
  }

  /**
   * Cart.order
   */
  export type Cart$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Cart without action
   */
  export type CartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    avatar: 'avatar',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    phone: 'phone',
    username: 'username',
    bio: 'bio'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    uniqueId: 'uniqueId',
    role: 'role',
    permission: 'permission',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    businessId: 'businessId'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const BusinessAccScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    businessName: 'businessName',
    businessUserName: 'businessUserName',
    businessAvatar: 'businessAvatar',
    businessAddress: 'businessAddress',
    vatId: 'vatId',
    businessType: 'businessType',
    taxType: 'taxType',
    userId: 'userId',
    memberId: 'memberId'
  };

  export type BusinessAccScalarFieldEnum = (typeof BusinessAccScalarFieldEnum)[keyof typeof BusinessAccScalarFieldEnum]


  export const BillScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    cName: 'cName',
    cLastName: 'cLastName',
    cPhone: 'cPhone',
    cGender: 'cGender',
    cAddress: 'cAddress',
    cProvince: 'cProvince',
    cPostId: 'cPostId',
    product: 'product',
    payment: 'payment',
    amount: 'amount',
    purchaseAt: 'purchaseAt',
    platform: 'platform',
    cashStatus: 'cashStatus',
    price: 'price',
    image: 'image',
    deleted: 'deleted',
    memberId: 'memberId',
    businessAcc: 'businessAcc',
    storeId: 'storeId'
  };

  export type BillScalarFieldEnum = (typeof BillScalarFieldEnum)[keyof typeof BillScalarFieldEnum]


  export const AdsCostScalarFieldEnum: {
    id: 'id',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    adsCost: 'adsCost',
    memberId: 'memberId',
    platformId: 'platformId',
    product: 'product',
    businessAcc: 'businessAcc'
  };

  export type AdsCostScalarFieldEnum = (typeof AdsCostScalarFieldEnum)[keyof typeof AdsCostScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    amount: 'amount',
    group: 'group',
    image: 'image',
    note: 'note',
    desc: 'desc',
    deleted: 'deleted',
    save: 'save',
    channel: 'channel',
    code: 'code',
    businessAcc: 'businessAcc',
    memberId: 'memberId'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const PlatformScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    accName: 'accName',
    accId: 'accId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    businessAcc: 'businessAcc',
    memberId: 'memberId',
    deleted: 'deleted'
  };

  export type PlatformScalarFieldEnum = (typeof PlatformScalarFieldEnum)[keyof typeof PlatformScalarFieldEnum]


  export const StoreScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    accName: 'accName',
    accId: 'accId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    businessAcc: 'businessAcc',
    memberId: 'memberId',
    deleted: 'deleted'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    barcode: 'barcode',
    image: 'image',
    stock: 'stock',
    price: 'price',
    categoryId: 'categoryId',
    memberId: 'memberId',
    statusId: 'statusId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deleted: 'deleted',
    businessAcc: 'businessAcc'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const CreditScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    ownerId: 'ownerId',
    creditorId: 'creditorId'
  };

  export type CreditScalarFieldEnum = (typeof CreditScalarFieldEnum)[keyof typeof CreditScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hashtag: 'hashtag',
    content: 'content',
    mediaUrl: 'mediaUrl',
    mediaType: 'mediaType',
    published: 'published',
    authorId: 'authorId',
    deleted: 'deleted'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const ReactionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    type: 'type',
    postId: 'postId',
    userId: 'userId'
  };

  export type ReactionScalarFieldEnum = (typeof ReactionScalarFieldEnum)[keyof typeof ReactionScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    content: 'content',
    postId: 'postId',
    userId: 'userId',
    deleted: 'deleted'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const InboxScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    read: 'read',
    unsent: 'unsent',
    deleted: 'deleted'
  };

  export type InboxScalarFieldEnum = (typeof InboxScalarFieldEnum)[keyof typeof InboxScalarFieldEnum]


  export const ShopScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    productType: 'productType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    category: 'category',
    sellerId: 'sellerId',
    buyerId: 'buyerId',
    deleted: 'deleted'
  };

  export type ShopScalarFieldEnum = (typeof ShopScalarFieldEnum)[keyof typeof ShopScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    quantity: 'quantity',
    shopId: 'shopId',
    buyerId: 'buyerId',
    sellerId: 'sellerId',
    deleted: 'deleted'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OptionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    shopId: 'shopId'
  };

  export type OptionScalarFieldEnum = (typeof OptionScalarFieldEnum)[keyof typeof OptionScalarFieldEnum]


  export const OptionValueScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    value: 'value',
    price: 'price',
    interest: 'interest',
    duration: 'duration',
    optionId: 'optionId'
  };

  export type OptionValueScalarFieldEnum = (typeof OptionValueScalarFieldEnum)[keyof typeof OptionValueScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    content: 'content',
    rating: 'rating',
    shopId: 'shopId',
    userId: 'userId',
    orderId: 'orderId'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const CartScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    orderId: 'orderId',
    payment: 'payment',
    status: 'status',
    total: 'total'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'BusinessType'
   */
  export type EnumBusinessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusinessType'>
    


  /**
   * Reference to a field of type 'BusinessType[]'
   */
  export type ListEnumBusinessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusinessType[]'>
    


  /**
   * Reference to a field of type 'taxType'
   */
  export type EnumtaxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'taxType'>
    


  /**
   * Reference to a field of type 'taxType[]'
   */
  export type ListEnumtaxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'taxType[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Payment'
   */
  export type EnumPaymentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Payment'>
    


  /**
   * Reference to a field of type 'Payment[]'
   */
  export type ListEnumPaymentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Payment[]'>
    


  /**
   * Reference to a field of type 'IncomeChannel'
   */
  export type EnumIncomeChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncomeChannel'>
    


  /**
   * Reference to a field of type 'IncomeChannel[]'
   */
  export type ListEnumIncomeChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncomeChannel[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Bank'
   */
  export type EnumBankFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bank'>
    


  /**
   * Reference to a field of type 'Bank[]'
   */
  export type ListEnumBankFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bank[]'>
    


  /**
   * Reference to a field of type 'SocialMedia'
   */
  export type EnumSocialMediaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialMedia'>
    


  /**
   * Reference to a field of type 'SocialMedia[]'
   */
  export type ListEnumSocialMediaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialMedia[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'ReactionType'
   */
  export type EnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType'>
    


  /**
   * Reference to a field of type 'ReactionType[]'
   */
  export type ListEnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType[]'>
    


  /**
   * Reference to a field of type 'ProductType'
   */
  export type EnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType'>
    


  /**
   * Reference to a field of type 'ProductType[]'
   */
  export type ListEnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType[]'>
    


  /**
   * Reference to a field of type 'Category'
   */
  export type EnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category'>
    


  /**
   * Reference to a field of type 'Category[]'
   */
  export type ListEnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category[]'>
    


  /**
   * Reference to a field of type 'OptionName'
   */
  export type EnumOptionNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OptionName'>
    


  /**
   * Reference to a field of type 'OptionName[]'
   */
  export type ListEnumOptionNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OptionName[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    phone?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    business?: BusinessAccListRelationFilter
    member?: MemberListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    reactions?: ReactionListRelationFilter
    sentMessages?: InboxListRelationFilter
    receivedMessages?: InboxListRelationFilter
    seller?: ShopListRelationFilter
    buyer?: ShopListRelationFilter
    Order?: OrderListRelationFilter
    review?: ReviewListRelationFilter
    owner?: CreditListRelationFilter
    credit?: CreditListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phone?: SortOrder
    username?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    business?: BusinessAccOrderByRelationAggregateInput
    member?: MemberOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    reactions?: ReactionOrderByRelationAggregateInput
    sentMessages?: InboxOrderByRelationAggregateInput
    receivedMessages?: InboxOrderByRelationAggregateInput
    seller?: ShopOrderByRelationAggregateInput
    buyer?: ShopOrderByRelationAggregateInput
    Order?: OrderOrderByRelationAggregateInput
    review?: ReviewOrderByRelationAggregateInput
    owner?: CreditOrderByRelationAggregateInput
    credit?: CreditOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    phone?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    bio?: StringNullableFilter<"User"> | string | null
    business?: BusinessAccListRelationFilter
    member?: MemberListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    reactions?: ReactionListRelationFilter
    sentMessages?: InboxListRelationFilter
    receivedMessages?: InboxListRelationFilter
    seller?: ShopListRelationFilter
    buyer?: ShopListRelationFilter
    Order?: OrderListRelationFilter
    review?: ReviewListRelationFilter
    owner?: CreditListRelationFilter
    credit?: CreditListRelationFilter
  }, "id" | "email" | "phone" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phone?: SortOrder
    username?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    phone?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    uniqueId?: StringFilter<"Member"> | string
    role?: EnumUserRoleFilter<"Member"> | $Enums.UserRole
    permission?: StringFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    userId?: IntFilter<"Member"> | number
    businessId?: IntNullableFilter<"Member"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    business?: XOR<BusinessAccNullableScalarRelationFilter, BusinessAccWhereInput> | null
    bill?: BillListRelationFilter
    adsCost?: AdsCostListRelationFilter
    expense?: ExpenseListRelationFilter
    product?: ProductListRelationFilter
    platform?: PlatformListRelationFilter
    store?: StoreListRelationFilter
  }

  export type MemberOrderByWithRelationInput = {
    uniqueId?: SortOrder
    role?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    businessId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    business?: BusinessAccOrderByWithRelationInput
    bill?: BillOrderByRelationAggregateInput
    adsCost?: AdsCostOrderByRelationAggregateInput
    expense?: ExpenseOrderByRelationAggregateInput
    product?: ProductOrderByRelationAggregateInput
    platform?: PlatformOrderByRelationAggregateInput
    store?: StoreOrderByRelationAggregateInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    uniqueId?: string
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    role?: EnumUserRoleFilter<"Member"> | $Enums.UserRole
    permission?: StringFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    userId?: IntFilter<"Member"> | number
    businessId?: IntNullableFilter<"Member"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    business?: XOR<BusinessAccNullableScalarRelationFilter, BusinessAccWhereInput> | null
    bill?: BillListRelationFilter
    adsCost?: AdsCostListRelationFilter
    expense?: ExpenseListRelationFilter
    product?: ProductListRelationFilter
    platform?: PlatformListRelationFilter
    store?: StoreListRelationFilter
  }, "uniqueId">

  export type MemberOrderByWithAggregationInput = {
    uniqueId?: SortOrder
    role?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    businessId?: SortOrderInput | SortOrder
    _count?: MemberCountOrderByAggregateInput
    _avg?: MemberAvgOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
    _sum?: MemberSumOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    uniqueId?: StringWithAggregatesFilter<"Member"> | string
    role?: EnumUserRoleWithAggregatesFilter<"Member"> | $Enums.UserRole
    permission?: StringWithAggregatesFilter<"Member"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    userId?: IntWithAggregatesFilter<"Member"> | number
    businessId?: IntNullableWithAggregatesFilter<"Member"> | number | null
  }

  export type BusinessAccWhereInput = {
    AND?: BusinessAccWhereInput | BusinessAccWhereInput[]
    OR?: BusinessAccWhereInput[]
    NOT?: BusinessAccWhereInput | BusinessAccWhereInput[]
    id?: IntFilter<"BusinessAcc"> | number
    createdAt?: DateTimeNullableFilter<"BusinessAcc"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"BusinessAcc"> | Date | string | null
    businessName?: StringFilter<"BusinessAcc"> | string
    businessUserName?: StringNullableFilter<"BusinessAcc"> | string | null
    businessAvatar?: StringNullableFilter<"BusinessAcc"> | string | null
    businessAddress?: StringNullableFilter<"BusinessAcc"> | string | null
    vatId?: StringFilter<"BusinessAcc"> | string
    businessType?: EnumBusinessTypeFilter<"BusinessAcc"> | $Enums.BusinessType
    taxType?: EnumtaxTypeFilter<"BusinessAcc"> | $Enums.taxType
    userId?: IntFilter<"BusinessAcc"> | number
    memberId?: StringNullableFilter<"BusinessAcc"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    AllMember?: MemberListRelationFilter
    billRecord?: BillListRelationFilter
    expenseRecord?: ExpenseListRelationFilter
    adsCostRecord?: AdsCostListRelationFilter
    platform?: PlatformListRelationFilter
    storefront?: StoreListRelationFilter
    product?: ProductListRelationFilter
  }

  export type BusinessAccOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    businessName?: SortOrder
    businessUserName?: SortOrderInput | SortOrder
    businessAvatar?: SortOrderInput | SortOrder
    businessAddress?: SortOrderInput | SortOrder
    vatId?: SortOrder
    businessType?: SortOrder
    taxType?: SortOrder
    userId?: SortOrder
    memberId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    AllMember?: MemberOrderByRelationAggregateInput
    billRecord?: BillOrderByRelationAggregateInput
    expenseRecord?: ExpenseOrderByRelationAggregateInput
    adsCostRecord?: AdsCostOrderByRelationAggregateInput
    platform?: PlatformOrderByRelationAggregateInput
    storefront?: StoreOrderByRelationAggregateInput
    product?: ProductOrderByRelationAggregateInput
  }

  export type BusinessAccWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    businessName?: string
    businessUserName?: string
    vatId?: string
    AND?: BusinessAccWhereInput | BusinessAccWhereInput[]
    OR?: BusinessAccWhereInput[]
    NOT?: BusinessAccWhereInput | BusinessAccWhereInput[]
    createdAt?: DateTimeNullableFilter<"BusinessAcc"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"BusinessAcc"> | Date | string | null
    businessAvatar?: StringNullableFilter<"BusinessAcc"> | string | null
    businessAddress?: StringNullableFilter<"BusinessAcc"> | string | null
    businessType?: EnumBusinessTypeFilter<"BusinessAcc"> | $Enums.BusinessType
    taxType?: EnumtaxTypeFilter<"BusinessAcc"> | $Enums.taxType
    userId?: IntFilter<"BusinessAcc"> | number
    memberId?: StringNullableFilter<"BusinessAcc"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    AllMember?: MemberListRelationFilter
    billRecord?: BillListRelationFilter
    expenseRecord?: ExpenseListRelationFilter
    adsCostRecord?: AdsCostListRelationFilter
    platform?: PlatformListRelationFilter
    storefront?: StoreListRelationFilter
    product?: ProductListRelationFilter
  }, "id" | "businessName" | "businessUserName" | "vatId">

  export type BusinessAccOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    businessName?: SortOrder
    businessUserName?: SortOrderInput | SortOrder
    businessAvatar?: SortOrderInput | SortOrder
    businessAddress?: SortOrderInput | SortOrder
    vatId?: SortOrder
    businessType?: SortOrder
    taxType?: SortOrder
    userId?: SortOrder
    memberId?: SortOrderInput | SortOrder
    _count?: BusinessAccCountOrderByAggregateInput
    _avg?: BusinessAccAvgOrderByAggregateInput
    _max?: BusinessAccMaxOrderByAggregateInput
    _min?: BusinessAccMinOrderByAggregateInput
    _sum?: BusinessAccSumOrderByAggregateInput
  }

  export type BusinessAccScalarWhereWithAggregatesInput = {
    AND?: BusinessAccScalarWhereWithAggregatesInput | BusinessAccScalarWhereWithAggregatesInput[]
    OR?: BusinessAccScalarWhereWithAggregatesInput[]
    NOT?: BusinessAccScalarWhereWithAggregatesInput | BusinessAccScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BusinessAcc"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"BusinessAcc"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"BusinessAcc"> | Date | string | null
    businessName?: StringWithAggregatesFilter<"BusinessAcc"> | string
    businessUserName?: StringNullableWithAggregatesFilter<"BusinessAcc"> | string | null
    businessAvatar?: StringNullableWithAggregatesFilter<"BusinessAcc"> | string | null
    businessAddress?: StringNullableWithAggregatesFilter<"BusinessAcc"> | string | null
    vatId?: StringWithAggregatesFilter<"BusinessAcc"> | string
    businessType?: EnumBusinessTypeWithAggregatesFilter<"BusinessAcc"> | $Enums.BusinessType
    taxType?: EnumtaxTypeWithAggregatesFilter<"BusinessAcc"> | $Enums.taxType
    userId?: IntWithAggregatesFilter<"BusinessAcc"> | number
    memberId?: StringNullableWithAggregatesFilter<"BusinessAcc"> | string | null
  }

  export type BillWhereInput = {
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    id?: IntFilter<"Bill"> | number
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    updatedAt?: DateTimeFilter<"Bill"> | Date | string
    cName?: StringFilter<"Bill"> | string
    cLastName?: StringNullableFilter<"Bill"> | string | null
    cPhone?: StringNullableFilter<"Bill"> | string | null
    cGender?: EnumGenderNullableFilter<"Bill"> | $Enums.Gender | null
    cAddress?: StringNullableFilter<"Bill"> | string | null
    cProvince?: StringNullableFilter<"Bill"> | string | null
    cPostId?: StringNullableFilter<"Bill"> | string | null
    product?: StringFilter<"Bill"> | string
    payment?: EnumPaymentFilter<"Bill"> | $Enums.Payment
    amount?: IntFilter<"Bill"> | number
    purchaseAt?: DateTimeFilter<"Bill"> | Date | string
    platform?: EnumIncomeChannelFilter<"Bill"> | $Enums.IncomeChannel
    cashStatus?: BoolFilter<"Bill"> | boolean
    price?: IntFilter<"Bill"> | number
    image?: StringNullableFilter<"Bill"> | string | null
    deleted?: BoolNullableFilter<"Bill"> | boolean | null
    memberId?: StringFilter<"Bill"> | string
    businessAcc?: IntFilter<"Bill"> | number
    storeId?: IntFilter<"Bill"> | number
    productList?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    businessId?: XOR<BusinessAccScalarRelationFilter, BusinessAccWhereInput>
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
  }

  export type BillOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cName?: SortOrder
    cLastName?: SortOrderInput | SortOrder
    cPhone?: SortOrderInput | SortOrder
    cGender?: SortOrderInput | SortOrder
    cAddress?: SortOrderInput | SortOrder
    cProvince?: SortOrderInput | SortOrder
    cPostId?: SortOrderInput | SortOrder
    product?: SortOrder
    payment?: SortOrder
    amount?: SortOrder
    purchaseAt?: SortOrder
    platform?: SortOrder
    cashStatus?: SortOrder
    price?: SortOrder
    image?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    memberId?: SortOrder
    businessAcc?: SortOrder
    storeId?: SortOrder
    productList?: ProductOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
    businessId?: BusinessAccOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
  }

  export type BillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    memberId?: string
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    updatedAt?: DateTimeFilter<"Bill"> | Date | string
    cName?: StringFilter<"Bill"> | string
    cLastName?: StringNullableFilter<"Bill"> | string | null
    cPhone?: StringNullableFilter<"Bill"> | string | null
    cGender?: EnumGenderNullableFilter<"Bill"> | $Enums.Gender | null
    cAddress?: StringNullableFilter<"Bill"> | string | null
    cProvince?: StringNullableFilter<"Bill"> | string | null
    cPostId?: StringNullableFilter<"Bill"> | string | null
    product?: StringFilter<"Bill"> | string
    payment?: EnumPaymentFilter<"Bill"> | $Enums.Payment
    amount?: IntFilter<"Bill"> | number
    purchaseAt?: DateTimeFilter<"Bill"> | Date | string
    platform?: EnumIncomeChannelFilter<"Bill"> | $Enums.IncomeChannel
    cashStatus?: BoolFilter<"Bill"> | boolean
    price?: IntFilter<"Bill"> | number
    image?: StringNullableFilter<"Bill"> | string | null
    deleted?: BoolNullableFilter<"Bill"> | boolean | null
    businessAcc?: IntFilter<"Bill"> | number
    storeId?: IntFilter<"Bill"> | number
    productList?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    businessId?: XOR<BusinessAccScalarRelationFilter, BusinessAccWhereInput>
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
  }, "id" | "memberId">

  export type BillOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cName?: SortOrder
    cLastName?: SortOrderInput | SortOrder
    cPhone?: SortOrderInput | SortOrder
    cGender?: SortOrderInput | SortOrder
    cAddress?: SortOrderInput | SortOrder
    cProvince?: SortOrderInput | SortOrder
    cPostId?: SortOrderInput | SortOrder
    product?: SortOrder
    payment?: SortOrder
    amount?: SortOrder
    purchaseAt?: SortOrder
    platform?: SortOrder
    cashStatus?: SortOrder
    price?: SortOrder
    image?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    memberId?: SortOrder
    businessAcc?: SortOrder
    storeId?: SortOrder
    _count?: BillCountOrderByAggregateInput
    _avg?: BillAvgOrderByAggregateInput
    _max?: BillMaxOrderByAggregateInput
    _min?: BillMinOrderByAggregateInput
    _sum?: BillSumOrderByAggregateInput
  }

  export type BillScalarWhereWithAggregatesInput = {
    AND?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    OR?: BillScalarWhereWithAggregatesInput[]
    NOT?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bill"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Bill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bill"> | Date | string
    cName?: StringWithAggregatesFilter<"Bill"> | string
    cLastName?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    cPhone?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    cGender?: EnumGenderNullableWithAggregatesFilter<"Bill"> | $Enums.Gender | null
    cAddress?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    cProvince?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    cPostId?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    product?: StringWithAggregatesFilter<"Bill"> | string
    payment?: EnumPaymentWithAggregatesFilter<"Bill"> | $Enums.Payment
    amount?: IntWithAggregatesFilter<"Bill"> | number
    purchaseAt?: DateTimeWithAggregatesFilter<"Bill"> | Date | string
    platform?: EnumIncomeChannelWithAggregatesFilter<"Bill"> | $Enums.IncomeChannel
    cashStatus?: BoolWithAggregatesFilter<"Bill"> | boolean
    price?: IntWithAggregatesFilter<"Bill"> | number
    image?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"Bill"> | boolean | null
    memberId?: StringWithAggregatesFilter<"Bill"> | string
    businessAcc?: IntWithAggregatesFilter<"Bill"> | number
    storeId?: IntWithAggregatesFilter<"Bill"> | number
  }

  export type AdsCostWhereInput = {
    AND?: AdsCostWhereInput | AdsCostWhereInput[]
    OR?: AdsCostWhereInput[]
    NOT?: AdsCostWhereInput | AdsCostWhereInput[]
    id?: IntFilter<"AdsCost"> | number
    date?: DateTimeFilter<"AdsCost"> | Date | string
    createdAt?: DateTimeFilter<"AdsCost"> | Date | string
    updatedAt?: DateTimeFilter<"AdsCost"> | Date | string
    adsCost?: DecimalFilter<"AdsCost"> | Decimal | DecimalJsLike | number | string
    memberId?: StringFilter<"AdsCost"> | string
    platformId?: IntFilter<"AdsCost"> | number
    product?: StringFilter<"AdsCost"> | string
    businessAcc?: IntFilter<"AdsCost"> | number
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    platform?: XOR<PlatformScalarRelationFilter, PlatformWhereInput>
    businessId?: XOR<BusinessAccScalarRelationFilter, BusinessAccWhereInput>
    productList?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type AdsCostOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adsCost?: SortOrder
    memberId?: SortOrder
    platformId?: SortOrder
    product?: SortOrder
    businessAcc?: SortOrder
    member?: MemberOrderByWithRelationInput
    platform?: PlatformOrderByWithRelationInput
    businessId?: BusinessAccOrderByWithRelationInput
    productList?: ProductOrderByWithRelationInput
  }

  export type AdsCostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdsCostWhereInput | AdsCostWhereInput[]
    OR?: AdsCostWhereInput[]
    NOT?: AdsCostWhereInput | AdsCostWhereInput[]
    date?: DateTimeFilter<"AdsCost"> | Date | string
    createdAt?: DateTimeFilter<"AdsCost"> | Date | string
    updatedAt?: DateTimeFilter<"AdsCost"> | Date | string
    adsCost?: DecimalFilter<"AdsCost"> | Decimal | DecimalJsLike | number | string
    memberId?: StringFilter<"AdsCost"> | string
    platformId?: IntFilter<"AdsCost"> | number
    product?: StringFilter<"AdsCost"> | string
    businessAcc?: IntFilter<"AdsCost"> | number
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    platform?: XOR<PlatformScalarRelationFilter, PlatformWhereInput>
    businessId?: XOR<BusinessAccScalarRelationFilter, BusinessAccWhereInput>
    productList?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type AdsCostOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adsCost?: SortOrder
    memberId?: SortOrder
    platformId?: SortOrder
    product?: SortOrder
    businessAcc?: SortOrder
    _count?: AdsCostCountOrderByAggregateInput
    _avg?: AdsCostAvgOrderByAggregateInput
    _max?: AdsCostMaxOrderByAggregateInput
    _min?: AdsCostMinOrderByAggregateInput
    _sum?: AdsCostSumOrderByAggregateInput
  }

  export type AdsCostScalarWhereWithAggregatesInput = {
    AND?: AdsCostScalarWhereWithAggregatesInput | AdsCostScalarWhereWithAggregatesInput[]
    OR?: AdsCostScalarWhereWithAggregatesInput[]
    NOT?: AdsCostScalarWhereWithAggregatesInput | AdsCostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdsCost"> | number
    date?: DateTimeWithAggregatesFilter<"AdsCost"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AdsCost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdsCost"> | Date | string
    adsCost?: DecimalWithAggregatesFilter<"AdsCost"> | Decimal | DecimalJsLike | number | string
    memberId?: StringWithAggregatesFilter<"AdsCost"> | string
    platformId?: IntWithAggregatesFilter<"AdsCost"> | number
    product?: StringWithAggregatesFilter<"AdsCost"> | string
    businessAcc?: IntWithAggregatesFilter<"AdsCost"> | number
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    date?: DateTimeFilter<"Expense"> | Date | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    id?: IntFilter<"Expense"> | number
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    group?: StringNullableFilter<"Expense"> | string | null
    image?: StringNullableFilter<"Expense"> | string | null
    note?: StringNullableFilter<"Expense"> | string | null
    desc?: StringNullableFilter<"Expense"> | string | null
    deleted?: BoolNullableFilter<"Expense"> | boolean | null
    save?: BoolNullableFilter<"Expense"> | boolean | null
    channel?: EnumBankNullableFilter<"Expense"> | $Enums.Bank | null
    code?: StringNullableFilter<"Expense"> | string | null
    businessAcc?: IntFilter<"Expense"> | number
    memberId?: StringFilter<"Expense"> | string
    businessId?: XOR<BusinessAccScalarRelationFilter, BusinessAccWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type ExpenseOrderByWithRelationInput = {
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    amount?: SortOrder
    group?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    desc?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    save?: SortOrderInput | SortOrder
    channel?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    businessAcc?: SortOrder
    memberId?: SortOrder
    businessId?: BusinessAccOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    date?: DateTimeFilter<"Expense"> | Date | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    group?: StringNullableFilter<"Expense"> | string | null
    image?: StringNullableFilter<"Expense"> | string | null
    note?: StringNullableFilter<"Expense"> | string | null
    desc?: StringNullableFilter<"Expense"> | string | null
    deleted?: BoolNullableFilter<"Expense"> | boolean | null
    save?: BoolNullableFilter<"Expense"> | boolean | null
    channel?: EnumBankNullableFilter<"Expense"> | $Enums.Bank | null
    code?: StringNullableFilter<"Expense"> | string | null
    businessAcc?: IntFilter<"Expense"> | number
    memberId?: StringFilter<"Expense"> | string
    businessId?: XOR<BusinessAccScalarRelationFilter, BusinessAccWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    amount?: SortOrder
    group?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    desc?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    save?: SortOrderInput | SortOrder
    channel?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    businessAcc?: SortOrder
    memberId?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    date?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    id?: IntWithAggregatesFilter<"Expense"> | number
    amount?: DecimalWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    group?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    image?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    note?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    desc?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"Expense"> | boolean | null
    save?: BoolNullableWithAggregatesFilter<"Expense"> | boolean | null
    channel?: EnumBankNullableWithAggregatesFilter<"Expense"> | $Enums.Bank | null
    code?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    businessAcc?: IntWithAggregatesFilter<"Expense"> | number
    memberId?: StringWithAggregatesFilter<"Expense"> | string
  }

  export type PlatformWhereInput = {
    AND?: PlatformWhereInput | PlatformWhereInput[]
    OR?: PlatformWhereInput[]
    NOT?: PlatformWhereInput | PlatformWhereInput[]
    id?: IntFilter<"Platform"> | number
    platform?: EnumSocialMediaFilter<"Platform"> | $Enums.SocialMedia
    accName?: StringFilter<"Platform"> | string
    accId?: StringFilter<"Platform"> | string
    createdAt?: DateTimeFilter<"Platform"> | Date | string
    updatedAt?: DateTimeFilter<"Platform"> | Date | string
    businessAcc?: IntFilter<"Platform"> | number
    memberId?: StringFilter<"Platform"> | string
    deleted?: BoolNullableFilter<"Platform"> | boolean | null
    platformId?: AdsCostListRelationFilter
    businessId?: XOR<BusinessAccScalarRelationFilter, BusinessAccWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type PlatformOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    accName?: SortOrder
    accId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessAcc?: SortOrder
    memberId?: SortOrder
    deleted?: SortOrderInput | SortOrder
    platformId?: AdsCostOrderByRelationAggregateInput
    businessId?: BusinessAccOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
  }

  export type PlatformWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    accName?: string
    AND?: PlatformWhereInput | PlatformWhereInput[]
    OR?: PlatformWhereInput[]
    NOT?: PlatformWhereInput | PlatformWhereInput[]
    platform?: EnumSocialMediaFilter<"Platform"> | $Enums.SocialMedia
    accId?: StringFilter<"Platform"> | string
    createdAt?: DateTimeFilter<"Platform"> | Date | string
    updatedAt?: DateTimeFilter<"Platform"> | Date | string
    businessAcc?: IntFilter<"Platform"> | number
    memberId?: StringFilter<"Platform"> | string
    deleted?: BoolNullableFilter<"Platform"> | boolean | null
    platformId?: AdsCostListRelationFilter
    businessId?: XOR<BusinessAccScalarRelationFilter, BusinessAccWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id" | "accName">

  export type PlatformOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    accName?: SortOrder
    accId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessAcc?: SortOrder
    memberId?: SortOrder
    deleted?: SortOrderInput | SortOrder
    _count?: PlatformCountOrderByAggregateInput
    _avg?: PlatformAvgOrderByAggregateInput
    _max?: PlatformMaxOrderByAggregateInput
    _min?: PlatformMinOrderByAggregateInput
    _sum?: PlatformSumOrderByAggregateInput
  }

  export type PlatformScalarWhereWithAggregatesInput = {
    AND?: PlatformScalarWhereWithAggregatesInput | PlatformScalarWhereWithAggregatesInput[]
    OR?: PlatformScalarWhereWithAggregatesInput[]
    NOT?: PlatformScalarWhereWithAggregatesInput | PlatformScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Platform"> | number
    platform?: EnumSocialMediaWithAggregatesFilter<"Platform"> | $Enums.SocialMedia
    accName?: StringWithAggregatesFilter<"Platform"> | string
    accId?: StringWithAggregatesFilter<"Platform"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Platform"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Platform"> | Date | string
    businessAcc?: IntWithAggregatesFilter<"Platform"> | number
    memberId?: StringWithAggregatesFilter<"Platform"> | string
    deleted?: BoolNullableWithAggregatesFilter<"Platform"> | boolean | null
  }

  export type StoreWhereInput = {
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    id?: IntFilter<"Store"> | number
    platform?: EnumIncomeChannelFilter<"Store"> | $Enums.IncomeChannel
    accName?: StringFilter<"Store"> | string
    accId?: StringFilter<"Store"> | string
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    businessAcc?: IntFilter<"Store"> | number
    memberId?: StringFilter<"Store"> | string
    deleted?: BoolNullableFilter<"Store"> | boolean | null
    storefrontId?: BillListRelationFilter
    businessId?: XOR<BusinessAccScalarRelationFilter, BusinessAccWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type StoreOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    accName?: SortOrder
    accId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessAcc?: SortOrder
    memberId?: SortOrder
    deleted?: SortOrderInput | SortOrder
    storefrontId?: BillOrderByRelationAggregateInput
    businessId?: BusinessAccOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
  }

  export type StoreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    accName?: string
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    platform?: EnumIncomeChannelFilter<"Store"> | $Enums.IncomeChannel
    accId?: StringFilter<"Store"> | string
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    businessAcc?: IntFilter<"Store"> | number
    memberId?: StringFilter<"Store"> | string
    deleted?: BoolNullableFilter<"Store"> | boolean | null
    storefrontId?: BillListRelationFilter
    businessId?: XOR<BusinessAccScalarRelationFilter, BusinessAccWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id" | "accName">

  export type StoreOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    accName?: SortOrder
    accId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessAcc?: SortOrder
    memberId?: SortOrder
    deleted?: SortOrderInput | SortOrder
    _count?: StoreCountOrderByAggregateInput
    _avg?: StoreAvgOrderByAggregateInput
    _max?: StoreMaxOrderByAggregateInput
    _min?: StoreMinOrderByAggregateInput
    _sum?: StoreSumOrderByAggregateInput
  }

  export type StoreScalarWhereWithAggregatesInput = {
    AND?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    OR?: StoreScalarWhereWithAggregatesInput[]
    NOT?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Store"> | number
    platform?: EnumIncomeChannelWithAggregatesFilter<"Store"> | $Enums.IncomeChannel
    accName?: StringWithAggregatesFilter<"Store"> | string
    accId?: StringWithAggregatesFilter<"Store"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
    businessAcc?: IntWithAggregatesFilter<"Store"> | number
    memberId?: StringWithAggregatesFilter<"Store"> | string
    deleted?: BoolNullableWithAggregatesFilter<"Store"> | boolean | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    barcode?: StringFilter<"Product"> | string
    image?: StringNullableFilter<"Product"> | string | null
    stock?: IntFilter<"Product"> | number
    price?: IntFilter<"Product"> | number
    categoryId?: IntNullableFilter<"Product"> | number | null
    memberId?: StringFilter<"Product"> | string
    statusId?: IntNullableFilter<"Product"> | number | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deleted?: BoolNullableFilter<"Product"> | boolean | null
    businessAcc?: IntFilter<"Product"> | number
    billRecord?: BillListRelationFilter
    adsRecord?: AdsCostListRelationFilter
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    businessId?: XOR<BusinessAccScalarRelationFilter, BusinessAccWhereInput>
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    barcode?: SortOrder
    image?: SortOrderInput | SortOrder
    stock?: SortOrder
    price?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    memberId?: SortOrder
    statusId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrderInput | SortOrder
    businessAcc?: SortOrder
    billRecord?: BillOrderByRelationAggregateInput
    adsRecord?: AdsCostOrderByRelationAggregateInput
    member?: MemberOrderByWithRelationInput
    businessId?: BusinessAccOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    description?: StringNullableFilter<"Product"> | string | null
    barcode?: StringFilter<"Product"> | string
    image?: StringNullableFilter<"Product"> | string | null
    stock?: IntFilter<"Product"> | number
    price?: IntFilter<"Product"> | number
    categoryId?: IntNullableFilter<"Product"> | number | null
    memberId?: StringFilter<"Product"> | string
    statusId?: IntNullableFilter<"Product"> | number | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deleted?: BoolNullableFilter<"Product"> | boolean | null
    businessAcc?: IntFilter<"Product"> | number
    billRecord?: BillListRelationFilter
    adsRecord?: AdsCostListRelationFilter
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    businessId?: XOR<BusinessAccScalarRelationFilter, BusinessAccWhereInput>
  }, "id" | "name">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    barcode?: SortOrder
    image?: SortOrderInput | SortOrder
    stock?: SortOrder
    price?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    memberId?: SortOrder
    statusId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrderInput | SortOrder
    businessAcc?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    barcode?: StringWithAggregatesFilter<"Product"> | string
    image?: StringNullableWithAggregatesFilter<"Product"> | string | null
    stock?: IntWithAggregatesFilter<"Product"> | number
    price?: IntWithAggregatesFilter<"Product"> | number
    categoryId?: IntNullableWithAggregatesFilter<"Product"> | number | null
    memberId?: StringWithAggregatesFilter<"Product"> | string
    statusId?: IntNullableWithAggregatesFilter<"Product"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    deleted?: BoolNullableWithAggregatesFilter<"Product"> | boolean | null
    businessAcc?: IntWithAggregatesFilter<"Product"> | number
  }

  export type CreditWhereInput = {
    AND?: CreditWhereInput | CreditWhereInput[]
    OR?: CreditWhereInput[]
    NOT?: CreditWhereInput | CreditWhereInput[]
    id?: IntFilter<"Credit"> | number
    createdAt?: DateTimeFilter<"Credit"> | Date | string
    ownerId?: IntFilter<"Credit"> | number
    creditorId?: IntFilter<"Credit"> | number
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    creditor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CreditOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    ownerId?: SortOrder
    creditorId?: SortOrder
    owner?: UserOrderByWithRelationInput
    creditor?: UserOrderByWithRelationInput
  }

  export type CreditWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CreditWhereInput | CreditWhereInput[]
    OR?: CreditWhereInput[]
    NOT?: CreditWhereInput | CreditWhereInput[]
    createdAt?: DateTimeFilter<"Credit"> | Date | string
    ownerId?: IntFilter<"Credit"> | number
    creditorId?: IntFilter<"Credit"> | number
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    creditor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CreditOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    ownerId?: SortOrder
    creditorId?: SortOrder
    _count?: CreditCountOrderByAggregateInput
    _avg?: CreditAvgOrderByAggregateInput
    _max?: CreditMaxOrderByAggregateInput
    _min?: CreditMinOrderByAggregateInput
    _sum?: CreditSumOrderByAggregateInput
  }

  export type CreditScalarWhereWithAggregatesInput = {
    AND?: CreditScalarWhereWithAggregatesInput | CreditScalarWhereWithAggregatesInput[]
    OR?: CreditScalarWhereWithAggregatesInput[]
    NOT?: CreditScalarWhereWithAggregatesInput | CreditScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Credit"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Credit"> | Date | string
    ownerId?: IntWithAggregatesFilter<"Credit"> | number
    creditorId?: IntWithAggregatesFilter<"Credit"> | number
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: IntFilter<"Post"> | number
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    hashtag?: StringNullableListFilter<"Post">
    content?: StringNullableFilter<"Post"> | string | null
    mediaUrl?: StringNullableFilter<"Post"> | string | null
    mediaType?: EnumMediaTypeNullableFilter<"Post"> | $Enums.MediaType | null
    published?: BoolFilter<"Post"> | boolean
    authorId?: IntFilter<"Post"> | number
    deleted?: BoolNullableFilter<"Post"> | boolean | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    reactions?: ReactionListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hashtag?: SortOrder
    content?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    published?: SortOrder
    authorId?: SortOrder
    deleted?: SortOrderInput | SortOrder
    author?: UserOrderByWithRelationInput
    reactions?: ReactionOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    hashtag?: StringNullableListFilter<"Post">
    content?: StringNullableFilter<"Post"> | string | null
    mediaUrl?: StringNullableFilter<"Post"> | string | null
    mediaType?: EnumMediaTypeNullableFilter<"Post"> | $Enums.MediaType | null
    published?: BoolFilter<"Post"> | boolean
    authorId?: IntFilter<"Post"> | number
    deleted?: BoolNullableFilter<"Post"> | boolean | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    reactions?: ReactionListRelationFilter
    comments?: CommentListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hashtag?: SortOrder
    content?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    published?: SortOrder
    authorId?: SortOrder
    deleted?: SortOrderInput | SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Post"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    hashtag?: StringNullableListFilter<"Post">
    content?: StringNullableWithAggregatesFilter<"Post"> | string | null
    mediaUrl?: StringNullableWithAggregatesFilter<"Post"> | string | null
    mediaType?: EnumMediaTypeNullableWithAggregatesFilter<"Post"> | $Enums.MediaType | null
    published?: BoolWithAggregatesFilter<"Post"> | boolean
    authorId?: IntWithAggregatesFilter<"Post"> | number
    deleted?: BoolNullableWithAggregatesFilter<"Post"> | boolean | null
  }

  export type ReactionWhereInput = {
    AND?: ReactionWhereInput | ReactionWhereInput[]
    OR?: ReactionWhereInput[]
    NOT?: ReactionWhereInput | ReactionWhereInput[]
    id?: IntFilter<"Reaction"> | number
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
    updatedAt?: DateTimeFilter<"Reaction"> | Date | string
    type?: EnumReactionTypeFilter<"Reaction"> | $Enums.ReactionType
    postId?: IntFilter<"Reaction"> | number
    userId?: IntFilter<"Reaction"> | number
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReactionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReactionWhereInput | ReactionWhereInput[]
    OR?: ReactionWhereInput[]
    NOT?: ReactionWhereInput | ReactionWhereInput[]
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
    updatedAt?: DateTimeFilter<"Reaction"> | Date | string
    type?: EnumReactionTypeFilter<"Reaction"> | $Enums.ReactionType
    postId?: IntFilter<"Reaction"> | number
    userId?: IntFilter<"Reaction"> | number
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReactionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    _count?: ReactionCountOrderByAggregateInput
    _avg?: ReactionAvgOrderByAggregateInput
    _max?: ReactionMaxOrderByAggregateInput
    _min?: ReactionMinOrderByAggregateInput
    _sum?: ReactionSumOrderByAggregateInput
  }

  export type ReactionScalarWhereWithAggregatesInput = {
    AND?: ReactionScalarWhereWithAggregatesInput | ReactionScalarWhereWithAggregatesInput[]
    OR?: ReactionScalarWhereWithAggregatesInput[]
    NOT?: ReactionScalarWhereWithAggregatesInput | ReactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Reaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reaction"> | Date | string
    type?: EnumReactionTypeWithAggregatesFilter<"Reaction"> | $Enums.ReactionType
    postId?: IntWithAggregatesFilter<"Reaction"> | number
    userId?: IntWithAggregatesFilter<"Reaction"> | number
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    content?: StringFilter<"Comment"> | string
    postId?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    deleted?: BoolNullableFilter<"Comment"> | boolean | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    deleted?: SortOrderInput | SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    content?: StringFilter<"Comment"> | string
    postId?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    deleted?: BoolNullableFilter<"Comment"> | boolean | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    deleted?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    postId?: IntWithAggregatesFilter<"Comment"> | number
    userId?: IntWithAggregatesFilter<"Comment"> | number
    deleted?: BoolNullableWithAggregatesFilter<"Comment"> | boolean | null
  }

  export type InboxWhereInput = {
    AND?: InboxWhereInput | InboxWhereInput[]
    OR?: InboxWhereInput[]
    NOT?: InboxWhereInput | InboxWhereInput[]
    id?: IntFilter<"Inbox"> | number
    senderId?: IntFilter<"Inbox"> | number
    receiverId?: IntFilter<"Inbox"> | number
    message?: StringFilter<"Inbox"> | string
    createdAt?: DateTimeFilter<"Inbox"> | Date | string
    updatedAt?: DateTimeFilter<"Inbox"> | Date | string
    read?: BoolFilter<"Inbox"> | boolean
    unsent?: BoolFilter<"Inbox"> | boolean
    deleted?: BoolNullableFilter<"Inbox"> | boolean | null
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InboxOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    read?: SortOrder
    unsent?: SortOrder
    deleted?: SortOrderInput | SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
  }

  export type InboxWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InboxWhereInput | InboxWhereInput[]
    OR?: InboxWhereInput[]
    NOT?: InboxWhereInput | InboxWhereInput[]
    senderId?: IntFilter<"Inbox"> | number
    receiverId?: IntFilter<"Inbox"> | number
    message?: StringFilter<"Inbox"> | string
    createdAt?: DateTimeFilter<"Inbox"> | Date | string
    updatedAt?: DateTimeFilter<"Inbox"> | Date | string
    read?: BoolFilter<"Inbox"> | boolean
    unsent?: BoolFilter<"Inbox"> | boolean
    deleted?: BoolNullableFilter<"Inbox"> | boolean | null
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InboxOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    read?: SortOrder
    unsent?: SortOrder
    deleted?: SortOrderInput | SortOrder
    _count?: InboxCountOrderByAggregateInput
    _avg?: InboxAvgOrderByAggregateInput
    _max?: InboxMaxOrderByAggregateInput
    _min?: InboxMinOrderByAggregateInput
    _sum?: InboxSumOrderByAggregateInput
  }

  export type InboxScalarWhereWithAggregatesInput = {
    AND?: InboxScalarWhereWithAggregatesInput | InboxScalarWhereWithAggregatesInput[]
    OR?: InboxScalarWhereWithAggregatesInput[]
    NOT?: InboxScalarWhereWithAggregatesInput | InboxScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inbox"> | number
    senderId?: IntWithAggregatesFilter<"Inbox"> | number
    receiverId?: IntWithAggregatesFilter<"Inbox"> | number
    message?: StringWithAggregatesFilter<"Inbox"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Inbox"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inbox"> | Date | string
    read?: BoolWithAggregatesFilter<"Inbox"> | boolean
    unsent?: BoolWithAggregatesFilter<"Inbox"> | boolean
    deleted?: BoolNullableWithAggregatesFilter<"Inbox"> | boolean | null
  }

  export type ShopWhereInput = {
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    id?: IntFilter<"Shop"> | number
    name?: StringFilter<"Shop"> | string
    description?: StringNullableFilter<"Shop"> | string | null
    productType?: EnumProductTypeFilter<"Shop"> | $Enums.ProductType
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    category?: EnumCategoryFilter<"Shop"> | $Enums.Category
    sellerId?: IntFilter<"Shop"> | number
    buyerId?: IntFilter<"Shop"> | number
    deleted?: BoolNullableFilter<"Shop"> | boolean | null
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    buyer?: XOR<UserScalarRelationFilter, UserWhereInput>
    orders?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    options?: OptionListRelationFilter
    review?: ReviewListRelationFilter
  }

  export type ShopOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    productType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    deleted?: SortOrderInput | SortOrder
    seller?: UserOrderByWithRelationInput
    buyer?: UserOrderByWithRelationInput
    orders?: OrderOrderByWithRelationInput
    options?: OptionOrderByRelationAggregateInput
    review?: ReviewOrderByRelationAggregateInput
  }

  export type ShopWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    name?: StringFilter<"Shop"> | string
    description?: StringNullableFilter<"Shop"> | string | null
    productType?: EnumProductTypeFilter<"Shop"> | $Enums.ProductType
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    category?: EnumCategoryFilter<"Shop"> | $Enums.Category
    sellerId?: IntFilter<"Shop"> | number
    buyerId?: IntFilter<"Shop"> | number
    deleted?: BoolNullableFilter<"Shop"> | boolean | null
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    buyer?: XOR<UserScalarRelationFilter, UserWhereInput>
    orders?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    options?: OptionListRelationFilter
    review?: ReviewListRelationFilter
  }, "id">

  export type ShopOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    productType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    deleted?: SortOrderInput | SortOrder
    _count?: ShopCountOrderByAggregateInput
    _avg?: ShopAvgOrderByAggregateInput
    _max?: ShopMaxOrderByAggregateInput
    _min?: ShopMinOrderByAggregateInput
    _sum?: ShopSumOrderByAggregateInput
  }

  export type ShopScalarWhereWithAggregatesInput = {
    AND?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    OR?: ShopScalarWhereWithAggregatesInput[]
    NOT?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Shop"> | number
    name?: StringWithAggregatesFilter<"Shop"> | string
    description?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    productType?: EnumProductTypeWithAggregatesFilter<"Shop"> | $Enums.ProductType
    createdAt?: DateTimeWithAggregatesFilter<"Shop"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shop"> | Date | string
    category?: EnumCategoryWithAggregatesFilter<"Shop"> | $Enums.Category
    sellerId?: IntWithAggregatesFilter<"Shop"> | number
    buyerId?: IntWithAggregatesFilter<"Shop"> | number
    deleted?: BoolNullableWithAggregatesFilter<"Shop"> | boolean | null
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    quantity?: IntFilter<"Order"> | number
    shopId?: IntFilter<"Order"> | number
    buyerId?: IntFilter<"Order"> | number
    sellerId?: IntFilter<"Order"> | number
    deleted?: BoolNullableFilter<"Order"> | boolean | null
    seller?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    buyer?: XOR<UserScalarRelationFilter, UserWhereInput>
    review?: XOR<ReviewNullableScalarRelationFilter, ReviewWhereInput> | null
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quantity?: SortOrder
    shopId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    deleted?: SortOrderInput | SortOrder
    seller?: ShopOrderByWithRelationInput
    buyer?: UserOrderByWithRelationInput
    review?: ReviewOrderByWithRelationInput
    cart?: CartOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    shopId?: number
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    quantity?: IntFilter<"Order"> | number
    buyerId?: IntFilter<"Order"> | number
    sellerId?: IntFilter<"Order"> | number
    deleted?: BoolNullableFilter<"Order"> | boolean | null
    seller?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    buyer?: XOR<UserScalarRelationFilter, UserWhereInput>
    review?: XOR<ReviewNullableScalarRelationFilter, ReviewWhereInput> | null
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
  }, "id" | "shopId">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quantity?: SortOrder
    shopId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    deleted?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    quantity?: IntWithAggregatesFilter<"Order"> | number
    shopId?: IntWithAggregatesFilter<"Order"> | number
    buyerId?: IntWithAggregatesFilter<"Order"> | number
    sellerId?: IntWithAggregatesFilter<"Order"> | number
    deleted?: BoolNullableWithAggregatesFilter<"Order"> | boolean | null
  }

  export type OptionWhereInput = {
    AND?: OptionWhereInput | OptionWhereInput[]
    OR?: OptionWhereInput[]
    NOT?: OptionWhereInput | OptionWhereInput[]
    id?: IntFilter<"Option"> | number
    createdAt?: DateTimeFilter<"Option"> | Date | string
    updatedAt?: DateTimeFilter<"Option"> | Date | string
    name?: EnumOptionNameFilter<"Option"> | $Enums.OptionName
    shopId?: IntFilter<"Option"> | number
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    values?: OptionValueListRelationFilter
  }

  export type OptionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    shopId?: SortOrder
    shop?: ShopOrderByWithRelationInput
    values?: OptionValueOrderByRelationAggregateInput
  }

  export type OptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OptionWhereInput | OptionWhereInput[]
    OR?: OptionWhereInput[]
    NOT?: OptionWhereInput | OptionWhereInput[]
    createdAt?: DateTimeFilter<"Option"> | Date | string
    updatedAt?: DateTimeFilter<"Option"> | Date | string
    name?: EnumOptionNameFilter<"Option"> | $Enums.OptionName
    shopId?: IntFilter<"Option"> | number
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    values?: OptionValueListRelationFilter
  }, "id">

  export type OptionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    shopId?: SortOrder
    _count?: OptionCountOrderByAggregateInput
    _avg?: OptionAvgOrderByAggregateInput
    _max?: OptionMaxOrderByAggregateInput
    _min?: OptionMinOrderByAggregateInput
    _sum?: OptionSumOrderByAggregateInput
  }

  export type OptionScalarWhereWithAggregatesInput = {
    AND?: OptionScalarWhereWithAggregatesInput | OptionScalarWhereWithAggregatesInput[]
    OR?: OptionScalarWhereWithAggregatesInput[]
    NOT?: OptionScalarWhereWithAggregatesInput | OptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Option"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Option"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Option"> | Date | string
    name?: EnumOptionNameWithAggregatesFilter<"Option"> | $Enums.OptionName
    shopId?: IntWithAggregatesFilter<"Option"> | number
  }

  export type OptionValueWhereInput = {
    AND?: OptionValueWhereInput | OptionValueWhereInput[]
    OR?: OptionValueWhereInput[]
    NOT?: OptionValueWhereInput | OptionValueWhereInput[]
    id?: IntFilter<"OptionValue"> | number
    createdAt?: DateTimeFilter<"OptionValue"> | Date | string
    updatedAt?: DateTimeFilter<"OptionValue"> | Date | string
    value?: StringFilter<"OptionValue"> | string
    price?: FloatNullableFilter<"OptionValue"> | number | null
    interest?: FloatNullableFilter<"OptionValue"> | number | null
    duration?: IntNullableFilter<"OptionValue"> | number | null
    optionId?: IntFilter<"OptionValue"> | number
    option?: XOR<OptionScalarRelationFilter, OptionWhereInput>
  }

  export type OptionValueOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    value?: SortOrder
    price?: SortOrderInput | SortOrder
    interest?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    optionId?: SortOrder
    option?: OptionOrderByWithRelationInput
  }

  export type OptionValueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OptionValueWhereInput | OptionValueWhereInput[]
    OR?: OptionValueWhereInput[]
    NOT?: OptionValueWhereInput | OptionValueWhereInput[]
    createdAt?: DateTimeFilter<"OptionValue"> | Date | string
    updatedAt?: DateTimeFilter<"OptionValue"> | Date | string
    value?: StringFilter<"OptionValue"> | string
    price?: FloatNullableFilter<"OptionValue"> | number | null
    interest?: FloatNullableFilter<"OptionValue"> | number | null
    duration?: IntNullableFilter<"OptionValue"> | number | null
    optionId?: IntFilter<"OptionValue"> | number
    option?: XOR<OptionScalarRelationFilter, OptionWhereInput>
  }, "id">

  export type OptionValueOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    value?: SortOrder
    price?: SortOrderInput | SortOrder
    interest?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    optionId?: SortOrder
    _count?: OptionValueCountOrderByAggregateInput
    _avg?: OptionValueAvgOrderByAggregateInput
    _max?: OptionValueMaxOrderByAggregateInput
    _min?: OptionValueMinOrderByAggregateInput
    _sum?: OptionValueSumOrderByAggregateInput
  }

  export type OptionValueScalarWhereWithAggregatesInput = {
    AND?: OptionValueScalarWhereWithAggregatesInput | OptionValueScalarWhereWithAggregatesInput[]
    OR?: OptionValueScalarWhereWithAggregatesInput[]
    NOT?: OptionValueScalarWhereWithAggregatesInput | OptionValueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OptionValue"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OptionValue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OptionValue"> | Date | string
    value?: StringWithAggregatesFilter<"OptionValue"> | string
    price?: FloatNullableWithAggregatesFilter<"OptionValue"> | number | null
    interest?: FloatNullableWithAggregatesFilter<"OptionValue"> | number | null
    duration?: IntNullableWithAggregatesFilter<"OptionValue"> | number | null
    optionId?: IntWithAggregatesFilter<"OptionValue"> | number
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: IntFilter<"Review"> | number
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    content?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    shopId?: IntFilter<"Review"> | number
    userId?: IntFilter<"Review"> | number
    orderId?: IntFilter<"Review"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    shopId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    order?: OrderOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    shop?: ShopOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderId?: number
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    content?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    shopId?: IntFilter<"Review"> | number
    userId?: IntFilter<"Review"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
  }, "id" | "orderId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    shopId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Review"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    content?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    shopId?: IntWithAggregatesFilter<"Review"> | number
    userId?: IntWithAggregatesFilter<"Review"> | number
    orderId?: IntWithAggregatesFilter<"Review"> | number
  }

  export type CartWhereInput = {
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    id?: IntFilter<"Cart"> | number
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    orderId?: IntFilter<"Cart"> | number
    payment?: EnumPaymentFilter<"Cart"> | $Enums.Payment
    status?: StringFilter<"Cart"> | string
    total?: IntFilter<"Cart"> | number
    order?: OrderListRelationFilter
  }

  export type CartOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderId?: SortOrder
    payment?: SortOrder
    status?: SortOrder
    total?: SortOrder
    order?: OrderOrderByRelationAggregateInput
  }

  export type CartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderId?: number
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    payment?: EnumPaymentFilter<"Cart"> | $Enums.Payment
    status?: StringFilter<"Cart"> | string
    total?: IntFilter<"Cart"> | number
    order?: OrderListRelationFilter
  }, "id" | "orderId">

  export type CartOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderId?: SortOrder
    payment?: SortOrder
    status?: SortOrder
    total?: SortOrder
    _count?: CartCountOrderByAggregateInput
    _avg?: CartAvgOrderByAggregateInput
    _max?: CartMaxOrderByAggregateInput
    _min?: CartMinOrderByAggregateInput
    _sum?: CartSumOrderByAggregateInput
  }

  export type CartScalarWhereWithAggregatesInput = {
    AND?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    OR?: CartScalarWhereWithAggregatesInput[]
    NOT?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cart"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
    orderId?: IntWithAggregatesFilter<"Cart"> | number
    payment?: EnumPaymentWithAggregatesFilter<"Cart"> | $Enums.Payment
    status?: StringWithAggregatesFilter<"Cart"> | string
    total?: IntWithAggregatesFilter<"Cart"> | number
  }

  export type UserCreateInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccCreateNestedManyWithoutUserInput
    member?: MemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    sentMessages?: InboxCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxCreateNestedManyWithoutReceiverInput
    seller?: ShopCreateNestedManyWithoutSellerInput
    buyer?: ShopCreateNestedManyWithoutBuyerInput
    Order?: OrderCreateNestedManyWithoutBuyerInput
    review?: ReviewCreateNestedManyWithoutUserInput
    owner?: CreditCreateNestedManyWithoutOwnerInput
    credit?: CreditCreateNestedManyWithoutCreditorInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccUncheckedCreateNestedManyWithoutUserInput
    member?: MemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: InboxUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxUncheckedCreateNestedManyWithoutReceiverInput
    seller?: ShopUncheckedCreateNestedManyWithoutSellerInput
    buyer?: ShopUncheckedCreateNestedManyWithoutBuyerInput
    Order?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    owner?: CreditUncheckedCreateNestedManyWithoutOwnerInput
    credit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUpdateManyWithoutUserNestedInput
    member?: MemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUpdateManyWithoutReceiverNestedInput
    seller?: ShopUpdateManyWithoutSellerNestedInput
    buyer?: ShopUpdateManyWithoutBuyerNestedInput
    Order?: OrderUpdateManyWithoutBuyerNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    owner?: CreditUpdateManyWithoutOwnerNestedInput
    credit?: CreditUpdateManyWithoutCreditorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUncheckedUpdateManyWithoutUserNestedInput
    member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUncheckedUpdateManyWithoutReceiverNestedInput
    seller?: ShopUncheckedUpdateManyWithoutSellerNestedInput
    buyer?: ShopUncheckedUpdateManyWithoutBuyerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    owner?: CreditUncheckedUpdateManyWithoutOwnerNestedInput
    credit?: CreditUncheckedUpdateManyWithoutCreditorNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberCreateInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMemberInput
    business?: BusinessAccCreateNestedOneWithoutAllMemberInput
    bill?: BillCreateNestedManyWithoutMemberInput
    adsCost?: AdsCostCreateNestedManyWithoutMemberInput
    expense?: ExpenseCreateNestedManyWithoutMemberInput
    product?: ProductCreateNestedManyWithoutMemberInput
    platform?: PlatformCreateNestedManyWithoutMemberInput
    store?: StoreCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    businessId?: number | null
    bill?: BillUncheckedCreateNestedManyWithoutMemberInput
    adsCost?: AdsCostUncheckedCreateNestedManyWithoutMemberInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutMemberInput
    product?: ProductUncheckedCreateNestedManyWithoutMemberInput
    platform?: PlatformUncheckedCreateNestedManyWithoutMemberInput
    store?: StoreUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberUpdateInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMemberNestedInput
    business?: BusinessAccUpdateOneWithoutAllMemberNestedInput
    bill?: BillUpdateManyWithoutMemberNestedInput
    adsCost?: AdsCostUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUpdateManyWithoutMemberNestedInput
    product?: ProductUpdateManyWithoutMemberNestedInput
    platform?: PlatformUpdateManyWithoutMemberNestedInput
    store?: StoreUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    businessId?: NullableIntFieldUpdateOperationsInput | number | null
    bill?: BillUncheckedUpdateManyWithoutMemberNestedInput
    adsCost?: AdsCostUncheckedUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutMemberNestedInput
    product?: ProductUncheckedUpdateManyWithoutMemberNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutMemberNestedInput
    store?: StoreUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateManyInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    businessId?: number | null
  }

  export type MemberUpdateManyMutationInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    businessId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BusinessAccCreateInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    memberId?: string | null
    user: UserCreateNestedOneWithoutBusinessInput
    AllMember?: MemberCreateNestedManyWithoutBusinessInput
    billRecord?: BillCreateNestedManyWithoutBusinessIdInput
    expenseRecord?: ExpenseCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreCreateNestedManyWithoutBusinessIdInput
    product?: ProductCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    userId: number
    memberId?: string | null
    AllMember?: MemberUncheckedCreateNestedManyWithoutBusinessInput
    billRecord?: BillUncheckedCreateNestedManyWithoutBusinessIdInput
    expenseRecord?: ExpenseUncheckedCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostUncheckedCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformUncheckedCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreUncheckedCreateNestedManyWithoutBusinessIdInput
    product?: ProductUncheckedCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    AllMember?: MemberUpdateManyWithoutBusinessNestedInput
    billRecord?: BillUpdateManyWithoutBusinessIdNestedInput
    expenseRecord?: ExpenseUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUpdateManyWithoutBusinessIdNestedInput
  }

  export type BusinessAccUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    userId?: IntFieldUpdateOperationsInput | number
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    AllMember?: MemberUncheckedUpdateManyWithoutBusinessNestedInput
    billRecord?: BillUncheckedUpdateManyWithoutBusinessIdNestedInput
    expenseRecord?: ExpenseUncheckedUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUncheckedUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUncheckedUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUncheckedUpdateManyWithoutBusinessIdNestedInput
  }

  export type BusinessAccCreateManyInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    userId: number
    memberId?: string | null
  }

  export type BusinessAccUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessAccUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    userId?: IntFieldUpdateOperationsInput | number
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    cName: string
    cLastName?: string | null
    cPhone?: string | null
    cGender?: $Enums.Gender | null
    cAddress?: string | null
    cProvince?: string | null
    cPostId?: string | null
    payment: $Enums.Payment
    amount: number
    purchaseAt?: Date | string
    platform: $Enums.IncomeChannel
    cashStatus?: boolean
    price: number
    image?: string | null
    deleted?: boolean | null
    productList: ProductCreateNestedOneWithoutBillRecordInput
    member: MemberCreateNestedOneWithoutBillInput
    businessId: BusinessAccCreateNestedOneWithoutBillRecordInput
    store: StoreCreateNestedOneWithoutStorefrontIdInput
  }

  export type BillUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cName: string
    cLastName?: string | null
    cPhone?: string | null
    cGender?: $Enums.Gender | null
    cAddress?: string | null
    cProvince?: string | null
    cPostId?: string | null
    product: string
    payment: $Enums.Payment
    amount: number
    purchaseAt?: Date | string
    platform: $Enums.IncomeChannel
    cashStatus?: boolean
    price: number
    image?: string | null
    deleted?: boolean | null
    memberId: string
    businessAcc: number
    storeId: number
  }

  export type BillUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    productList?: ProductUpdateOneRequiredWithoutBillRecordNestedInput
    member?: MemberUpdateOneRequiredWithoutBillNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutBillRecordNestedInput
    store?: StoreUpdateOneRequiredWithoutStorefrontIdNestedInput
  }

  export type BillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    product?: StringFieldUpdateOperationsInput | string
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    memberId?: StringFieldUpdateOperationsInput | string
    businessAcc?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type BillCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cName: string
    cLastName?: string | null
    cPhone?: string | null
    cGender?: $Enums.Gender | null
    cAddress?: string | null
    cProvince?: string | null
    cPostId?: string | null
    product: string
    payment: $Enums.Payment
    amount: number
    purchaseAt?: Date | string
    platform: $Enums.IncomeChannel
    cashStatus?: boolean
    price: number
    image?: string | null
    deleted?: boolean | null
    memberId: string
    businessAcc: number
    storeId: number
  }

  export type BillUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    product?: StringFieldUpdateOperationsInput | string
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    memberId?: StringFieldUpdateOperationsInput | string
    businessAcc?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type AdsCostCreateInput = {
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    adsCost: Decimal | DecimalJsLike | number | string
    member: MemberCreateNestedOneWithoutAdsCostInput
    platform: PlatformCreateNestedOneWithoutPlatformIdInput
    businessId: BusinessAccCreateNestedOneWithoutAdsCostRecordInput
    productList: ProductCreateNestedOneWithoutAdsRecordInput
  }

  export type AdsCostUncheckedCreateInput = {
    id?: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    adsCost: Decimal | DecimalJsLike | number | string
    memberId: string
    platformId: number
    product: string
    businessAcc: number
  }

  export type AdsCostUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    member?: MemberUpdateOneRequiredWithoutAdsCostNestedInput
    platform?: PlatformUpdateOneRequiredWithoutPlatformIdNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutAdsCostRecordNestedInput
    productList?: ProductUpdateOneRequiredWithoutAdsRecordNestedInput
  }

  export type AdsCostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    memberId?: StringFieldUpdateOperationsInput | string
    platformId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    businessAcc?: IntFieldUpdateOperationsInput | number
  }

  export type AdsCostCreateManyInput = {
    id?: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    adsCost: Decimal | DecimalJsLike | number | string
    memberId: string
    platformId: number
    product: string
    businessAcc: number
  }

  export type AdsCostUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AdsCostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    memberId?: StringFieldUpdateOperationsInput | string
    platformId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    businessAcc?: IntFieldUpdateOperationsInput | number
  }

  export type ExpenseCreateInput = {
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    group?: string | null
    image?: string | null
    note?: string | null
    desc?: string | null
    deleted?: boolean | null
    save?: boolean | null
    channel?: $Enums.Bank | null
    code?: string | null
    businessId: BusinessAccCreateNestedOneWithoutExpenseRecordInput
    member: MemberCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateInput = {
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    group?: string | null
    image?: string | null
    note?: string | null
    desc?: string | null
    deleted?: boolean | null
    save?: boolean | null
    channel?: $Enums.Bank | null
    code?: string | null
    businessAcc: number
    memberId: string
  }

  export type ExpenseUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    save?: NullableBoolFieldUpdateOperationsInput | boolean | null
    channel?: NullableEnumBankFieldUpdateOperationsInput | $Enums.Bank | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: BusinessAccUpdateOneRequiredWithoutExpenseRecordNestedInput
    member?: MemberUpdateOneRequiredWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    save?: NullableBoolFieldUpdateOperationsInput | boolean | null
    channel?: NullableEnumBankFieldUpdateOperationsInput | $Enums.Bank | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    businessAcc?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseCreateManyInput = {
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    group?: string | null
    image?: string | null
    note?: string | null
    desc?: string | null
    deleted?: boolean | null
    save?: boolean | null
    channel?: $Enums.Bank | null
    code?: string | null
    businessAcc: number
    memberId: string
  }

  export type ExpenseUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    save?: NullableBoolFieldUpdateOperationsInput | boolean | null
    channel?: NullableEnumBankFieldUpdateOperationsInput | $Enums.Bank | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUncheckedUpdateManyInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    save?: NullableBoolFieldUpdateOperationsInput | boolean | null
    channel?: NullableEnumBankFieldUpdateOperationsInput | $Enums.Bank | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    businessAcc?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type PlatformCreateInput = {
    platform: $Enums.SocialMedia
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    platformId?: AdsCostCreateNestedManyWithoutPlatformInput
    businessId: BusinessAccCreateNestedOneWithoutPlatformInput
    member: MemberCreateNestedOneWithoutPlatformInput
  }

  export type PlatformUncheckedCreateInput = {
    id?: number
    platform: $Enums.SocialMedia
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessAcc: number
    memberId: string
    deleted?: boolean | null
    platformId?: AdsCostUncheckedCreateNestedManyWithoutPlatformInput
  }

  export type PlatformUpdateInput = {
    platform?: EnumSocialMediaFieldUpdateOperationsInput | $Enums.SocialMedia
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    platformId?: AdsCostUpdateManyWithoutPlatformNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutPlatformNestedInput
    member?: MemberUpdateOneRequiredWithoutPlatformNestedInput
  }

  export type PlatformUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumSocialMediaFieldUpdateOperationsInput | $Enums.SocialMedia
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessAcc?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    platformId?: AdsCostUncheckedUpdateManyWithoutPlatformNestedInput
  }

  export type PlatformCreateManyInput = {
    id?: number
    platform: $Enums.SocialMedia
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessAcc: number
    memberId: string
    deleted?: boolean | null
  }

  export type PlatformUpdateManyMutationInput = {
    platform?: EnumSocialMediaFieldUpdateOperationsInput | $Enums.SocialMedia
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PlatformUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumSocialMediaFieldUpdateOperationsInput | $Enums.SocialMedia
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessAcc?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StoreCreateInput = {
    platform: $Enums.IncomeChannel
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    storefrontId?: BillCreateNestedManyWithoutStoreInput
    businessId: BusinessAccCreateNestedOneWithoutStorefrontInput
    member: MemberCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateInput = {
    id?: number
    platform: $Enums.IncomeChannel
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessAcc: number
    memberId: string
    deleted?: boolean | null
    storefrontId?: BillUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreUpdateInput = {
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storefrontId?: BillUpdateManyWithoutStoreNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutStorefrontNestedInput
    member?: MemberUpdateOneRequiredWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessAcc?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storefrontId?: BillUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreCreateManyInput = {
    id?: number
    platform: $Enums.IncomeChannel
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessAcc: number
    memberId: string
    deleted?: boolean | null
  }

  export type StoreUpdateManyMutationInput = {
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StoreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessAcc?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ProductCreateInput = {
    name: string
    description?: string | null
    barcode: string
    image?: string | null
    stock: number
    price: number
    categoryId?: number | null
    statusId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    billRecord?: BillCreateNestedManyWithoutProductListInput
    adsRecord?: AdsCostCreateNestedManyWithoutProductListInput
    member: MemberCreateNestedOneWithoutProductInput
    businessId: BusinessAccCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    barcode: string
    image?: string | null
    stock: number
    price: number
    categoryId?: number | null
    memberId: string
    statusId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    businessAcc: number
    billRecord?: BillUncheckedCreateNestedManyWithoutProductListInput
    adsRecord?: AdsCostUncheckedCreateNestedManyWithoutProductListInput
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    billRecord?: BillUpdateManyWithoutProductListNestedInput
    adsRecord?: AdsCostUpdateManyWithoutProductListNestedInput
    member?: MemberUpdateOneRequiredWithoutProductNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    memberId?: StringFieldUpdateOperationsInput | string
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    businessAcc?: IntFieldUpdateOperationsInput | number
    billRecord?: BillUncheckedUpdateManyWithoutProductListNestedInput
    adsRecord?: AdsCostUncheckedUpdateManyWithoutProductListNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    barcode: string
    image?: string | null
    stock: number
    price: number
    categoryId?: number | null
    memberId: string
    statusId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    businessAcc: number
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    memberId?: StringFieldUpdateOperationsInput | string
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    businessAcc?: IntFieldUpdateOperationsInput | number
  }

  export type CreditCreateInput = {
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnerInput
    creditor: UserCreateNestedOneWithoutCreditInput
  }

  export type CreditUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    ownerId: number
    creditorId: number
  }

  export type CreditUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnerNestedInput
    creditor?: UserUpdateOneRequiredWithoutCreditNestedInput
  }

  export type CreditUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
    creditorId?: IntFieldUpdateOperationsInput | number
  }

  export type CreditCreateManyInput = {
    id?: number
    createdAt?: Date | string
    ownerId: number
    creditorId: number
  }

  export type CreditUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
    creditorId?: IntFieldUpdateOperationsInput | number
  }

  export type PostCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    hashtag?: PostCreatehashtagInput | string[]
    content?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.MediaType | null
    published?: boolean
    deleted?: boolean | null
    author: UserCreateNestedOneWithoutPostsInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hashtag?: PostCreatehashtagInput | string[]
    content?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.MediaType | null
    published?: boolean
    authorId: number
    deleted?: boolean | null
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtag?: PostUpdatehashtagInput | string[]
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    published?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtag?: PostUpdatehashtagInput | string[]
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    published?: BoolFieldUpdateOperationsInput | boolean
    authorId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hashtag?: PostCreatehashtagInput | string[]
    content?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.MediaType | null
    published?: boolean
    authorId: number
    deleted?: boolean | null
  }

  export type PostUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtag?: PostUpdatehashtagInput | string[]
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    published?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtag?: PostUpdatehashtagInput | string[]
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    published?: BoolFieldUpdateOperationsInput | boolean
    authorId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ReactionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ReactionType
    post: PostCreateNestedOneWithoutReactionsInput
    user: UserCreateNestedOneWithoutReactionsInput
  }

  export type ReactionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ReactionType
    postId: number
    userId: number
  }

  export type ReactionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    post?: PostUpdateOneRequiredWithoutReactionsNestedInput
    user?: UserUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type ReactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ReactionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ReactionType
    postId: number
    userId: number
  }

  export type ReactionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
  }

  export type ReactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    deleted?: boolean | null
    post: PostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    postId: number
    userId: number
    deleted?: boolean | null
  }

  export type CommentUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CommentCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    postId: number
    userId: number
    deleted?: boolean | null
  }

  export type CommentUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type InboxCreateInput = {
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    unsent?: boolean
    deleted?: boolean | null
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type InboxUncheckedCreateInput = {
    id?: number
    senderId: number
    receiverId: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    unsent?: boolean
    deleted?: boolean | null
  }

  export type InboxUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    unsent?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type InboxUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    unsent?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type InboxCreateManyInput = {
    id?: number
    senderId: number
    receiverId: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    unsent?: boolean
    deleted?: boolean | null
  }

  export type InboxUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    unsent?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type InboxUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    unsent?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ShopCreateInput = {
    name: string
    description?: string | null
    productType?: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: $Enums.Category
    deleted?: boolean | null
    seller: UserCreateNestedOneWithoutSellerInput
    buyer: UserCreateNestedOneWithoutBuyerInput
    orders?: OrderCreateNestedOneWithoutSellerInput
    options?: OptionCreateNestedManyWithoutShopInput
    review?: ReviewCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    productType?: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: $Enums.Category
    sellerId: number
    buyerId: number
    deleted?: boolean | null
    orders?: OrderUncheckedCreateNestedOneWithoutSellerInput
    options?: OptionUncheckedCreateNestedManyWithoutShopInput
    review?: ReviewUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seller?: UserUpdateOneRequiredWithoutSellerNestedInput
    buyer?: UserUpdateOneRequiredWithoutBuyerNestedInput
    orders?: OrderUpdateOneWithoutSellerNestedInput
    options?: OptionUpdateManyWithoutShopNestedInput
    review?: ReviewUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    sellerId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orders?: OrderUncheckedUpdateOneWithoutSellerNestedInput
    options?: OptionUncheckedUpdateManyWithoutShopNestedInput
    review?: ReviewUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    productType?: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: $Enums.Category
    sellerId: number
    buyerId: number
    deleted?: boolean | null
  }

  export type ShopUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ShopUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    sellerId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OrderCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity: number
    buyerId: number
    deleted?: boolean | null
    seller: ShopCreateNestedOneWithoutOrdersInput
    buyer: UserCreateNestedOneWithoutOrderInput
    review?: ReviewCreateNestedOneWithoutOrderInput
    cart?: CartCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity: number
    shopId: number
    buyerId: number
    sellerId: number
    deleted?: boolean | null
    review?: ReviewUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seller?: ShopUpdateOneRequiredWithoutOrdersNestedInput
    buyer?: UserUpdateOneRequiredWithoutOrderNestedInput
    review?: ReviewUpdateOneWithoutOrderNestedInput
    cart?: CartUpdateOneRequiredWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    review?: ReviewUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity: number
    shopId: number
    buyerId: number
    sellerId: number
    deleted?: boolean | null
  }

  export type OrderUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OptionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: $Enums.OptionName
    shop: ShopCreateNestedOneWithoutOptionsInput
    values?: OptionValueCreateNestedManyWithoutOptionInput
  }

  export type OptionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: $Enums.OptionName
    shopId: number
    values?: OptionValueUncheckedCreateNestedManyWithoutOptionInput
  }

  export type OptionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: EnumOptionNameFieldUpdateOperationsInput | $Enums.OptionName
    shop?: ShopUpdateOneRequiredWithoutOptionsNestedInput
    values?: OptionValueUpdateManyWithoutOptionNestedInput
  }

  export type OptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: EnumOptionNameFieldUpdateOperationsInput | $Enums.OptionName
    shopId?: IntFieldUpdateOperationsInput | number
    values?: OptionValueUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type OptionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: $Enums.OptionName
    shopId: number
  }

  export type OptionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: EnumOptionNameFieldUpdateOperationsInput | $Enums.OptionName
  }

  export type OptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: EnumOptionNameFieldUpdateOperationsInput | $Enums.OptionName
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type OptionValueCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    value: string
    price?: number | null
    interest?: number | null
    duration?: number | null
    option: OptionCreateNestedOneWithoutValuesInput
  }

  export type OptionValueUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    value: string
    price?: number | null
    interest?: number | null
    duration?: number | null
    optionId: number
  }

  export type OptionValueUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    interest?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    option?: OptionUpdateOneRequiredWithoutValuesNestedInput
  }

  export type OptionValueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    interest?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    optionId?: IntFieldUpdateOperationsInput | number
  }

  export type OptionValueCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    value: string
    price?: number | null
    interest?: number | null
    duration?: number | null
    optionId: number
  }

  export type OptionValueUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    interest?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OptionValueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    interest?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    optionId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    rating: number
    order: OrderCreateNestedOneWithoutReviewInput
    user: UserCreateNestedOneWithoutReviewInput
    shop: ShopCreateNestedOneWithoutReviewInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    rating: number
    shopId: number
    userId: number
    orderId: number
  }

  export type ReviewUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutReviewNestedInput
    user?: UserUpdateOneRequiredWithoutReviewNestedInput
    shop?: ShopUpdateOneRequiredWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    rating: number
    shopId: number
    userId: number
    orderId: number
  }

  export type ReviewUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type CartCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId: number
    payment: $Enums.Payment
    status: string
    total: number
    order?: OrderCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId: number
    payment: $Enums.Payment
    status: string
    total: number
    order?: OrderUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: IntFieldUpdateOperationsInput | number
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    status?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: IntFieldUpdateOperationsInput | number
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    status?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    order?: OrderUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId: number
    payment: $Enums.Payment
    status: string
    total: number
  }

  export type CartUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: IntFieldUpdateOperationsInput | number
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    status?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
  }

  export type CartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: IntFieldUpdateOperationsInput | number
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    status?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BusinessAccListRelationFilter = {
    every?: BusinessAccWhereInput
    some?: BusinessAccWhereInput
    none?: BusinessAccWhereInput
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ReactionListRelationFilter = {
    every?: ReactionWhereInput
    some?: ReactionWhereInput
    none?: ReactionWhereInput
  }

  export type InboxListRelationFilter = {
    every?: InboxWhereInput
    some?: InboxWhereInput
    none?: InboxWhereInput
  }

  export type ShopListRelationFilter = {
    every?: ShopWhereInput
    some?: ShopWhereInput
    none?: ShopWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type CreditListRelationFilter = {
    every?: CreditWhereInput
    some?: CreditWhereInput
    none?: CreditWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BusinessAccOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InboxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phone?: SortOrder
    username?: SortOrder
    bio?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phone?: SortOrder
    username?: SortOrder
    bio?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phone?: SortOrder
    username?: SortOrder
    bio?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BusinessAccNullableScalarRelationFilter = {
    is?: BusinessAccWhereInput | null
    isNot?: BusinessAccWhereInput | null
  }

  export type BillListRelationFilter = {
    every?: BillWhereInput
    some?: BillWhereInput
    none?: BillWhereInput
  }

  export type AdsCostListRelationFilter = {
    every?: AdsCostWhereInput
    some?: AdsCostWhereInput
    none?: AdsCostWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type PlatformListRelationFilter = {
    every?: PlatformWhereInput
    some?: PlatformWhereInput
    none?: PlatformWhereInput
  }

  export type StoreListRelationFilter = {
    every?: StoreWhereInput
    some?: StoreWhereInput
    none?: StoreWhereInput
  }

  export type BillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdsCostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlatformOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberCountOrderByAggregateInput = {
    uniqueId?: SortOrder
    role?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    businessId?: SortOrder
  }

  export type MemberAvgOrderByAggregateInput = {
    userId?: SortOrder
    businessId?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    uniqueId?: SortOrder
    role?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    businessId?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    uniqueId?: SortOrder
    role?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    businessId?: SortOrder
  }

  export type MemberSumOrderByAggregateInput = {
    userId?: SortOrder
    businessId?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumBusinessTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessType | EnumBusinessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessTypeFilter<$PrismaModel> | $Enums.BusinessType
  }

  export type EnumtaxTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.taxType | EnumtaxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.taxType[] | ListEnumtaxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.taxType[] | ListEnumtaxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumtaxTypeFilter<$PrismaModel> | $Enums.taxType
  }

  export type BusinessAccCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessName?: SortOrder
    businessUserName?: SortOrder
    businessAvatar?: SortOrder
    businessAddress?: SortOrder
    vatId?: SortOrder
    businessType?: SortOrder
    taxType?: SortOrder
    userId?: SortOrder
    memberId?: SortOrder
  }

  export type BusinessAccAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BusinessAccMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessName?: SortOrder
    businessUserName?: SortOrder
    businessAvatar?: SortOrder
    businessAddress?: SortOrder
    vatId?: SortOrder
    businessType?: SortOrder
    taxType?: SortOrder
    userId?: SortOrder
    memberId?: SortOrder
  }

  export type BusinessAccMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessName?: SortOrder
    businessUserName?: SortOrder
    businessAvatar?: SortOrder
    businessAddress?: SortOrder
    vatId?: SortOrder
    businessType?: SortOrder
    taxType?: SortOrder
    userId?: SortOrder
    memberId?: SortOrder
  }

  export type BusinessAccSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumBusinessTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessType | EnumBusinessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessTypeWithAggregatesFilter<$PrismaModel> | $Enums.BusinessType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBusinessTypeFilter<$PrismaModel>
    _max?: NestedEnumBusinessTypeFilter<$PrismaModel>
  }

  export type EnumtaxTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.taxType | EnumtaxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.taxType[] | ListEnumtaxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.taxType[] | ListEnumtaxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumtaxTypeWithAggregatesFilter<$PrismaModel> | $Enums.taxType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtaxTypeFilter<$PrismaModel>
    _max?: NestedEnumtaxTypeFilter<$PrismaModel>
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EnumPaymentFilter<$PrismaModel = never> = {
    equals?: $Enums.Payment | EnumPaymentFieldRefInput<$PrismaModel>
    in?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    notIn?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentFilter<$PrismaModel> | $Enums.Payment
  }

  export type EnumIncomeChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeChannel | EnumIncomeChannelFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeChannel[] | ListEnumIncomeChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncomeChannel[] | ListEnumIncomeChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumIncomeChannelFilter<$PrismaModel> | $Enums.IncomeChannel
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type MemberScalarRelationFilter = {
    is?: MemberWhereInput
    isNot?: MemberWhereInput
  }

  export type BusinessAccScalarRelationFilter = {
    is?: BusinessAccWhereInput
    isNot?: BusinessAccWhereInput
  }

  export type StoreScalarRelationFilter = {
    is?: StoreWhereInput
    isNot?: StoreWhereInput
  }

  export type BillCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cName?: SortOrder
    cLastName?: SortOrder
    cPhone?: SortOrder
    cGender?: SortOrder
    cAddress?: SortOrder
    cProvince?: SortOrder
    cPostId?: SortOrder
    product?: SortOrder
    payment?: SortOrder
    amount?: SortOrder
    purchaseAt?: SortOrder
    platform?: SortOrder
    cashStatus?: SortOrder
    price?: SortOrder
    image?: SortOrder
    deleted?: SortOrder
    memberId?: SortOrder
    businessAcc?: SortOrder
    storeId?: SortOrder
  }

  export type BillAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    businessAcc?: SortOrder
    storeId?: SortOrder
  }

  export type BillMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cName?: SortOrder
    cLastName?: SortOrder
    cPhone?: SortOrder
    cGender?: SortOrder
    cAddress?: SortOrder
    cProvince?: SortOrder
    cPostId?: SortOrder
    product?: SortOrder
    payment?: SortOrder
    amount?: SortOrder
    purchaseAt?: SortOrder
    platform?: SortOrder
    cashStatus?: SortOrder
    price?: SortOrder
    image?: SortOrder
    deleted?: SortOrder
    memberId?: SortOrder
    businessAcc?: SortOrder
    storeId?: SortOrder
  }

  export type BillMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cName?: SortOrder
    cLastName?: SortOrder
    cPhone?: SortOrder
    cGender?: SortOrder
    cAddress?: SortOrder
    cProvince?: SortOrder
    cPostId?: SortOrder
    product?: SortOrder
    payment?: SortOrder
    amount?: SortOrder
    purchaseAt?: SortOrder
    platform?: SortOrder
    cashStatus?: SortOrder
    price?: SortOrder
    image?: SortOrder
    deleted?: SortOrder
    memberId?: SortOrder
    businessAcc?: SortOrder
    storeId?: SortOrder
  }

  export type BillSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    businessAcc?: SortOrder
    storeId?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type EnumPaymentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Payment | EnumPaymentFieldRefInput<$PrismaModel>
    in?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    notIn?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentWithAggregatesFilter<$PrismaModel> | $Enums.Payment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentFilter<$PrismaModel>
    _max?: NestedEnumPaymentFilter<$PrismaModel>
  }

  export type EnumIncomeChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeChannel | EnumIncomeChannelFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeChannel[] | ListEnumIncomeChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncomeChannel[] | ListEnumIncomeChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumIncomeChannelWithAggregatesFilter<$PrismaModel> | $Enums.IncomeChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncomeChannelFilter<$PrismaModel>
    _max?: NestedEnumIncomeChannelFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type PlatformScalarRelationFilter = {
    is?: PlatformWhereInput
    isNot?: PlatformWhereInput
  }

  export type AdsCostCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adsCost?: SortOrder
    memberId?: SortOrder
    platformId?: SortOrder
    product?: SortOrder
    businessAcc?: SortOrder
  }

  export type AdsCostAvgOrderByAggregateInput = {
    id?: SortOrder
    adsCost?: SortOrder
    platformId?: SortOrder
    businessAcc?: SortOrder
  }

  export type AdsCostMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adsCost?: SortOrder
    memberId?: SortOrder
    platformId?: SortOrder
    product?: SortOrder
    businessAcc?: SortOrder
  }

  export type AdsCostMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adsCost?: SortOrder
    memberId?: SortOrder
    platformId?: SortOrder
    product?: SortOrder
    businessAcc?: SortOrder
  }

  export type AdsCostSumOrderByAggregateInput = {
    id?: SortOrder
    adsCost?: SortOrder
    platformId?: SortOrder
    businessAcc?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumBankNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Bank | EnumBankFieldRefInput<$PrismaModel> | null
    in?: $Enums.Bank[] | ListEnumBankFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Bank[] | ListEnumBankFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBankNullableFilter<$PrismaModel> | $Enums.Bank | null
  }

  export type ExpenseCountOrderByAggregateInput = {
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    amount?: SortOrder
    group?: SortOrder
    image?: SortOrder
    note?: SortOrder
    desc?: SortOrder
    deleted?: SortOrder
    save?: SortOrder
    channel?: SortOrder
    code?: SortOrder
    businessAcc?: SortOrder
    memberId?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    businessAcc?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    amount?: SortOrder
    group?: SortOrder
    image?: SortOrder
    note?: SortOrder
    desc?: SortOrder
    deleted?: SortOrder
    save?: SortOrder
    channel?: SortOrder
    code?: SortOrder
    businessAcc?: SortOrder
    memberId?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    amount?: SortOrder
    group?: SortOrder
    image?: SortOrder
    note?: SortOrder
    desc?: SortOrder
    deleted?: SortOrder
    save?: SortOrder
    channel?: SortOrder
    code?: SortOrder
    businessAcc?: SortOrder
    memberId?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    businessAcc?: SortOrder
  }

  export type EnumBankNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Bank | EnumBankFieldRefInput<$PrismaModel> | null
    in?: $Enums.Bank[] | ListEnumBankFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Bank[] | ListEnumBankFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBankNullableWithAggregatesFilter<$PrismaModel> | $Enums.Bank | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBankNullableFilter<$PrismaModel>
    _max?: NestedEnumBankNullableFilter<$PrismaModel>
  }

  export type EnumSocialMediaFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialMedia | EnumSocialMediaFieldRefInput<$PrismaModel>
    in?: $Enums.SocialMedia[] | ListEnumSocialMediaFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialMedia[] | ListEnumSocialMediaFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialMediaFilter<$PrismaModel> | $Enums.SocialMedia
  }

  export type PlatformCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    accName?: SortOrder
    accId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessAcc?: SortOrder
    memberId?: SortOrder
    deleted?: SortOrder
  }

  export type PlatformAvgOrderByAggregateInput = {
    id?: SortOrder
    businessAcc?: SortOrder
  }

  export type PlatformMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    accName?: SortOrder
    accId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessAcc?: SortOrder
    memberId?: SortOrder
    deleted?: SortOrder
  }

  export type PlatformMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    accName?: SortOrder
    accId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessAcc?: SortOrder
    memberId?: SortOrder
    deleted?: SortOrder
  }

  export type PlatformSumOrderByAggregateInput = {
    id?: SortOrder
    businessAcc?: SortOrder
  }

  export type EnumSocialMediaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialMedia | EnumSocialMediaFieldRefInput<$PrismaModel>
    in?: $Enums.SocialMedia[] | ListEnumSocialMediaFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialMedia[] | ListEnumSocialMediaFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialMediaWithAggregatesFilter<$PrismaModel> | $Enums.SocialMedia
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialMediaFilter<$PrismaModel>
    _max?: NestedEnumSocialMediaFilter<$PrismaModel>
  }

  export type StoreCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    accName?: SortOrder
    accId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessAcc?: SortOrder
    memberId?: SortOrder
    deleted?: SortOrder
  }

  export type StoreAvgOrderByAggregateInput = {
    id?: SortOrder
    businessAcc?: SortOrder
  }

  export type StoreMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    accName?: SortOrder
    accId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessAcc?: SortOrder
    memberId?: SortOrder
    deleted?: SortOrder
  }

  export type StoreMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    accName?: SortOrder
    accId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessAcc?: SortOrder
    memberId?: SortOrder
    deleted?: SortOrder
  }

  export type StoreSumOrderByAggregateInput = {
    id?: SortOrder
    businessAcc?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    barcode?: SortOrder
    image?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    memberId?: SortOrder
    statusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
    businessAcc?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    statusId?: SortOrder
    businessAcc?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    barcode?: SortOrder
    image?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    memberId?: SortOrder
    statusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
    businessAcc?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    barcode?: SortOrder
    image?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    memberId?: SortOrder
    statusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
    businessAcc?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    statusId?: SortOrder
    businessAcc?: SortOrder
  }

  export type CreditCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    ownerId?: SortOrder
    creditorId?: SortOrder
  }

  export type CreditAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    creditorId?: SortOrder
  }

  export type CreditMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    ownerId?: SortOrder
    creditorId?: SortOrder
  }

  export type CreditMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    ownerId?: SortOrder
    creditorId?: SortOrder
  }

  export type CreditSumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    creditorId?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumMediaTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMediaTypeNullableFilter<$PrismaModel> | $Enums.MediaType | null
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hashtag?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    deleted?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    deleted?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    deleted?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
  }

  export type EnumMediaTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMediaTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.MediaType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeNullableFilter<$PrismaModel>
  }

  export type EnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type ReactionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type ReactionAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type ReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type ReactionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type ReactionSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type EnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    deleted?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    deleted?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    deleted?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type InboxCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    read?: SortOrder
    unsent?: SortOrder
    deleted?: SortOrder
  }

  export type InboxAvgOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type InboxMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    read?: SortOrder
    unsent?: SortOrder
    deleted?: SortOrder
  }

  export type InboxMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    read?: SortOrder
    unsent?: SortOrder
    deleted?: SortOrder
  }

  export type InboxSumOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type EnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type EnumCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryFilter<$PrismaModel> | $Enums.Category
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type OptionListRelationFilter = {
    every?: OptionWhereInput
    some?: OptionWhereInput
    none?: OptionWhereInput
  }

  export type OptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    productType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    deleted?: SortOrder
  }

  export type ShopAvgOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
  }

  export type ShopMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    productType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    deleted?: SortOrder
  }

  export type ShopMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    productType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    deleted?: SortOrder
  }

  export type ShopSumOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
  }

  export type EnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type EnumCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryWithAggregatesFilter<$PrismaModel> | $Enums.Category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryFilter<$PrismaModel>
    _max?: NestedEnumCategoryFilter<$PrismaModel>
  }

  export type ShopScalarRelationFilter = {
    is?: ShopWhereInput
    isNot?: ShopWhereInput
  }

  export type ReviewNullableScalarRelationFilter = {
    is?: ReviewWhereInput | null
    isNot?: ReviewWhereInput | null
  }

  export type CartScalarRelationFilter = {
    is?: CartWhereInput
    isNot?: CartWhereInput
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quantity?: SortOrder
    shopId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    deleted?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    shopId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quantity?: SortOrder
    shopId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    deleted?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quantity?: SortOrder
    shopId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    deleted?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    shopId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
  }

  export type EnumOptionNameFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionName | EnumOptionNameFieldRefInput<$PrismaModel>
    in?: $Enums.OptionName[] | ListEnumOptionNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.OptionName[] | ListEnumOptionNameFieldRefInput<$PrismaModel>
    not?: NestedEnumOptionNameFilter<$PrismaModel> | $Enums.OptionName
  }

  export type OptionValueListRelationFilter = {
    every?: OptionValueWhereInput
    some?: OptionValueWhereInput
    none?: OptionValueWhereInput
  }

  export type OptionValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OptionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    shopId?: SortOrder
  }

  export type OptionAvgOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type OptionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    shopId?: SortOrder
  }

  export type OptionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    shopId?: SortOrder
  }

  export type OptionSumOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type EnumOptionNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionName | EnumOptionNameFieldRefInput<$PrismaModel>
    in?: $Enums.OptionName[] | ListEnumOptionNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.OptionName[] | ListEnumOptionNameFieldRefInput<$PrismaModel>
    not?: NestedEnumOptionNameWithAggregatesFilter<$PrismaModel> | $Enums.OptionName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOptionNameFilter<$PrismaModel>
    _max?: NestedEnumOptionNameFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type OptionScalarRelationFilter = {
    is?: OptionWhereInput
    isNot?: OptionWhereInput
  }

  export type OptionValueCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    value?: SortOrder
    price?: SortOrder
    interest?: SortOrder
    duration?: SortOrder
    optionId?: SortOrder
  }

  export type OptionValueAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    interest?: SortOrder
    duration?: SortOrder
    optionId?: SortOrder
  }

  export type OptionValueMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    value?: SortOrder
    price?: SortOrder
    interest?: SortOrder
    duration?: SortOrder
    optionId?: SortOrder
  }

  export type OptionValueMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    value?: SortOrder
    price?: SortOrder
    interest?: SortOrder
    duration?: SortOrder
    optionId?: SortOrder
  }

  export type OptionValueSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    interest?: SortOrder
    duration?: SortOrder
    optionId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    shopId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    shopId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    shopId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    shopId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    shopId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
  }

  export type CartCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderId?: SortOrder
    payment?: SortOrder
    status?: SortOrder
    total?: SortOrder
  }

  export type CartAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    total?: SortOrder
  }

  export type CartMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderId?: SortOrder
    payment?: SortOrder
    status?: SortOrder
    total?: SortOrder
  }

  export type CartMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderId?: SortOrder
    payment?: SortOrder
    status?: SortOrder
    total?: SortOrder
  }

  export type CartSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    total?: SortOrder
  }

  export type BusinessAccCreateNestedManyWithoutUserInput = {
    create?: XOR<BusinessAccCreateWithoutUserInput, BusinessAccUncheckedCreateWithoutUserInput> | BusinessAccCreateWithoutUserInput[] | BusinessAccUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BusinessAccCreateOrConnectWithoutUserInput | BusinessAccCreateOrConnectWithoutUserInput[]
    createMany?: BusinessAccCreateManyUserInputEnvelope
    connect?: BusinessAccWhereUniqueInput | BusinessAccWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type InboxCreateNestedManyWithoutSenderInput = {
    create?: XOR<InboxCreateWithoutSenderInput, InboxUncheckedCreateWithoutSenderInput> | InboxCreateWithoutSenderInput[] | InboxUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: InboxCreateOrConnectWithoutSenderInput | InboxCreateOrConnectWithoutSenderInput[]
    createMany?: InboxCreateManySenderInputEnvelope
    connect?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
  }

  export type InboxCreateNestedManyWithoutReceiverInput = {
    create?: XOR<InboxCreateWithoutReceiverInput, InboxUncheckedCreateWithoutReceiverInput> | InboxCreateWithoutReceiverInput[] | InboxUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: InboxCreateOrConnectWithoutReceiverInput | InboxCreateOrConnectWithoutReceiverInput[]
    createMany?: InboxCreateManyReceiverInputEnvelope
    connect?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
  }

  export type ShopCreateNestedManyWithoutSellerInput = {
    create?: XOR<ShopCreateWithoutSellerInput, ShopUncheckedCreateWithoutSellerInput> | ShopCreateWithoutSellerInput[] | ShopUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutSellerInput | ShopCreateOrConnectWithoutSellerInput[]
    createMany?: ShopCreateManySellerInputEnvelope
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type ShopCreateNestedManyWithoutBuyerInput = {
    create?: XOR<ShopCreateWithoutBuyerInput, ShopUncheckedCreateWithoutBuyerInput> | ShopCreateWithoutBuyerInput[] | ShopUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutBuyerInput | ShopCreateOrConnectWithoutBuyerInput[]
    createMany?: ShopCreateManyBuyerInputEnvelope
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutBuyerInput = {
    create?: XOR<OrderCreateWithoutBuyerInput, OrderUncheckedCreateWithoutBuyerInput> | OrderCreateWithoutBuyerInput[] | OrderUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBuyerInput | OrderCreateOrConnectWithoutBuyerInput[]
    createMany?: OrderCreateManyBuyerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CreditCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CreditCreateWithoutOwnerInput, CreditUncheckedCreateWithoutOwnerInput> | CreditCreateWithoutOwnerInput[] | CreditUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CreditCreateOrConnectWithoutOwnerInput | CreditCreateOrConnectWithoutOwnerInput[]
    createMany?: CreditCreateManyOwnerInputEnvelope
    connect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
  }

  export type CreditCreateNestedManyWithoutCreditorInput = {
    create?: XOR<CreditCreateWithoutCreditorInput, CreditUncheckedCreateWithoutCreditorInput> | CreditCreateWithoutCreditorInput[] | CreditUncheckedCreateWithoutCreditorInput[]
    connectOrCreate?: CreditCreateOrConnectWithoutCreditorInput | CreditCreateOrConnectWithoutCreditorInput[]
    createMany?: CreditCreateManyCreditorInputEnvelope
    connect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
  }

  export type BusinessAccUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BusinessAccCreateWithoutUserInput, BusinessAccUncheckedCreateWithoutUserInput> | BusinessAccCreateWithoutUserInput[] | BusinessAccUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BusinessAccCreateOrConnectWithoutUserInput | BusinessAccCreateOrConnectWithoutUserInput[]
    createMany?: BusinessAccCreateManyUserInputEnvelope
    connect?: BusinessAccWhereUniqueInput | BusinessAccWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type InboxUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<InboxCreateWithoutSenderInput, InboxUncheckedCreateWithoutSenderInput> | InboxCreateWithoutSenderInput[] | InboxUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: InboxCreateOrConnectWithoutSenderInput | InboxCreateOrConnectWithoutSenderInput[]
    createMany?: InboxCreateManySenderInputEnvelope
    connect?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
  }

  export type InboxUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<InboxCreateWithoutReceiverInput, InboxUncheckedCreateWithoutReceiverInput> | InboxCreateWithoutReceiverInput[] | InboxUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: InboxCreateOrConnectWithoutReceiverInput | InboxCreateOrConnectWithoutReceiverInput[]
    createMany?: InboxCreateManyReceiverInputEnvelope
    connect?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
  }

  export type ShopUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<ShopCreateWithoutSellerInput, ShopUncheckedCreateWithoutSellerInput> | ShopCreateWithoutSellerInput[] | ShopUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutSellerInput | ShopCreateOrConnectWithoutSellerInput[]
    createMany?: ShopCreateManySellerInputEnvelope
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type ShopUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<ShopCreateWithoutBuyerInput, ShopUncheckedCreateWithoutBuyerInput> | ShopCreateWithoutBuyerInput[] | ShopUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutBuyerInput | ShopCreateOrConnectWithoutBuyerInput[]
    createMany?: ShopCreateManyBuyerInputEnvelope
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<OrderCreateWithoutBuyerInput, OrderUncheckedCreateWithoutBuyerInput> | OrderCreateWithoutBuyerInput[] | OrderUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBuyerInput | OrderCreateOrConnectWithoutBuyerInput[]
    createMany?: OrderCreateManyBuyerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CreditUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CreditCreateWithoutOwnerInput, CreditUncheckedCreateWithoutOwnerInput> | CreditCreateWithoutOwnerInput[] | CreditUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CreditCreateOrConnectWithoutOwnerInput | CreditCreateOrConnectWithoutOwnerInput[]
    createMany?: CreditCreateManyOwnerInputEnvelope
    connect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
  }

  export type CreditUncheckedCreateNestedManyWithoutCreditorInput = {
    create?: XOR<CreditCreateWithoutCreditorInput, CreditUncheckedCreateWithoutCreditorInput> | CreditCreateWithoutCreditorInput[] | CreditUncheckedCreateWithoutCreditorInput[]
    connectOrCreate?: CreditCreateOrConnectWithoutCreditorInput | CreditCreateOrConnectWithoutCreditorInput[]
    createMany?: CreditCreateManyCreditorInputEnvelope
    connect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BusinessAccUpdateManyWithoutUserNestedInput = {
    create?: XOR<BusinessAccCreateWithoutUserInput, BusinessAccUncheckedCreateWithoutUserInput> | BusinessAccCreateWithoutUserInput[] | BusinessAccUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BusinessAccCreateOrConnectWithoutUserInput | BusinessAccCreateOrConnectWithoutUserInput[]
    upsert?: BusinessAccUpsertWithWhereUniqueWithoutUserInput | BusinessAccUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BusinessAccCreateManyUserInputEnvelope
    set?: BusinessAccWhereUniqueInput | BusinessAccWhereUniqueInput[]
    disconnect?: BusinessAccWhereUniqueInput | BusinessAccWhereUniqueInput[]
    delete?: BusinessAccWhereUniqueInput | BusinessAccWhereUniqueInput[]
    connect?: BusinessAccWhereUniqueInput | BusinessAccWhereUniqueInput[]
    update?: BusinessAccUpdateWithWhereUniqueWithoutUserInput | BusinessAccUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BusinessAccUpdateManyWithWhereWithoutUserInput | BusinessAccUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BusinessAccScalarWhereInput | BusinessAccScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutUserInput | ReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutUserInput | ReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutUserInput | ReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type InboxUpdateManyWithoutSenderNestedInput = {
    create?: XOR<InboxCreateWithoutSenderInput, InboxUncheckedCreateWithoutSenderInput> | InboxCreateWithoutSenderInput[] | InboxUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: InboxCreateOrConnectWithoutSenderInput | InboxCreateOrConnectWithoutSenderInput[]
    upsert?: InboxUpsertWithWhereUniqueWithoutSenderInput | InboxUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: InboxCreateManySenderInputEnvelope
    set?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    disconnect?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    delete?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    connect?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    update?: InboxUpdateWithWhereUniqueWithoutSenderInput | InboxUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: InboxUpdateManyWithWhereWithoutSenderInput | InboxUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: InboxScalarWhereInput | InboxScalarWhereInput[]
  }

  export type InboxUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<InboxCreateWithoutReceiverInput, InboxUncheckedCreateWithoutReceiverInput> | InboxCreateWithoutReceiverInput[] | InboxUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: InboxCreateOrConnectWithoutReceiverInput | InboxCreateOrConnectWithoutReceiverInput[]
    upsert?: InboxUpsertWithWhereUniqueWithoutReceiverInput | InboxUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: InboxCreateManyReceiverInputEnvelope
    set?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    disconnect?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    delete?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    connect?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    update?: InboxUpdateWithWhereUniqueWithoutReceiverInput | InboxUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: InboxUpdateManyWithWhereWithoutReceiverInput | InboxUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: InboxScalarWhereInput | InboxScalarWhereInput[]
  }

  export type ShopUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ShopCreateWithoutSellerInput, ShopUncheckedCreateWithoutSellerInput> | ShopCreateWithoutSellerInput[] | ShopUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutSellerInput | ShopCreateOrConnectWithoutSellerInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutSellerInput | ShopUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ShopCreateManySellerInputEnvelope
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutSellerInput | ShopUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutSellerInput | ShopUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type ShopUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<ShopCreateWithoutBuyerInput, ShopUncheckedCreateWithoutBuyerInput> | ShopCreateWithoutBuyerInput[] | ShopUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutBuyerInput | ShopCreateOrConnectWithoutBuyerInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutBuyerInput | ShopUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: ShopCreateManyBuyerInputEnvelope
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutBuyerInput | ShopUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutBuyerInput | ShopUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<OrderCreateWithoutBuyerInput, OrderUncheckedCreateWithoutBuyerInput> | OrderCreateWithoutBuyerInput[] | OrderUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBuyerInput | OrderCreateOrConnectWithoutBuyerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutBuyerInput | OrderUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: OrderCreateManyBuyerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutBuyerInput | OrderUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutBuyerInput | OrderUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CreditUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CreditCreateWithoutOwnerInput, CreditUncheckedCreateWithoutOwnerInput> | CreditCreateWithoutOwnerInput[] | CreditUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CreditCreateOrConnectWithoutOwnerInput | CreditCreateOrConnectWithoutOwnerInput[]
    upsert?: CreditUpsertWithWhereUniqueWithoutOwnerInput | CreditUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CreditCreateManyOwnerInputEnvelope
    set?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    disconnect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    delete?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    connect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    update?: CreditUpdateWithWhereUniqueWithoutOwnerInput | CreditUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CreditUpdateManyWithWhereWithoutOwnerInput | CreditUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CreditScalarWhereInput | CreditScalarWhereInput[]
  }

  export type CreditUpdateManyWithoutCreditorNestedInput = {
    create?: XOR<CreditCreateWithoutCreditorInput, CreditUncheckedCreateWithoutCreditorInput> | CreditCreateWithoutCreditorInput[] | CreditUncheckedCreateWithoutCreditorInput[]
    connectOrCreate?: CreditCreateOrConnectWithoutCreditorInput | CreditCreateOrConnectWithoutCreditorInput[]
    upsert?: CreditUpsertWithWhereUniqueWithoutCreditorInput | CreditUpsertWithWhereUniqueWithoutCreditorInput[]
    createMany?: CreditCreateManyCreditorInputEnvelope
    set?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    disconnect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    delete?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    connect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    update?: CreditUpdateWithWhereUniqueWithoutCreditorInput | CreditUpdateWithWhereUniqueWithoutCreditorInput[]
    updateMany?: CreditUpdateManyWithWhereWithoutCreditorInput | CreditUpdateManyWithWhereWithoutCreditorInput[]
    deleteMany?: CreditScalarWhereInput | CreditScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BusinessAccUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BusinessAccCreateWithoutUserInput, BusinessAccUncheckedCreateWithoutUserInput> | BusinessAccCreateWithoutUserInput[] | BusinessAccUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BusinessAccCreateOrConnectWithoutUserInput | BusinessAccCreateOrConnectWithoutUserInput[]
    upsert?: BusinessAccUpsertWithWhereUniqueWithoutUserInput | BusinessAccUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BusinessAccCreateManyUserInputEnvelope
    set?: BusinessAccWhereUniqueInput | BusinessAccWhereUniqueInput[]
    disconnect?: BusinessAccWhereUniqueInput | BusinessAccWhereUniqueInput[]
    delete?: BusinessAccWhereUniqueInput | BusinessAccWhereUniqueInput[]
    connect?: BusinessAccWhereUniqueInput | BusinessAccWhereUniqueInput[]
    update?: BusinessAccUpdateWithWhereUniqueWithoutUserInput | BusinessAccUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BusinessAccUpdateManyWithWhereWithoutUserInput | BusinessAccUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BusinessAccScalarWhereInput | BusinessAccScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutUserInput | ReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutUserInput | ReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutUserInput | ReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type InboxUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<InboxCreateWithoutSenderInput, InboxUncheckedCreateWithoutSenderInput> | InboxCreateWithoutSenderInput[] | InboxUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: InboxCreateOrConnectWithoutSenderInput | InboxCreateOrConnectWithoutSenderInput[]
    upsert?: InboxUpsertWithWhereUniqueWithoutSenderInput | InboxUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: InboxCreateManySenderInputEnvelope
    set?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    disconnect?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    delete?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    connect?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    update?: InboxUpdateWithWhereUniqueWithoutSenderInput | InboxUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: InboxUpdateManyWithWhereWithoutSenderInput | InboxUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: InboxScalarWhereInput | InboxScalarWhereInput[]
  }

  export type InboxUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<InboxCreateWithoutReceiverInput, InboxUncheckedCreateWithoutReceiverInput> | InboxCreateWithoutReceiverInput[] | InboxUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: InboxCreateOrConnectWithoutReceiverInput | InboxCreateOrConnectWithoutReceiverInput[]
    upsert?: InboxUpsertWithWhereUniqueWithoutReceiverInput | InboxUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: InboxCreateManyReceiverInputEnvelope
    set?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    disconnect?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    delete?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    connect?: InboxWhereUniqueInput | InboxWhereUniqueInput[]
    update?: InboxUpdateWithWhereUniqueWithoutReceiverInput | InboxUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: InboxUpdateManyWithWhereWithoutReceiverInput | InboxUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: InboxScalarWhereInput | InboxScalarWhereInput[]
  }

  export type ShopUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ShopCreateWithoutSellerInput, ShopUncheckedCreateWithoutSellerInput> | ShopCreateWithoutSellerInput[] | ShopUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutSellerInput | ShopCreateOrConnectWithoutSellerInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutSellerInput | ShopUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ShopCreateManySellerInputEnvelope
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutSellerInput | ShopUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutSellerInput | ShopUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type ShopUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<ShopCreateWithoutBuyerInput, ShopUncheckedCreateWithoutBuyerInput> | ShopCreateWithoutBuyerInput[] | ShopUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutBuyerInput | ShopCreateOrConnectWithoutBuyerInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutBuyerInput | ShopUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: ShopCreateManyBuyerInputEnvelope
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutBuyerInput | ShopUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutBuyerInput | ShopUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<OrderCreateWithoutBuyerInput, OrderUncheckedCreateWithoutBuyerInput> | OrderCreateWithoutBuyerInput[] | OrderUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBuyerInput | OrderCreateOrConnectWithoutBuyerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutBuyerInput | OrderUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: OrderCreateManyBuyerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutBuyerInput | OrderUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutBuyerInput | OrderUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CreditUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CreditCreateWithoutOwnerInput, CreditUncheckedCreateWithoutOwnerInput> | CreditCreateWithoutOwnerInput[] | CreditUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CreditCreateOrConnectWithoutOwnerInput | CreditCreateOrConnectWithoutOwnerInput[]
    upsert?: CreditUpsertWithWhereUniqueWithoutOwnerInput | CreditUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CreditCreateManyOwnerInputEnvelope
    set?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    disconnect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    delete?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    connect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    update?: CreditUpdateWithWhereUniqueWithoutOwnerInput | CreditUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CreditUpdateManyWithWhereWithoutOwnerInput | CreditUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CreditScalarWhereInput | CreditScalarWhereInput[]
  }

  export type CreditUncheckedUpdateManyWithoutCreditorNestedInput = {
    create?: XOR<CreditCreateWithoutCreditorInput, CreditUncheckedCreateWithoutCreditorInput> | CreditCreateWithoutCreditorInput[] | CreditUncheckedCreateWithoutCreditorInput[]
    connectOrCreate?: CreditCreateOrConnectWithoutCreditorInput | CreditCreateOrConnectWithoutCreditorInput[]
    upsert?: CreditUpsertWithWhereUniqueWithoutCreditorInput | CreditUpsertWithWhereUniqueWithoutCreditorInput[]
    createMany?: CreditCreateManyCreditorInputEnvelope
    set?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    disconnect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    delete?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    connect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    update?: CreditUpdateWithWhereUniqueWithoutCreditorInput | CreditUpdateWithWhereUniqueWithoutCreditorInput[]
    updateMany?: CreditUpdateManyWithWhereWithoutCreditorInput | CreditUpdateManyWithWhereWithoutCreditorInput[]
    deleteMany?: CreditScalarWhereInput | CreditScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMemberInput = {
    create?: XOR<UserCreateWithoutMemberInput, UserUncheckedCreateWithoutMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberInput
    connect?: UserWhereUniqueInput
  }

  export type BusinessAccCreateNestedOneWithoutAllMemberInput = {
    create?: XOR<BusinessAccCreateWithoutAllMemberInput, BusinessAccUncheckedCreateWithoutAllMemberInput>
    connectOrCreate?: BusinessAccCreateOrConnectWithoutAllMemberInput
    connect?: BusinessAccWhereUniqueInput
  }

  export type BillCreateNestedManyWithoutMemberInput = {
    create?: XOR<BillCreateWithoutMemberInput, BillUncheckedCreateWithoutMemberInput> | BillCreateWithoutMemberInput[] | BillUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BillCreateOrConnectWithoutMemberInput | BillCreateOrConnectWithoutMemberInput[]
    createMany?: BillCreateManyMemberInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type AdsCostCreateNestedManyWithoutMemberInput = {
    create?: XOR<AdsCostCreateWithoutMemberInput, AdsCostUncheckedCreateWithoutMemberInput> | AdsCostCreateWithoutMemberInput[] | AdsCostUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutMemberInput | AdsCostCreateOrConnectWithoutMemberInput[]
    createMany?: AdsCostCreateManyMemberInputEnvelope
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutMemberInput = {
    create?: XOR<ExpenseCreateWithoutMemberInput, ExpenseUncheckedCreateWithoutMemberInput> | ExpenseCreateWithoutMemberInput[] | ExpenseUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutMemberInput | ExpenseCreateOrConnectWithoutMemberInput[]
    createMany?: ExpenseCreateManyMemberInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutMemberInput = {
    create?: XOR<ProductCreateWithoutMemberInput, ProductUncheckedCreateWithoutMemberInput> | ProductCreateWithoutMemberInput[] | ProductUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutMemberInput | ProductCreateOrConnectWithoutMemberInput[]
    createMany?: ProductCreateManyMemberInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PlatformCreateNestedManyWithoutMemberInput = {
    create?: XOR<PlatformCreateWithoutMemberInput, PlatformUncheckedCreateWithoutMemberInput> | PlatformCreateWithoutMemberInput[] | PlatformUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: PlatformCreateOrConnectWithoutMemberInput | PlatformCreateOrConnectWithoutMemberInput[]
    createMany?: PlatformCreateManyMemberInputEnvelope
    connect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
  }

  export type StoreCreateNestedManyWithoutMemberInput = {
    create?: XOR<StoreCreateWithoutMemberInput, StoreUncheckedCreateWithoutMemberInput> | StoreCreateWithoutMemberInput[] | StoreUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutMemberInput | StoreCreateOrConnectWithoutMemberInput[]
    createMany?: StoreCreateManyMemberInputEnvelope
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
  }

  export type BillUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<BillCreateWithoutMemberInput, BillUncheckedCreateWithoutMemberInput> | BillCreateWithoutMemberInput[] | BillUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BillCreateOrConnectWithoutMemberInput | BillCreateOrConnectWithoutMemberInput[]
    createMany?: BillCreateManyMemberInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type AdsCostUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<AdsCostCreateWithoutMemberInput, AdsCostUncheckedCreateWithoutMemberInput> | AdsCostCreateWithoutMemberInput[] | AdsCostUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutMemberInput | AdsCostCreateOrConnectWithoutMemberInput[]
    createMany?: AdsCostCreateManyMemberInputEnvelope
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<ExpenseCreateWithoutMemberInput, ExpenseUncheckedCreateWithoutMemberInput> | ExpenseCreateWithoutMemberInput[] | ExpenseUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutMemberInput | ExpenseCreateOrConnectWithoutMemberInput[]
    createMany?: ExpenseCreateManyMemberInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<ProductCreateWithoutMemberInput, ProductUncheckedCreateWithoutMemberInput> | ProductCreateWithoutMemberInput[] | ProductUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutMemberInput | ProductCreateOrConnectWithoutMemberInput[]
    createMany?: ProductCreateManyMemberInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PlatformUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<PlatformCreateWithoutMemberInput, PlatformUncheckedCreateWithoutMemberInput> | PlatformCreateWithoutMemberInput[] | PlatformUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: PlatformCreateOrConnectWithoutMemberInput | PlatformCreateOrConnectWithoutMemberInput[]
    createMany?: PlatformCreateManyMemberInputEnvelope
    connect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
  }

  export type StoreUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<StoreCreateWithoutMemberInput, StoreUncheckedCreateWithoutMemberInput> | StoreCreateWithoutMemberInput[] | StoreUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutMemberInput | StoreCreateOrConnectWithoutMemberInput[]
    createMany?: StoreCreateManyMemberInputEnvelope
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type UserUpdateOneRequiredWithoutMemberNestedInput = {
    create?: XOR<UserCreateWithoutMemberInput, UserUncheckedCreateWithoutMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberInput
    upsert?: UserUpsertWithoutMemberInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMemberInput, UserUpdateWithoutMemberInput>, UserUncheckedUpdateWithoutMemberInput>
  }

  export type BusinessAccUpdateOneWithoutAllMemberNestedInput = {
    create?: XOR<BusinessAccCreateWithoutAllMemberInput, BusinessAccUncheckedCreateWithoutAllMemberInput>
    connectOrCreate?: BusinessAccCreateOrConnectWithoutAllMemberInput
    upsert?: BusinessAccUpsertWithoutAllMemberInput
    disconnect?: BusinessAccWhereInput | boolean
    delete?: BusinessAccWhereInput | boolean
    connect?: BusinessAccWhereUniqueInput
    update?: XOR<XOR<BusinessAccUpdateToOneWithWhereWithoutAllMemberInput, BusinessAccUpdateWithoutAllMemberInput>, BusinessAccUncheckedUpdateWithoutAllMemberInput>
  }

  export type BillUpdateManyWithoutMemberNestedInput = {
    create?: XOR<BillCreateWithoutMemberInput, BillUncheckedCreateWithoutMemberInput> | BillCreateWithoutMemberInput[] | BillUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BillCreateOrConnectWithoutMemberInput | BillCreateOrConnectWithoutMemberInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutMemberInput | BillUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: BillCreateManyMemberInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutMemberInput | BillUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: BillUpdateManyWithWhereWithoutMemberInput | BillUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type AdsCostUpdateManyWithoutMemberNestedInput = {
    create?: XOR<AdsCostCreateWithoutMemberInput, AdsCostUncheckedCreateWithoutMemberInput> | AdsCostCreateWithoutMemberInput[] | AdsCostUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutMemberInput | AdsCostCreateOrConnectWithoutMemberInput[]
    upsert?: AdsCostUpsertWithWhereUniqueWithoutMemberInput | AdsCostUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: AdsCostCreateManyMemberInputEnvelope
    set?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    disconnect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    delete?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    update?: AdsCostUpdateWithWhereUniqueWithoutMemberInput | AdsCostUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: AdsCostUpdateManyWithWhereWithoutMemberInput | AdsCostUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: AdsCostScalarWhereInput | AdsCostScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutMemberNestedInput = {
    create?: XOR<ExpenseCreateWithoutMemberInput, ExpenseUncheckedCreateWithoutMemberInput> | ExpenseCreateWithoutMemberInput[] | ExpenseUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutMemberInput | ExpenseCreateOrConnectWithoutMemberInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutMemberInput | ExpenseUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: ExpenseCreateManyMemberInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutMemberInput | ExpenseUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutMemberInput | ExpenseUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutMemberNestedInput = {
    create?: XOR<ProductCreateWithoutMemberInput, ProductUncheckedCreateWithoutMemberInput> | ProductCreateWithoutMemberInput[] | ProductUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutMemberInput | ProductCreateOrConnectWithoutMemberInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutMemberInput | ProductUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: ProductCreateManyMemberInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutMemberInput | ProductUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutMemberInput | ProductUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PlatformUpdateManyWithoutMemberNestedInput = {
    create?: XOR<PlatformCreateWithoutMemberInput, PlatformUncheckedCreateWithoutMemberInput> | PlatformCreateWithoutMemberInput[] | PlatformUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: PlatformCreateOrConnectWithoutMemberInput | PlatformCreateOrConnectWithoutMemberInput[]
    upsert?: PlatformUpsertWithWhereUniqueWithoutMemberInput | PlatformUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: PlatformCreateManyMemberInputEnvelope
    set?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    disconnect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    delete?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    connect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    update?: PlatformUpdateWithWhereUniqueWithoutMemberInput | PlatformUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: PlatformUpdateManyWithWhereWithoutMemberInput | PlatformUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: PlatformScalarWhereInput | PlatformScalarWhereInput[]
  }

  export type StoreUpdateManyWithoutMemberNestedInput = {
    create?: XOR<StoreCreateWithoutMemberInput, StoreUncheckedCreateWithoutMemberInput> | StoreCreateWithoutMemberInput[] | StoreUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutMemberInput | StoreCreateOrConnectWithoutMemberInput[]
    upsert?: StoreUpsertWithWhereUniqueWithoutMemberInput | StoreUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: StoreCreateManyMemberInputEnvelope
    set?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    disconnect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    delete?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    update?: StoreUpdateWithWhereUniqueWithoutMemberInput | StoreUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: StoreUpdateManyWithWhereWithoutMemberInput | StoreUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: StoreScalarWhereInput | StoreScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BillUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<BillCreateWithoutMemberInput, BillUncheckedCreateWithoutMemberInput> | BillCreateWithoutMemberInput[] | BillUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BillCreateOrConnectWithoutMemberInput | BillCreateOrConnectWithoutMemberInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutMemberInput | BillUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: BillCreateManyMemberInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutMemberInput | BillUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: BillUpdateManyWithWhereWithoutMemberInput | BillUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type AdsCostUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<AdsCostCreateWithoutMemberInput, AdsCostUncheckedCreateWithoutMemberInput> | AdsCostCreateWithoutMemberInput[] | AdsCostUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutMemberInput | AdsCostCreateOrConnectWithoutMemberInput[]
    upsert?: AdsCostUpsertWithWhereUniqueWithoutMemberInput | AdsCostUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: AdsCostCreateManyMemberInputEnvelope
    set?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    disconnect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    delete?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    update?: AdsCostUpdateWithWhereUniqueWithoutMemberInput | AdsCostUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: AdsCostUpdateManyWithWhereWithoutMemberInput | AdsCostUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: AdsCostScalarWhereInput | AdsCostScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<ExpenseCreateWithoutMemberInput, ExpenseUncheckedCreateWithoutMemberInput> | ExpenseCreateWithoutMemberInput[] | ExpenseUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutMemberInput | ExpenseCreateOrConnectWithoutMemberInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutMemberInput | ExpenseUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: ExpenseCreateManyMemberInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutMemberInput | ExpenseUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutMemberInput | ExpenseUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<ProductCreateWithoutMemberInput, ProductUncheckedCreateWithoutMemberInput> | ProductCreateWithoutMemberInput[] | ProductUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutMemberInput | ProductCreateOrConnectWithoutMemberInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutMemberInput | ProductUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: ProductCreateManyMemberInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutMemberInput | ProductUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutMemberInput | ProductUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PlatformUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<PlatformCreateWithoutMemberInput, PlatformUncheckedCreateWithoutMemberInput> | PlatformCreateWithoutMemberInput[] | PlatformUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: PlatformCreateOrConnectWithoutMemberInput | PlatformCreateOrConnectWithoutMemberInput[]
    upsert?: PlatformUpsertWithWhereUniqueWithoutMemberInput | PlatformUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: PlatformCreateManyMemberInputEnvelope
    set?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    disconnect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    delete?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    connect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    update?: PlatformUpdateWithWhereUniqueWithoutMemberInput | PlatformUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: PlatformUpdateManyWithWhereWithoutMemberInput | PlatformUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: PlatformScalarWhereInput | PlatformScalarWhereInput[]
  }

  export type StoreUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<StoreCreateWithoutMemberInput, StoreUncheckedCreateWithoutMemberInput> | StoreCreateWithoutMemberInput[] | StoreUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutMemberInput | StoreCreateOrConnectWithoutMemberInput[]
    upsert?: StoreUpsertWithWhereUniqueWithoutMemberInput | StoreUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: StoreCreateManyMemberInputEnvelope
    set?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    disconnect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    delete?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    update?: StoreUpdateWithWhereUniqueWithoutMemberInput | StoreUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: StoreUpdateManyWithWhereWithoutMemberInput | StoreUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: StoreScalarWhereInput | StoreScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBusinessInput = {
    create?: XOR<UserCreateWithoutBusinessInput, UserUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: UserCreateOrConnectWithoutBusinessInput
    connect?: UserWhereUniqueInput
  }

  export type MemberCreateNestedManyWithoutBusinessInput = {
    create?: XOR<MemberCreateWithoutBusinessInput, MemberUncheckedCreateWithoutBusinessInput> | MemberCreateWithoutBusinessInput[] | MemberUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutBusinessInput | MemberCreateOrConnectWithoutBusinessInput[]
    createMany?: MemberCreateManyBusinessInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type BillCreateNestedManyWithoutBusinessIdInput = {
    create?: XOR<BillCreateWithoutBusinessIdInput, BillUncheckedCreateWithoutBusinessIdInput> | BillCreateWithoutBusinessIdInput[] | BillUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: BillCreateOrConnectWithoutBusinessIdInput | BillCreateOrConnectWithoutBusinessIdInput[]
    createMany?: BillCreateManyBusinessIdInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutBusinessIdInput = {
    create?: XOR<ExpenseCreateWithoutBusinessIdInput, ExpenseUncheckedCreateWithoutBusinessIdInput> | ExpenseCreateWithoutBusinessIdInput[] | ExpenseUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBusinessIdInput | ExpenseCreateOrConnectWithoutBusinessIdInput[]
    createMany?: ExpenseCreateManyBusinessIdInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type AdsCostCreateNestedManyWithoutBusinessIdInput = {
    create?: XOR<AdsCostCreateWithoutBusinessIdInput, AdsCostUncheckedCreateWithoutBusinessIdInput> | AdsCostCreateWithoutBusinessIdInput[] | AdsCostUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutBusinessIdInput | AdsCostCreateOrConnectWithoutBusinessIdInput[]
    createMany?: AdsCostCreateManyBusinessIdInputEnvelope
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
  }

  export type PlatformCreateNestedManyWithoutBusinessIdInput = {
    create?: XOR<PlatformCreateWithoutBusinessIdInput, PlatformUncheckedCreateWithoutBusinessIdInput> | PlatformCreateWithoutBusinessIdInput[] | PlatformUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: PlatformCreateOrConnectWithoutBusinessIdInput | PlatformCreateOrConnectWithoutBusinessIdInput[]
    createMany?: PlatformCreateManyBusinessIdInputEnvelope
    connect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
  }

  export type StoreCreateNestedManyWithoutBusinessIdInput = {
    create?: XOR<StoreCreateWithoutBusinessIdInput, StoreUncheckedCreateWithoutBusinessIdInput> | StoreCreateWithoutBusinessIdInput[] | StoreUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutBusinessIdInput | StoreCreateOrConnectWithoutBusinessIdInput[]
    createMany?: StoreCreateManyBusinessIdInputEnvelope
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutBusinessIdInput = {
    create?: XOR<ProductCreateWithoutBusinessIdInput, ProductUncheckedCreateWithoutBusinessIdInput> | ProductCreateWithoutBusinessIdInput[] | ProductUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBusinessIdInput | ProductCreateOrConnectWithoutBusinessIdInput[]
    createMany?: ProductCreateManyBusinessIdInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<MemberCreateWithoutBusinessInput, MemberUncheckedCreateWithoutBusinessInput> | MemberCreateWithoutBusinessInput[] | MemberUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutBusinessInput | MemberCreateOrConnectWithoutBusinessInput[]
    createMany?: MemberCreateManyBusinessInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type BillUncheckedCreateNestedManyWithoutBusinessIdInput = {
    create?: XOR<BillCreateWithoutBusinessIdInput, BillUncheckedCreateWithoutBusinessIdInput> | BillCreateWithoutBusinessIdInput[] | BillUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: BillCreateOrConnectWithoutBusinessIdInput | BillCreateOrConnectWithoutBusinessIdInput[]
    createMany?: BillCreateManyBusinessIdInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutBusinessIdInput = {
    create?: XOR<ExpenseCreateWithoutBusinessIdInput, ExpenseUncheckedCreateWithoutBusinessIdInput> | ExpenseCreateWithoutBusinessIdInput[] | ExpenseUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBusinessIdInput | ExpenseCreateOrConnectWithoutBusinessIdInput[]
    createMany?: ExpenseCreateManyBusinessIdInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type AdsCostUncheckedCreateNestedManyWithoutBusinessIdInput = {
    create?: XOR<AdsCostCreateWithoutBusinessIdInput, AdsCostUncheckedCreateWithoutBusinessIdInput> | AdsCostCreateWithoutBusinessIdInput[] | AdsCostUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutBusinessIdInput | AdsCostCreateOrConnectWithoutBusinessIdInput[]
    createMany?: AdsCostCreateManyBusinessIdInputEnvelope
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
  }

  export type PlatformUncheckedCreateNestedManyWithoutBusinessIdInput = {
    create?: XOR<PlatformCreateWithoutBusinessIdInput, PlatformUncheckedCreateWithoutBusinessIdInput> | PlatformCreateWithoutBusinessIdInput[] | PlatformUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: PlatformCreateOrConnectWithoutBusinessIdInput | PlatformCreateOrConnectWithoutBusinessIdInput[]
    createMany?: PlatformCreateManyBusinessIdInputEnvelope
    connect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
  }

  export type StoreUncheckedCreateNestedManyWithoutBusinessIdInput = {
    create?: XOR<StoreCreateWithoutBusinessIdInput, StoreUncheckedCreateWithoutBusinessIdInput> | StoreCreateWithoutBusinessIdInput[] | StoreUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutBusinessIdInput | StoreCreateOrConnectWithoutBusinessIdInput[]
    createMany?: StoreCreateManyBusinessIdInputEnvelope
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBusinessIdInput = {
    create?: XOR<ProductCreateWithoutBusinessIdInput, ProductUncheckedCreateWithoutBusinessIdInput> | ProductCreateWithoutBusinessIdInput[] | ProductUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBusinessIdInput | ProductCreateOrConnectWithoutBusinessIdInput[]
    createMany?: ProductCreateManyBusinessIdInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumBusinessTypeFieldUpdateOperationsInput = {
    set?: $Enums.BusinessType
  }

  export type EnumtaxTypeFieldUpdateOperationsInput = {
    set?: $Enums.taxType
  }

  export type UserUpdateOneRequiredWithoutBusinessNestedInput = {
    create?: XOR<UserCreateWithoutBusinessInput, UserUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: UserCreateOrConnectWithoutBusinessInput
    upsert?: UserUpsertWithoutBusinessInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBusinessInput, UserUpdateWithoutBusinessInput>, UserUncheckedUpdateWithoutBusinessInput>
  }

  export type MemberUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<MemberCreateWithoutBusinessInput, MemberUncheckedCreateWithoutBusinessInput> | MemberCreateWithoutBusinessInput[] | MemberUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutBusinessInput | MemberCreateOrConnectWithoutBusinessInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutBusinessInput | MemberUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: MemberCreateManyBusinessInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutBusinessInput | MemberUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutBusinessInput | MemberUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type BillUpdateManyWithoutBusinessIdNestedInput = {
    create?: XOR<BillCreateWithoutBusinessIdInput, BillUncheckedCreateWithoutBusinessIdInput> | BillCreateWithoutBusinessIdInput[] | BillUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: BillCreateOrConnectWithoutBusinessIdInput | BillCreateOrConnectWithoutBusinessIdInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutBusinessIdInput | BillUpsertWithWhereUniqueWithoutBusinessIdInput[]
    createMany?: BillCreateManyBusinessIdInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutBusinessIdInput | BillUpdateWithWhereUniqueWithoutBusinessIdInput[]
    updateMany?: BillUpdateManyWithWhereWithoutBusinessIdInput | BillUpdateManyWithWhereWithoutBusinessIdInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutBusinessIdNestedInput = {
    create?: XOR<ExpenseCreateWithoutBusinessIdInput, ExpenseUncheckedCreateWithoutBusinessIdInput> | ExpenseCreateWithoutBusinessIdInput[] | ExpenseUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBusinessIdInput | ExpenseCreateOrConnectWithoutBusinessIdInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutBusinessIdInput | ExpenseUpsertWithWhereUniqueWithoutBusinessIdInput[]
    createMany?: ExpenseCreateManyBusinessIdInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutBusinessIdInput | ExpenseUpdateWithWhereUniqueWithoutBusinessIdInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutBusinessIdInput | ExpenseUpdateManyWithWhereWithoutBusinessIdInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type AdsCostUpdateManyWithoutBusinessIdNestedInput = {
    create?: XOR<AdsCostCreateWithoutBusinessIdInput, AdsCostUncheckedCreateWithoutBusinessIdInput> | AdsCostCreateWithoutBusinessIdInput[] | AdsCostUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutBusinessIdInput | AdsCostCreateOrConnectWithoutBusinessIdInput[]
    upsert?: AdsCostUpsertWithWhereUniqueWithoutBusinessIdInput | AdsCostUpsertWithWhereUniqueWithoutBusinessIdInput[]
    createMany?: AdsCostCreateManyBusinessIdInputEnvelope
    set?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    disconnect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    delete?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    update?: AdsCostUpdateWithWhereUniqueWithoutBusinessIdInput | AdsCostUpdateWithWhereUniqueWithoutBusinessIdInput[]
    updateMany?: AdsCostUpdateManyWithWhereWithoutBusinessIdInput | AdsCostUpdateManyWithWhereWithoutBusinessIdInput[]
    deleteMany?: AdsCostScalarWhereInput | AdsCostScalarWhereInput[]
  }

  export type PlatformUpdateManyWithoutBusinessIdNestedInput = {
    create?: XOR<PlatformCreateWithoutBusinessIdInput, PlatformUncheckedCreateWithoutBusinessIdInput> | PlatformCreateWithoutBusinessIdInput[] | PlatformUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: PlatformCreateOrConnectWithoutBusinessIdInput | PlatformCreateOrConnectWithoutBusinessIdInput[]
    upsert?: PlatformUpsertWithWhereUniqueWithoutBusinessIdInput | PlatformUpsertWithWhereUniqueWithoutBusinessIdInput[]
    createMany?: PlatformCreateManyBusinessIdInputEnvelope
    set?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    disconnect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    delete?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    connect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    update?: PlatformUpdateWithWhereUniqueWithoutBusinessIdInput | PlatformUpdateWithWhereUniqueWithoutBusinessIdInput[]
    updateMany?: PlatformUpdateManyWithWhereWithoutBusinessIdInput | PlatformUpdateManyWithWhereWithoutBusinessIdInput[]
    deleteMany?: PlatformScalarWhereInput | PlatformScalarWhereInput[]
  }

  export type StoreUpdateManyWithoutBusinessIdNestedInput = {
    create?: XOR<StoreCreateWithoutBusinessIdInput, StoreUncheckedCreateWithoutBusinessIdInput> | StoreCreateWithoutBusinessIdInput[] | StoreUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutBusinessIdInput | StoreCreateOrConnectWithoutBusinessIdInput[]
    upsert?: StoreUpsertWithWhereUniqueWithoutBusinessIdInput | StoreUpsertWithWhereUniqueWithoutBusinessIdInput[]
    createMany?: StoreCreateManyBusinessIdInputEnvelope
    set?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    disconnect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    delete?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    update?: StoreUpdateWithWhereUniqueWithoutBusinessIdInput | StoreUpdateWithWhereUniqueWithoutBusinessIdInput[]
    updateMany?: StoreUpdateManyWithWhereWithoutBusinessIdInput | StoreUpdateManyWithWhereWithoutBusinessIdInput[]
    deleteMany?: StoreScalarWhereInput | StoreScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutBusinessIdNestedInput = {
    create?: XOR<ProductCreateWithoutBusinessIdInput, ProductUncheckedCreateWithoutBusinessIdInput> | ProductCreateWithoutBusinessIdInput[] | ProductUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBusinessIdInput | ProductCreateOrConnectWithoutBusinessIdInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBusinessIdInput | ProductUpsertWithWhereUniqueWithoutBusinessIdInput[]
    createMany?: ProductCreateManyBusinessIdInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBusinessIdInput | ProductUpdateWithWhereUniqueWithoutBusinessIdInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBusinessIdInput | ProductUpdateManyWithWhereWithoutBusinessIdInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<MemberCreateWithoutBusinessInput, MemberUncheckedCreateWithoutBusinessInput> | MemberCreateWithoutBusinessInput[] | MemberUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutBusinessInput | MemberCreateOrConnectWithoutBusinessInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutBusinessInput | MemberUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: MemberCreateManyBusinessInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutBusinessInput | MemberUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutBusinessInput | MemberUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type BillUncheckedUpdateManyWithoutBusinessIdNestedInput = {
    create?: XOR<BillCreateWithoutBusinessIdInput, BillUncheckedCreateWithoutBusinessIdInput> | BillCreateWithoutBusinessIdInput[] | BillUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: BillCreateOrConnectWithoutBusinessIdInput | BillCreateOrConnectWithoutBusinessIdInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutBusinessIdInput | BillUpsertWithWhereUniqueWithoutBusinessIdInput[]
    createMany?: BillCreateManyBusinessIdInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutBusinessIdInput | BillUpdateWithWhereUniqueWithoutBusinessIdInput[]
    updateMany?: BillUpdateManyWithWhereWithoutBusinessIdInput | BillUpdateManyWithWhereWithoutBusinessIdInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutBusinessIdNestedInput = {
    create?: XOR<ExpenseCreateWithoutBusinessIdInput, ExpenseUncheckedCreateWithoutBusinessIdInput> | ExpenseCreateWithoutBusinessIdInput[] | ExpenseUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBusinessIdInput | ExpenseCreateOrConnectWithoutBusinessIdInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutBusinessIdInput | ExpenseUpsertWithWhereUniqueWithoutBusinessIdInput[]
    createMany?: ExpenseCreateManyBusinessIdInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutBusinessIdInput | ExpenseUpdateWithWhereUniqueWithoutBusinessIdInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutBusinessIdInput | ExpenseUpdateManyWithWhereWithoutBusinessIdInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type AdsCostUncheckedUpdateManyWithoutBusinessIdNestedInput = {
    create?: XOR<AdsCostCreateWithoutBusinessIdInput, AdsCostUncheckedCreateWithoutBusinessIdInput> | AdsCostCreateWithoutBusinessIdInput[] | AdsCostUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutBusinessIdInput | AdsCostCreateOrConnectWithoutBusinessIdInput[]
    upsert?: AdsCostUpsertWithWhereUniqueWithoutBusinessIdInput | AdsCostUpsertWithWhereUniqueWithoutBusinessIdInput[]
    createMany?: AdsCostCreateManyBusinessIdInputEnvelope
    set?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    disconnect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    delete?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    update?: AdsCostUpdateWithWhereUniqueWithoutBusinessIdInput | AdsCostUpdateWithWhereUniqueWithoutBusinessIdInput[]
    updateMany?: AdsCostUpdateManyWithWhereWithoutBusinessIdInput | AdsCostUpdateManyWithWhereWithoutBusinessIdInput[]
    deleteMany?: AdsCostScalarWhereInput | AdsCostScalarWhereInput[]
  }

  export type PlatformUncheckedUpdateManyWithoutBusinessIdNestedInput = {
    create?: XOR<PlatformCreateWithoutBusinessIdInput, PlatformUncheckedCreateWithoutBusinessIdInput> | PlatformCreateWithoutBusinessIdInput[] | PlatformUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: PlatformCreateOrConnectWithoutBusinessIdInput | PlatformCreateOrConnectWithoutBusinessIdInput[]
    upsert?: PlatformUpsertWithWhereUniqueWithoutBusinessIdInput | PlatformUpsertWithWhereUniqueWithoutBusinessIdInput[]
    createMany?: PlatformCreateManyBusinessIdInputEnvelope
    set?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    disconnect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    delete?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    connect?: PlatformWhereUniqueInput | PlatformWhereUniqueInput[]
    update?: PlatformUpdateWithWhereUniqueWithoutBusinessIdInput | PlatformUpdateWithWhereUniqueWithoutBusinessIdInput[]
    updateMany?: PlatformUpdateManyWithWhereWithoutBusinessIdInput | PlatformUpdateManyWithWhereWithoutBusinessIdInput[]
    deleteMany?: PlatformScalarWhereInput | PlatformScalarWhereInput[]
  }

  export type StoreUncheckedUpdateManyWithoutBusinessIdNestedInput = {
    create?: XOR<StoreCreateWithoutBusinessIdInput, StoreUncheckedCreateWithoutBusinessIdInput> | StoreCreateWithoutBusinessIdInput[] | StoreUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutBusinessIdInput | StoreCreateOrConnectWithoutBusinessIdInput[]
    upsert?: StoreUpsertWithWhereUniqueWithoutBusinessIdInput | StoreUpsertWithWhereUniqueWithoutBusinessIdInput[]
    createMany?: StoreCreateManyBusinessIdInputEnvelope
    set?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    disconnect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    delete?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    update?: StoreUpdateWithWhereUniqueWithoutBusinessIdInput | StoreUpdateWithWhereUniqueWithoutBusinessIdInput[]
    updateMany?: StoreUpdateManyWithWhereWithoutBusinessIdInput | StoreUpdateManyWithWhereWithoutBusinessIdInput[]
    deleteMany?: StoreScalarWhereInput | StoreScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBusinessIdNestedInput = {
    create?: XOR<ProductCreateWithoutBusinessIdInput, ProductUncheckedCreateWithoutBusinessIdInput> | ProductCreateWithoutBusinessIdInput[] | ProductUncheckedCreateWithoutBusinessIdInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBusinessIdInput | ProductCreateOrConnectWithoutBusinessIdInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBusinessIdInput | ProductUpsertWithWhereUniqueWithoutBusinessIdInput[]
    createMany?: ProductCreateManyBusinessIdInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBusinessIdInput | ProductUpdateWithWhereUniqueWithoutBusinessIdInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBusinessIdInput | ProductUpdateManyWithWhereWithoutBusinessIdInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutBillRecordInput = {
    create?: XOR<ProductCreateWithoutBillRecordInput, ProductUncheckedCreateWithoutBillRecordInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBillRecordInput
    connect?: ProductWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutBillInput = {
    create?: XOR<MemberCreateWithoutBillInput, MemberUncheckedCreateWithoutBillInput>
    connectOrCreate?: MemberCreateOrConnectWithoutBillInput
    connect?: MemberWhereUniqueInput
  }

  export type BusinessAccCreateNestedOneWithoutBillRecordInput = {
    create?: XOR<BusinessAccCreateWithoutBillRecordInput, BusinessAccUncheckedCreateWithoutBillRecordInput>
    connectOrCreate?: BusinessAccCreateOrConnectWithoutBillRecordInput
    connect?: BusinessAccWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutStorefrontIdInput = {
    create?: XOR<StoreCreateWithoutStorefrontIdInput, StoreUncheckedCreateWithoutStorefrontIdInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStorefrontIdInput
    connect?: StoreWhereUniqueInput
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type EnumPaymentFieldUpdateOperationsInput = {
    set?: $Enums.Payment
  }

  export type EnumIncomeChannelFieldUpdateOperationsInput = {
    set?: $Enums.IncomeChannel
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ProductUpdateOneRequiredWithoutBillRecordNestedInput = {
    create?: XOR<ProductCreateWithoutBillRecordInput, ProductUncheckedCreateWithoutBillRecordInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBillRecordInput
    upsert?: ProductUpsertWithoutBillRecordInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutBillRecordInput, ProductUpdateWithoutBillRecordInput>, ProductUncheckedUpdateWithoutBillRecordInput>
  }

  export type MemberUpdateOneRequiredWithoutBillNestedInput = {
    create?: XOR<MemberCreateWithoutBillInput, MemberUncheckedCreateWithoutBillInput>
    connectOrCreate?: MemberCreateOrConnectWithoutBillInput
    upsert?: MemberUpsertWithoutBillInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutBillInput, MemberUpdateWithoutBillInput>, MemberUncheckedUpdateWithoutBillInput>
  }

  export type BusinessAccUpdateOneRequiredWithoutBillRecordNestedInput = {
    create?: XOR<BusinessAccCreateWithoutBillRecordInput, BusinessAccUncheckedCreateWithoutBillRecordInput>
    connectOrCreate?: BusinessAccCreateOrConnectWithoutBillRecordInput
    upsert?: BusinessAccUpsertWithoutBillRecordInput
    connect?: BusinessAccWhereUniqueInput
    update?: XOR<XOR<BusinessAccUpdateToOneWithWhereWithoutBillRecordInput, BusinessAccUpdateWithoutBillRecordInput>, BusinessAccUncheckedUpdateWithoutBillRecordInput>
  }

  export type StoreUpdateOneRequiredWithoutStorefrontIdNestedInput = {
    create?: XOR<StoreCreateWithoutStorefrontIdInput, StoreUncheckedCreateWithoutStorefrontIdInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStorefrontIdInput
    upsert?: StoreUpsertWithoutStorefrontIdInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutStorefrontIdInput, StoreUpdateWithoutStorefrontIdInput>, StoreUncheckedUpdateWithoutStorefrontIdInput>
  }

  export type MemberCreateNestedOneWithoutAdsCostInput = {
    create?: XOR<MemberCreateWithoutAdsCostInput, MemberUncheckedCreateWithoutAdsCostInput>
    connectOrCreate?: MemberCreateOrConnectWithoutAdsCostInput
    connect?: MemberWhereUniqueInput
  }

  export type PlatformCreateNestedOneWithoutPlatformIdInput = {
    create?: XOR<PlatformCreateWithoutPlatformIdInput, PlatformUncheckedCreateWithoutPlatformIdInput>
    connectOrCreate?: PlatformCreateOrConnectWithoutPlatformIdInput
    connect?: PlatformWhereUniqueInput
  }

  export type BusinessAccCreateNestedOneWithoutAdsCostRecordInput = {
    create?: XOR<BusinessAccCreateWithoutAdsCostRecordInput, BusinessAccUncheckedCreateWithoutAdsCostRecordInput>
    connectOrCreate?: BusinessAccCreateOrConnectWithoutAdsCostRecordInput
    connect?: BusinessAccWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutAdsRecordInput = {
    create?: XOR<ProductCreateWithoutAdsRecordInput, ProductUncheckedCreateWithoutAdsRecordInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdsRecordInput
    connect?: ProductWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type MemberUpdateOneRequiredWithoutAdsCostNestedInput = {
    create?: XOR<MemberCreateWithoutAdsCostInput, MemberUncheckedCreateWithoutAdsCostInput>
    connectOrCreate?: MemberCreateOrConnectWithoutAdsCostInput
    upsert?: MemberUpsertWithoutAdsCostInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutAdsCostInput, MemberUpdateWithoutAdsCostInput>, MemberUncheckedUpdateWithoutAdsCostInput>
  }

  export type PlatformUpdateOneRequiredWithoutPlatformIdNestedInput = {
    create?: XOR<PlatformCreateWithoutPlatformIdInput, PlatformUncheckedCreateWithoutPlatformIdInput>
    connectOrCreate?: PlatformCreateOrConnectWithoutPlatformIdInput
    upsert?: PlatformUpsertWithoutPlatformIdInput
    connect?: PlatformWhereUniqueInput
    update?: XOR<XOR<PlatformUpdateToOneWithWhereWithoutPlatformIdInput, PlatformUpdateWithoutPlatformIdInput>, PlatformUncheckedUpdateWithoutPlatformIdInput>
  }

  export type BusinessAccUpdateOneRequiredWithoutAdsCostRecordNestedInput = {
    create?: XOR<BusinessAccCreateWithoutAdsCostRecordInput, BusinessAccUncheckedCreateWithoutAdsCostRecordInput>
    connectOrCreate?: BusinessAccCreateOrConnectWithoutAdsCostRecordInput
    upsert?: BusinessAccUpsertWithoutAdsCostRecordInput
    connect?: BusinessAccWhereUniqueInput
    update?: XOR<XOR<BusinessAccUpdateToOneWithWhereWithoutAdsCostRecordInput, BusinessAccUpdateWithoutAdsCostRecordInput>, BusinessAccUncheckedUpdateWithoutAdsCostRecordInput>
  }

  export type ProductUpdateOneRequiredWithoutAdsRecordNestedInput = {
    create?: XOR<ProductCreateWithoutAdsRecordInput, ProductUncheckedCreateWithoutAdsRecordInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdsRecordInput
    upsert?: ProductUpsertWithoutAdsRecordInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutAdsRecordInput, ProductUpdateWithoutAdsRecordInput>, ProductUncheckedUpdateWithoutAdsRecordInput>
  }

  export type BusinessAccCreateNestedOneWithoutExpenseRecordInput = {
    create?: XOR<BusinessAccCreateWithoutExpenseRecordInput, BusinessAccUncheckedCreateWithoutExpenseRecordInput>
    connectOrCreate?: BusinessAccCreateOrConnectWithoutExpenseRecordInput
    connect?: BusinessAccWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutExpenseInput = {
    create?: XOR<MemberCreateWithoutExpenseInput, MemberUncheckedCreateWithoutExpenseInput>
    connectOrCreate?: MemberCreateOrConnectWithoutExpenseInput
    connect?: MemberWhereUniqueInput
  }

  export type NullableEnumBankFieldUpdateOperationsInput = {
    set?: $Enums.Bank | null
  }

  export type BusinessAccUpdateOneRequiredWithoutExpenseRecordNestedInput = {
    create?: XOR<BusinessAccCreateWithoutExpenseRecordInput, BusinessAccUncheckedCreateWithoutExpenseRecordInput>
    connectOrCreate?: BusinessAccCreateOrConnectWithoutExpenseRecordInput
    upsert?: BusinessAccUpsertWithoutExpenseRecordInput
    connect?: BusinessAccWhereUniqueInput
    update?: XOR<XOR<BusinessAccUpdateToOneWithWhereWithoutExpenseRecordInput, BusinessAccUpdateWithoutExpenseRecordInput>, BusinessAccUncheckedUpdateWithoutExpenseRecordInput>
  }

  export type MemberUpdateOneRequiredWithoutExpenseNestedInput = {
    create?: XOR<MemberCreateWithoutExpenseInput, MemberUncheckedCreateWithoutExpenseInput>
    connectOrCreate?: MemberCreateOrConnectWithoutExpenseInput
    upsert?: MemberUpsertWithoutExpenseInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutExpenseInput, MemberUpdateWithoutExpenseInput>, MemberUncheckedUpdateWithoutExpenseInput>
  }

  export type AdsCostCreateNestedManyWithoutPlatformInput = {
    create?: XOR<AdsCostCreateWithoutPlatformInput, AdsCostUncheckedCreateWithoutPlatformInput> | AdsCostCreateWithoutPlatformInput[] | AdsCostUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutPlatformInput | AdsCostCreateOrConnectWithoutPlatformInput[]
    createMany?: AdsCostCreateManyPlatformInputEnvelope
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
  }

  export type BusinessAccCreateNestedOneWithoutPlatformInput = {
    create?: XOR<BusinessAccCreateWithoutPlatformInput, BusinessAccUncheckedCreateWithoutPlatformInput>
    connectOrCreate?: BusinessAccCreateOrConnectWithoutPlatformInput
    connect?: BusinessAccWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutPlatformInput = {
    create?: XOR<MemberCreateWithoutPlatformInput, MemberUncheckedCreateWithoutPlatformInput>
    connectOrCreate?: MemberCreateOrConnectWithoutPlatformInput
    connect?: MemberWhereUniqueInput
  }

  export type AdsCostUncheckedCreateNestedManyWithoutPlatformInput = {
    create?: XOR<AdsCostCreateWithoutPlatformInput, AdsCostUncheckedCreateWithoutPlatformInput> | AdsCostCreateWithoutPlatformInput[] | AdsCostUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutPlatformInput | AdsCostCreateOrConnectWithoutPlatformInput[]
    createMany?: AdsCostCreateManyPlatformInputEnvelope
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
  }

  export type EnumSocialMediaFieldUpdateOperationsInput = {
    set?: $Enums.SocialMedia
  }

  export type AdsCostUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<AdsCostCreateWithoutPlatformInput, AdsCostUncheckedCreateWithoutPlatformInput> | AdsCostCreateWithoutPlatformInput[] | AdsCostUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutPlatformInput | AdsCostCreateOrConnectWithoutPlatformInput[]
    upsert?: AdsCostUpsertWithWhereUniqueWithoutPlatformInput | AdsCostUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: AdsCostCreateManyPlatformInputEnvelope
    set?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    disconnect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    delete?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    update?: AdsCostUpdateWithWhereUniqueWithoutPlatformInput | AdsCostUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: AdsCostUpdateManyWithWhereWithoutPlatformInput | AdsCostUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: AdsCostScalarWhereInput | AdsCostScalarWhereInput[]
  }

  export type BusinessAccUpdateOneRequiredWithoutPlatformNestedInput = {
    create?: XOR<BusinessAccCreateWithoutPlatformInput, BusinessAccUncheckedCreateWithoutPlatformInput>
    connectOrCreate?: BusinessAccCreateOrConnectWithoutPlatformInput
    upsert?: BusinessAccUpsertWithoutPlatformInput
    connect?: BusinessAccWhereUniqueInput
    update?: XOR<XOR<BusinessAccUpdateToOneWithWhereWithoutPlatformInput, BusinessAccUpdateWithoutPlatformInput>, BusinessAccUncheckedUpdateWithoutPlatformInput>
  }

  export type MemberUpdateOneRequiredWithoutPlatformNestedInput = {
    create?: XOR<MemberCreateWithoutPlatformInput, MemberUncheckedCreateWithoutPlatformInput>
    connectOrCreate?: MemberCreateOrConnectWithoutPlatformInput
    upsert?: MemberUpsertWithoutPlatformInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutPlatformInput, MemberUpdateWithoutPlatformInput>, MemberUncheckedUpdateWithoutPlatformInput>
  }

  export type AdsCostUncheckedUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<AdsCostCreateWithoutPlatformInput, AdsCostUncheckedCreateWithoutPlatformInput> | AdsCostCreateWithoutPlatformInput[] | AdsCostUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutPlatformInput | AdsCostCreateOrConnectWithoutPlatformInput[]
    upsert?: AdsCostUpsertWithWhereUniqueWithoutPlatformInput | AdsCostUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: AdsCostCreateManyPlatformInputEnvelope
    set?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    disconnect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    delete?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    update?: AdsCostUpdateWithWhereUniqueWithoutPlatformInput | AdsCostUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: AdsCostUpdateManyWithWhereWithoutPlatformInput | AdsCostUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: AdsCostScalarWhereInput | AdsCostScalarWhereInput[]
  }

  export type BillCreateNestedManyWithoutStoreInput = {
    create?: XOR<BillCreateWithoutStoreInput, BillUncheckedCreateWithoutStoreInput> | BillCreateWithoutStoreInput[] | BillUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: BillCreateOrConnectWithoutStoreInput | BillCreateOrConnectWithoutStoreInput[]
    createMany?: BillCreateManyStoreInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type BusinessAccCreateNestedOneWithoutStorefrontInput = {
    create?: XOR<BusinessAccCreateWithoutStorefrontInput, BusinessAccUncheckedCreateWithoutStorefrontInput>
    connectOrCreate?: BusinessAccCreateOrConnectWithoutStorefrontInput
    connect?: BusinessAccWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutStoreInput = {
    create?: XOR<MemberCreateWithoutStoreInput, MemberUncheckedCreateWithoutStoreInput>
    connectOrCreate?: MemberCreateOrConnectWithoutStoreInput
    connect?: MemberWhereUniqueInput
  }

  export type BillUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<BillCreateWithoutStoreInput, BillUncheckedCreateWithoutStoreInput> | BillCreateWithoutStoreInput[] | BillUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: BillCreateOrConnectWithoutStoreInput | BillCreateOrConnectWithoutStoreInput[]
    createMany?: BillCreateManyStoreInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type BillUpdateManyWithoutStoreNestedInput = {
    create?: XOR<BillCreateWithoutStoreInput, BillUncheckedCreateWithoutStoreInput> | BillCreateWithoutStoreInput[] | BillUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: BillCreateOrConnectWithoutStoreInput | BillCreateOrConnectWithoutStoreInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutStoreInput | BillUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: BillCreateManyStoreInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutStoreInput | BillUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: BillUpdateManyWithWhereWithoutStoreInput | BillUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type BusinessAccUpdateOneRequiredWithoutStorefrontNestedInput = {
    create?: XOR<BusinessAccCreateWithoutStorefrontInput, BusinessAccUncheckedCreateWithoutStorefrontInput>
    connectOrCreate?: BusinessAccCreateOrConnectWithoutStorefrontInput
    upsert?: BusinessAccUpsertWithoutStorefrontInput
    connect?: BusinessAccWhereUniqueInput
    update?: XOR<XOR<BusinessAccUpdateToOneWithWhereWithoutStorefrontInput, BusinessAccUpdateWithoutStorefrontInput>, BusinessAccUncheckedUpdateWithoutStorefrontInput>
  }

  export type MemberUpdateOneRequiredWithoutStoreNestedInput = {
    create?: XOR<MemberCreateWithoutStoreInput, MemberUncheckedCreateWithoutStoreInput>
    connectOrCreate?: MemberCreateOrConnectWithoutStoreInput
    upsert?: MemberUpsertWithoutStoreInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutStoreInput, MemberUpdateWithoutStoreInput>, MemberUncheckedUpdateWithoutStoreInput>
  }

  export type BillUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<BillCreateWithoutStoreInput, BillUncheckedCreateWithoutStoreInput> | BillCreateWithoutStoreInput[] | BillUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: BillCreateOrConnectWithoutStoreInput | BillCreateOrConnectWithoutStoreInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutStoreInput | BillUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: BillCreateManyStoreInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutStoreInput | BillUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: BillUpdateManyWithWhereWithoutStoreInput | BillUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type BillCreateNestedManyWithoutProductListInput = {
    create?: XOR<BillCreateWithoutProductListInput, BillUncheckedCreateWithoutProductListInput> | BillCreateWithoutProductListInput[] | BillUncheckedCreateWithoutProductListInput[]
    connectOrCreate?: BillCreateOrConnectWithoutProductListInput | BillCreateOrConnectWithoutProductListInput[]
    createMany?: BillCreateManyProductListInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type AdsCostCreateNestedManyWithoutProductListInput = {
    create?: XOR<AdsCostCreateWithoutProductListInput, AdsCostUncheckedCreateWithoutProductListInput> | AdsCostCreateWithoutProductListInput[] | AdsCostUncheckedCreateWithoutProductListInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutProductListInput | AdsCostCreateOrConnectWithoutProductListInput[]
    createMany?: AdsCostCreateManyProductListInputEnvelope
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
  }

  export type MemberCreateNestedOneWithoutProductInput = {
    create?: XOR<MemberCreateWithoutProductInput, MemberUncheckedCreateWithoutProductInput>
    connectOrCreate?: MemberCreateOrConnectWithoutProductInput
    connect?: MemberWhereUniqueInput
  }

  export type BusinessAccCreateNestedOneWithoutProductInput = {
    create?: XOR<BusinessAccCreateWithoutProductInput, BusinessAccUncheckedCreateWithoutProductInput>
    connectOrCreate?: BusinessAccCreateOrConnectWithoutProductInput
    connect?: BusinessAccWhereUniqueInput
  }

  export type BillUncheckedCreateNestedManyWithoutProductListInput = {
    create?: XOR<BillCreateWithoutProductListInput, BillUncheckedCreateWithoutProductListInput> | BillCreateWithoutProductListInput[] | BillUncheckedCreateWithoutProductListInput[]
    connectOrCreate?: BillCreateOrConnectWithoutProductListInput | BillCreateOrConnectWithoutProductListInput[]
    createMany?: BillCreateManyProductListInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type AdsCostUncheckedCreateNestedManyWithoutProductListInput = {
    create?: XOR<AdsCostCreateWithoutProductListInput, AdsCostUncheckedCreateWithoutProductListInput> | AdsCostCreateWithoutProductListInput[] | AdsCostUncheckedCreateWithoutProductListInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutProductListInput | AdsCostCreateOrConnectWithoutProductListInput[]
    createMany?: AdsCostCreateManyProductListInputEnvelope
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
  }

  export type BillUpdateManyWithoutProductListNestedInput = {
    create?: XOR<BillCreateWithoutProductListInput, BillUncheckedCreateWithoutProductListInput> | BillCreateWithoutProductListInput[] | BillUncheckedCreateWithoutProductListInput[]
    connectOrCreate?: BillCreateOrConnectWithoutProductListInput | BillCreateOrConnectWithoutProductListInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutProductListInput | BillUpsertWithWhereUniqueWithoutProductListInput[]
    createMany?: BillCreateManyProductListInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutProductListInput | BillUpdateWithWhereUniqueWithoutProductListInput[]
    updateMany?: BillUpdateManyWithWhereWithoutProductListInput | BillUpdateManyWithWhereWithoutProductListInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type AdsCostUpdateManyWithoutProductListNestedInput = {
    create?: XOR<AdsCostCreateWithoutProductListInput, AdsCostUncheckedCreateWithoutProductListInput> | AdsCostCreateWithoutProductListInput[] | AdsCostUncheckedCreateWithoutProductListInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutProductListInput | AdsCostCreateOrConnectWithoutProductListInput[]
    upsert?: AdsCostUpsertWithWhereUniqueWithoutProductListInput | AdsCostUpsertWithWhereUniqueWithoutProductListInput[]
    createMany?: AdsCostCreateManyProductListInputEnvelope
    set?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    disconnect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    delete?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    update?: AdsCostUpdateWithWhereUniqueWithoutProductListInput | AdsCostUpdateWithWhereUniqueWithoutProductListInput[]
    updateMany?: AdsCostUpdateManyWithWhereWithoutProductListInput | AdsCostUpdateManyWithWhereWithoutProductListInput[]
    deleteMany?: AdsCostScalarWhereInput | AdsCostScalarWhereInput[]
  }

  export type MemberUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<MemberCreateWithoutProductInput, MemberUncheckedCreateWithoutProductInput>
    connectOrCreate?: MemberCreateOrConnectWithoutProductInput
    upsert?: MemberUpsertWithoutProductInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutProductInput, MemberUpdateWithoutProductInput>, MemberUncheckedUpdateWithoutProductInput>
  }

  export type BusinessAccUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<BusinessAccCreateWithoutProductInput, BusinessAccUncheckedCreateWithoutProductInput>
    connectOrCreate?: BusinessAccCreateOrConnectWithoutProductInput
    upsert?: BusinessAccUpsertWithoutProductInput
    connect?: BusinessAccWhereUniqueInput
    update?: XOR<XOR<BusinessAccUpdateToOneWithWhereWithoutProductInput, BusinessAccUpdateWithoutProductInput>, BusinessAccUncheckedUpdateWithoutProductInput>
  }

  export type BillUncheckedUpdateManyWithoutProductListNestedInput = {
    create?: XOR<BillCreateWithoutProductListInput, BillUncheckedCreateWithoutProductListInput> | BillCreateWithoutProductListInput[] | BillUncheckedCreateWithoutProductListInput[]
    connectOrCreate?: BillCreateOrConnectWithoutProductListInput | BillCreateOrConnectWithoutProductListInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutProductListInput | BillUpsertWithWhereUniqueWithoutProductListInput[]
    createMany?: BillCreateManyProductListInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutProductListInput | BillUpdateWithWhereUniqueWithoutProductListInput[]
    updateMany?: BillUpdateManyWithWhereWithoutProductListInput | BillUpdateManyWithWhereWithoutProductListInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type AdsCostUncheckedUpdateManyWithoutProductListNestedInput = {
    create?: XOR<AdsCostCreateWithoutProductListInput, AdsCostUncheckedCreateWithoutProductListInput> | AdsCostCreateWithoutProductListInput[] | AdsCostUncheckedCreateWithoutProductListInput[]
    connectOrCreate?: AdsCostCreateOrConnectWithoutProductListInput | AdsCostCreateOrConnectWithoutProductListInput[]
    upsert?: AdsCostUpsertWithWhereUniqueWithoutProductListInput | AdsCostUpsertWithWhereUniqueWithoutProductListInput[]
    createMany?: AdsCostCreateManyProductListInputEnvelope
    set?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    disconnect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    delete?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    connect?: AdsCostWhereUniqueInput | AdsCostWhereUniqueInput[]
    update?: AdsCostUpdateWithWhereUniqueWithoutProductListInput | AdsCostUpdateWithWhereUniqueWithoutProductListInput[]
    updateMany?: AdsCostUpdateManyWithWhereWithoutProductListInput | AdsCostUpdateManyWithWhereWithoutProductListInput[]
    deleteMany?: AdsCostScalarWhereInput | AdsCostScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOwnerInput = {
    create?: XOR<UserCreateWithoutOwnerInput, UserUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnerInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreditInput = {
    create?: XOR<UserCreateWithoutCreditInput, UserUncheckedCreateWithoutCreditInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOwnerNestedInput = {
    create?: XOR<UserCreateWithoutOwnerInput, UserUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnerInput
    upsert?: UserUpsertWithoutOwnerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnerInput, UserUpdateWithoutOwnerInput>, UserUncheckedUpdateWithoutOwnerInput>
  }

  export type UserUpdateOneRequiredWithoutCreditNestedInput = {
    create?: XOR<UserCreateWithoutCreditInput, UserUncheckedCreateWithoutCreditInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditInput
    upsert?: UserUpsertWithoutCreditInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreditInput, UserUpdateWithoutCreditInput>, UserUncheckedUpdateWithoutCreditInput>
  }

  export type PostCreatehashtagInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type ReactionCreateNestedManyWithoutPostInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReactionUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostUpdatehashtagInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableEnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType | null
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type ReactionUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutPostInput | ReactionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutPostInput | ReactionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutPostInput | ReactionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReactionUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutPostInput | ReactionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutPostInput | ReactionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutPostInput | ReactionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutReactionsInput = {
    create?: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReactionsInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReactionsInput = {
    create?: XOR<UserCreateWithoutReactionsInput, UserUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReactionType
  }

  export type PostUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReactionsInput
    upsert?: PostUpsertWithoutReactionsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutReactionsInput, PostUpdateWithoutReactionsInput>, PostUncheckedUpdateWithoutReactionsInput>
  }

  export type UserUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<UserCreateWithoutReactionsInput, UserUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReactionsInput
    upsert?: UserUpsertWithoutReactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReactionsInput, UserUpdateWithoutReactionsInput>, UserUncheckedUpdateWithoutReactionsInput>
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserCreateNestedOneWithoutSellerInput = {
    create?: XOR<UserCreateWithoutSellerInput, UserUncheckedCreateWithoutSellerInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellerInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBuyerInput = {
    create?: XOR<UserCreateWithoutBuyerInput, UserUncheckedCreateWithoutBuyerInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuyerInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutSellerInput = {
    create?: XOR<OrderCreateWithoutSellerInput, OrderUncheckedCreateWithoutSellerInput>
    connectOrCreate?: OrderCreateOrConnectWithoutSellerInput
    connect?: OrderWhereUniqueInput
  }

  export type OptionCreateNestedManyWithoutShopInput = {
    create?: XOR<OptionCreateWithoutShopInput, OptionUncheckedCreateWithoutShopInput> | OptionCreateWithoutShopInput[] | OptionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OptionCreateOrConnectWithoutShopInput | OptionCreateOrConnectWithoutShopInput[]
    createMany?: OptionCreateManyShopInputEnvelope
    connect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutShopInput = {
    create?: XOR<ReviewCreateWithoutShopInput, ReviewUncheckedCreateWithoutShopInput> | ReviewCreateWithoutShopInput[] | ReviewUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutShopInput | ReviewCreateOrConnectWithoutShopInput[]
    createMany?: ReviewCreateManyShopInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedOneWithoutSellerInput = {
    create?: XOR<OrderCreateWithoutSellerInput, OrderUncheckedCreateWithoutSellerInput>
    connectOrCreate?: OrderCreateOrConnectWithoutSellerInput
    connect?: OrderWhereUniqueInput
  }

  export type OptionUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<OptionCreateWithoutShopInput, OptionUncheckedCreateWithoutShopInput> | OptionCreateWithoutShopInput[] | OptionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OptionCreateOrConnectWithoutShopInput | OptionCreateOrConnectWithoutShopInput[]
    createMany?: OptionCreateManyShopInputEnvelope
    connect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<ReviewCreateWithoutShopInput, ReviewUncheckedCreateWithoutShopInput> | ReviewCreateWithoutShopInput[] | ReviewUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutShopInput | ReviewCreateOrConnectWithoutShopInput[]
    createMany?: ReviewCreateManyShopInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type EnumProductTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductType
  }

  export type EnumCategoryFieldUpdateOperationsInput = {
    set?: $Enums.Category
  }

  export type UserUpdateOneRequiredWithoutSellerNestedInput = {
    create?: XOR<UserCreateWithoutSellerInput, UserUncheckedCreateWithoutSellerInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellerInput
    upsert?: UserUpsertWithoutSellerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSellerInput, UserUpdateWithoutSellerInput>, UserUncheckedUpdateWithoutSellerInput>
  }

  export type UserUpdateOneRequiredWithoutBuyerNestedInput = {
    create?: XOR<UserCreateWithoutBuyerInput, UserUncheckedCreateWithoutBuyerInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuyerInput
    upsert?: UserUpsertWithoutBuyerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBuyerInput, UserUpdateWithoutBuyerInput>, UserUncheckedUpdateWithoutBuyerInput>
  }

  export type OrderUpdateOneWithoutSellerNestedInput = {
    create?: XOR<OrderCreateWithoutSellerInput, OrderUncheckedCreateWithoutSellerInput>
    connectOrCreate?: OrderCreateOrConnectWithoutSellerInput
    upsert?: OrderUpsertWithoutSellerInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutSellerInput, OrderUpdateWithoutSellerInput>, OrderUncheckedUpdateWithoutSellerInput>
  }

  export type OptionUpdateManyWithoutShopNestedInput = {
    create?: XOR<OptionCreateWithoutShopInput, OptionUncheckedCreateWithoutShopInput> | OptionCreateWithoutShopInput[] | OptionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OptionCreateOrConnectWithoutShopInput | OptionCreateOrConnectWithoutShopInput[]
    upsert?: OptionUpsertWithWhereUniqueWithoutShopInput | OptionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: OptionCreateManyShopInputEnvelope
    set?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    disconnect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    delete?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    connect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    update?: OptionUpdateWithWhereUniqueWithoutShopInput | OptionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: OptionUpdateManyWithWhereWithoutShopInput | OptionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: OptionScalarWhereInput | OptionScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutShopNestedInput = {
    create?: XOR<ReviewCreateWithoutShopInput, ReviewUncheckedCreateWithoutShopInput> | ReviewCreateWithoutShopInput[] | ReviewUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutShopInput | ReviewCreateOrConnectWithoutShopInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutShopInput | ReviewUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ReviewCreateManyShopInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutShopInput | ReviewUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutShopInput | ReviewUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type OrderUncheckedUpdateOneWithoutSellerNestedInput = {
    create?: XOR<OrderCreateWithoutSellerInput, OrderUncheckedCreateWithoutSellerInput>
    connectOrCreate?: OrderCreateOrConnectWithoutSellerInput
    upsert?: OrderUpsertWithoutSellerInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutSellerInput, OrderUpdateWithoutSellerInput>, OrderUncheckedUpdateWithoutSellerInput>
  }

  export type OptionUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<OptionCreateWithoutShopInput, OptionUncheckedCreateWithoutShopInput> | OptionCreateWithoutShopInput[] | OptionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OptionCreateOrConnectWithoutShopInput | OptionCreateOrConnectWithoutShopInput[]
    upsert?: OptionUpsertWithWhereUniqueWithoutShopInput | OptionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: OptionCreateManyShopInputEnvelope
    set?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    disconnect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    delete?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    connect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    update?: OptionUpdateWithWhereUniqueWithoutShopInput | OptionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: OptionUpdateManyWithWhereWithoutShopInput | OptionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: OptionScalarWhereInput | OptionScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<ReviewCreateWithoutShopInput, ReviewUncheckedCreateWithoutShopInput> | ReviewCreateWithoutShopInput[] | ReviewUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutShopInput | ReviewCreateOrConnectWithoutShopInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutShopInput | ReviewUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ReviewCreateManyShopInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutShopInput | ReviewUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutShopInput | ReviewUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ShopCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ShopCreateWithoutOrdersInput, ShopUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ShopCreateOrConnectWithoutOrdersInput
    connect?: ShopWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrderInput = {
    create?: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderInput
    connect?: UserWhereUniqueInput
  }

  export type ReviewCreateNestedOneWithoutOrderInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput
    connect?: ReviewWhereUniqueInput
  }

  export type CartCreateNestedOneWithoutOrderInput = {
    create?: XOR<CartCreateWithoutOrderInput, CartUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CartCreateOrConnectWithoutOrderInput
    connect?: CartWhereUniqueInput
  }

  export type ReviewUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput
    connect?: ReviewWhereUniqueInput
  }

  export type ShopUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<ShopCreateWithoutOrdersInput, ShopUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ShopCreateOrConnectWithoutOrdersInput
    upsert?: ShopUpsertWithoutOrdersInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutOrdersInput, ShopUpdateWithoutOrdersInput>, ShopUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderInput
    upsert?: UserUpsertWithoutOrderInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrderInput, UserUpdateWithoutOrderInput>, UserUncheckedUpdateWithoutOrderInput>
  }

  export type ReviewUpdateOneWithoutOrderNestedInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput
    upsert?: ReviewUpsertWithoutOrderInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutOrderInput, ReviewUpdateWithoutOrderInput>, ReviewUncheckedUpdateWithoutOrderInput>
  }

  export type CartUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<CartCreateWithoutOrderInput, CartUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CartCreateOrConnectWithoutOrderInput
    upsert?: CartUpsertWithoutOrderInput
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutOrderInput, CartUpdateWithoutOrderInput>, CartUncheckedUpdateWithoutOrderInput>
  }

  export type ReviewUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput
    upsert?: ReviewUpsertWithoutOrderInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutOrderInput, ReviewUpdateWithoutOrderInput>, ReviewUncheckedUpdateWithoutOrderInput>
  }

  export type ShopCreateNestedOneWithoutOptionsInput = {
    create?: XOR<ShopCreateWithoutOptionsInput, ShopUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutOptionsInput
    connect?: ShopWhereUniqueInput
  }

  export type OptionValueCreateNestedManyWithoutOptionInput = {
    create?: XOR<OptionValueCreateWithoutOptionInput, OptionValueUncheckedCreateWithoutOptionInput> | OptionValueCreateWithoutOptionInput[] | OptionValueUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: OptionValueCreateOrConnectWithoutOptionInput | OptionValueCreateOrConnectWithoutOptionInput[]
    createMany?: OptionValueCreateManyOptionInputEnvelope
    connect?: OptionValueWhereUniqueInput | OptionValueWhereUniqueInput[]
  }

  export type OptionValueUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<OptionValueCreateWithoutOptionInput, OptionValueUncheckedCreateWithoutOptionInput> | OptionValueCreateWithoutOptionInput[] | OptionValueUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: OptionValueCreateOrConnectWithoutOptionInput | OptionValueCreateOrConnectWithoutOptionInput[]
    createMany?: OptionValueCreateManyOptionInputEnvelope
    connect?: OptionValueWhereUniqueInput | OptionValueWhereUniqueInput[]
  }

  export type EnumOptionNameFieldUpdateOperationsInput = {
    set?: $Enums.OptionName
  }

  export type ShopUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<ShopCreateWithoutOptionsInput, ShopUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutOptionsInput
    upsert?: ShopUpsertWithoutOptionsInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutOptionsInput, ShopUpdateWithoutOptionsInput>, ShopUncheckedUpdateWithoutOptionsInput>
  }

  export type OptionValueUpdateManyWithoutOptionNestedInput = {
    create?: XOR<OptionValueCreateWithoutOptionInput, OptionValueUncheckedCreateWithoutOptionInput> | OptionValueCreateWithoutOptionInput[] | OptionValueUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: OptionValueCreateOrConnectWithoutOptionInput | OptionValueCreateOrConnectWithoutOptionInput[]
    upsert?: OptionValueUpsertWithWhereUniqueWithoutOptionInput | OptionValueUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: OptionValueCreateManyOptionInputEnvelope
    set?: OptionValueWhereUniqueInput | OptionValueWhereUniqueInput[]
    disconnect?: OptionValueWhereUniqueInput | OptionValueWhereUniqueInput[]
    delete?: OptionValueWhereUniqueInput | OptionValueWhereUniqueInput[]
    connect?: OptionValueWhereUniqueInput | OptionValueWhereUniqueInput[]
    update?: OptionValueUpdateWithWhereUniqueWithoutOptionInput | OptionValueUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: OptionValueUpdateManyWithWhereWithoutOptionInput | OptionValueUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: OptionValueScalarWhereInput | OptionValueScalarWhereInput[]
  }

  export type OptionValueUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<OptionValueCreateWithoutOptionInput, OptionValueUncheckedCreateWithoutOptionInput> | OptionValueCreateWithoutOptionInput[] | OptionValueUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: OptionValueCreateOrConnectWithoutOptionInput | OptionValueCreateOrConnectWithoutOptionInput[]
    upsert?: OptionValueUpsertWithWhereUniqueWithoutOptionInput | OptionValueUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: OptionValueCreateManyOptionInputEnvelope
    set?: OptionValueWhereUniqueInput | OptionValueWhereUniqueInput[]
    disconnect?: OptionValueWhereUniqueInput | OptionValueWhereUniqueInput[]
    delete?: OptionValueWhereUniqueInput | OptionValueWhereUniqueInput[]
    connect?: OptionValueWhereUniqueInput | OptionValueWhereUniqueInput[]
    update?: OptionValueUpdateWithWhereUniqueWithoutOptionInput | OptionValueUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: OptionValueUpdateManyWithWhereWithoutOptionInput | OptionValueUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: OptionValueScalarWhereInput | OptionValueScalarWhereInput[]
  }

  export type OptionCreateNestedOneWithoutValuesInput = {
    create?: XOR<OptionCreateWithoutValuesInput, OptionUncheckedCreateWithoutValuesInput>
    connectOrCreate?: OptionCreateOrConnectWithoutValuesInput
    connect?: OptionWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OptionUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<OptionCreateWithoutValuesInput, OptionUncheckedCreateWithoutValuesInput>
    connectOrCreate?: OptionCreateOrConnectWithoutValuesInput
    upsert?: OptionUpsertWithoutValuesInput
    connect?: OptionWhereUniqueInput
    update?: XOR<XOR<OptionUpdateToOneWithWhereWithoutValuesInput, OptionUpdateWithoutValuesInput>, OptionUncheckedUpdateWithoutValuesInput>
  }

  export type OrderCreateNestedOneWithoutReviewInput = {
    create?: XOR<OrderCreateWithoutReviewInput, OrderUncheckedCreateWithoutReviewInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReviewInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewInput = {
    create?: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewInput
    connect?: UserWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutReviewInput = {
    create?: XOR<ShopCreateWithoutReviewInput, ShopUncheckedCreateWithoutReviewInput>
    connectOrCreate?: ShopCreateOrConnectWithoutReviewInput
    connect?: ShopWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<OrderCreateWithoutReviewInput, OrderUncheckedCreateWithoutReviewInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReviewInput
    upsert?: OrderUpsertWithoutReviewInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutReviewInput, OrderUpdateWithoutReviewInput>, OrderUncheckedUpdateWithoutReviewInput>
  }

  export type UserUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewInput
    upsert?: UserUpsertWithoutReviewInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewInput, UserUpdateWithoutReviewInput>, UserUncheckedUpdateWithoutReviewInput>
  }

  export type ShopUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<ShopCreateWithoutReviewInput, ShopUncheckedCreateWithoutReviewInput>
    connectOrCreate?: ShopCreateOrConnectWithoutReviewInput
    upsert?: ShopUpsertWithoutReviewInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutReviewInput, ShopUpdateWithoutReviewInput>, ShopUncheckedUpdateWithoutReviewInput>
  }

  export type OrderCreateNestedManyWithoutCartInput = {
    create?: XOR<OrderCreateWithoutCartInput, OrderUncheckedCreateWithoutCartInput> | OrderCreateWithoutCartInput[] | OrderUncheckedCreateWithoutCartInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCartInput | OrderCreateOrConnectWithoutCartInput[]
    createMany?: OrderCreateManyCartInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<OrderCreateWithoutCartInput, OrderUncheckedCreateWithoutCartInput> | OrderCreateWithoutCartInput[] | OrderUncheckedCreateWithoutCartInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCartInput | OrderCreateOrConnectWithoutCartInput[]
    createMany?: OrderCreateManyCartInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutCartNestedInput = {
    create?: XOR<OrderCreateWithoutCartInput, OrderUncheckedCreateWithoutCartInput> | OrderCreateWithoutCartInput[] | OrderUncheckedCreateWithoutCartInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCartInput | OrderCreateOrConnectWithoutCartInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCartInput | OrderUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: OrderCreateManyCartInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCartInput | OrderUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCartInput | OrderUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<OrderCreateWithoutCartInput, OrderUncheckedCreateWithoutCartInput> | OrderCreateWithoutCartInput[] | OrderUncheckedCreateWithoutCartInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCartInput | OrderCreateOrConnectWithoutCartInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCartInput | OrderUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: OrderCreateManyCartInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCartInput | OrderUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCartInput | OrderUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumBusinessTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessType | EnumBusinessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessTypeFilter<$PrismaModel> | $Enums.BusinessType
  }

  export type NestedEnumtaxTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.taxType | EnumtaxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.taxType[] | ListEnumtaxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.taxType[] | ListEnumtaxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumtaxTypeFilter<$PrismaModel> | $Enums.taxType
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumBusinessTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessType | EnumBusinessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessTypeWithAggregatesFilter<$PrismaModel> | $Enums.BusinessType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBusinessTypeFilter<$PrismaModel>
    _max?: NestedEnumBusinessTypeFilter<$PrismaModel>
  }

  export type NestedEnumtaxTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.taxType | EnumtaxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.taxType[] | ListEnumtaxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.taxType[] | ListEnumtaxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumtaxTypeWithAggregatesFilter<$PrismaModel> | $Enums.taxType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtaxTypeFilter<$PrismaModel>
    _max?: NestedEnumtaxTypeFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumPaymentFilter<$PrismaModel = never> = {
    equals?: $Enums.Payment | EnumPaymentFieldRefInput<$PrismaModel>
    in?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    notIn?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentFilter<$PrismaModel> | $Enums.Payment
  }

  export type NestedEnumIncomeChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeChannel | EnumIncomeChannelFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeChannel[] | ListEnumIncomeChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncomeChannel[] | ListEnumIncomeChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumIncomeChannelFilter<$PrismaModel> | $Enums.IncomeChannel
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Payment | EnumPaymentFieldRefInput<$PrismaModel>
    in?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    notIn?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentWithAggregatesFilter<$PrismaModel> | $Enums.Payment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentFilter<$PrismaModel>
    _max?: NestedEnumPaymentFilter<$PrismaModel>
  }

  export type NestedEnumIncomeChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeChannel | EnumIncomeChannelFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeChannel[] | ListEnumIncomeChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncomeChannel[] | ListEnumIncomeChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumIncomeChannelWithAggregatesFilter<$PrismaModel> | $Enums.IncomeChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncomeChannelFilter<$PrismaModel>
    _max?: NestedEnumIncomeChannelFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumBankNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Bank | EnumBankFieldRefInput<$PrismaModel> | null
    in?: $Enums.Bank[] | ListEnumBankFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Bank[] | ListEnumBankFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBankNullableFilter<$PrismaModel> | $Enums.Bank | null
  }

  export type NestedEnumBankNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Bank | EnumBankFieldRefInput<$PrismaModel> | null
    in?: $Enums.Bank[] | ListEnumBankFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Bank[] | ListEnumBankFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBankNullableWithAggregatesFilter<$PrismaModel> | $Enums.Bank | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBankNullableFilter<$PrismaModel>
    _max?: NestedEnumBankNullableFilter<$PrismaModel>
  }

  export type NestedEnumSocialMediaFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialMedia | EnumSocialMediaFieldRefInput<$PrismaModel>
    in?: $Enums.SocialMedia[] | ListEnumSocialMediaFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialMedia[] | ListEnumSocialMediaFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialMediaFilter<$PrismaModel> | $Enums.SocialMedia
  }

  export type NestedEnumSocialMediaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialMedia | EnumSocialMediaFieldRefInput<$PrismaModel>
    in?: $Enums.SocialMedia[] | ListEnumSocialMediaFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialMedia[] | ListEnumSocialMediaFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialMediaWithAggregatesFilter<$PrismaModel> | $Enums.SocialMedia
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialMediaFilter<$PrismaModel>
    _max?: NestedEnumSocialMediaFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMediaTypeNullableFilter<$PrismaModel> | $Enums.MediaType | null
  }

  export type NestedEnumMediaTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMediaTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.MediaType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type NestedEnumCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryFilter<$PrismaModel> | $Enums.Category
  }

  export type NestedEnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type NestedEnumCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryWithAggregatesFilter<$PrismaModel> | $Enums.Category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryFilter<$PrismaModel>
    _max?: NestedEnumCategoryFilter<$PrismaModel>
  }

  export type NestedEnumOptionNameFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionName | EnumOptionNameFieldRefInput<$PrismaModel>
    in?: $Enums.OptionName[] | ListEnumOptionNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.OptionName[] | ListEnumOptionNameFieldRefInput<$PrismaModel>
    not?: NestedEnumOptionNameFilter<$PrismaModel> | $Enums.OptionName
  }

  export type NestedEnumOptionNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionName | EnumOptionNameFieldRefInput<$PrismaModel>
    in?: $Enums.OptionName[] | ListEnumOptionNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.OptionName[] | ListEnumOptionNameFieldRefInput<$PrismaModel>
    not?: NestedEnumOptionNameWithAggregatesFilter<$PrismaModel> | $Enums.OptionName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOptionNameFilter<$PrismaModel>
    _max?: NestedEnumOptionNameFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BusinessAccCreateWithoutUserInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    memberId?: string | null
    AllMember?: MemberCreateNestedManyWithoutBusinessInput
    billRecord?: BillCreateNestedManyWithoutBusinessIdInput
    expenseRecord?: ExpenseCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreCreateNestedManyWithoutBusinessIdInput
    product?: ProductCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    memberId?: string | null
    AllMember?: MemberUncheckedCreateNestedManyWithoutBusinessInput
    billRecord?: BillUncheckedCreateNestedManyWithoutBusinessIdInput
    expenseRecord?: ExpenseUncheckedCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostUncheckedCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformUncheckedCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreUncheckedCreateNestedManyWithoutBusinessIdInput
    product?: ProductUncheckedCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccCreateOrConnectWithoutUserInput = {
    where: BusinessAccWhereUniqueInput
    create: XOR<BusinessAccCreateWithoutUserInput, BusinessAccUncheckedCreateWithoutUserInput>
  }

  export type BusinessAccCreateManyUserInputEnvelope = {
    data: BusinessAccCreateManyUserInput | BusinessAccCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MemberCreateWithoutUserInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    business?: BusinessAccCreateNestedOneWithoutAllMemberInput
    bill?: BillCreateNestedManyWithoutMemberInput
    adsCost?: AdsCostCreateNestedManyWithoutMemberInput
    expense?: ExpenseCreateNestedManyWithoutMemberInput
    product?: ProductCreateNestedManyWithoutMemberInput
    platform?: PlatformCreateNestedManyWithoutMemberInput
    store?: StoreCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutUserInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessId?: number | null
    bill?: BillUncheckedCreateNestedManyWithoutMemberInput
    adsCost?: AdsCostUncheckedCreateNestedManyWithoutMemberInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutMemberInput
    product?: ProductUncheckedCreateNestedManyWithoutMemberInput
    platform?: PlatformUncheckedCreateNestedManyWithoutMemberInput
    store?: StoreUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutUserInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberCreateManyUserInputEnvelope = {
    data: MemberCreateManyUserInput | MemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutAuthorInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    hashtag?: PostCreatehashtagInput | string[]
    content?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.MediaType | null
    published?: boolean
    deleted?: boolean | null
    reactions?: ReactionCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hashtag?: PostCreatehashtagInput | string[]
    content?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.MediaType | null
    published?: boolean
    deleted?: boolean | null
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    deleted?: boolean | null
    post: PostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    postId: number
    deleted?: boolean | null
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReactionCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ReactionType
    post: PostCreateNestedOneWithoutReactionsInput
  }

  export type ReactionUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ReactionType
    postId: number
  }

  export type ReactionCreateOrConnectWithoutUserInput = {
    where: ReactionWhereUniqueInput
    create: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput>
  }

  export type ReactionCreateManyUserInputEnvelope = {
    data: ReactionCreateManyUserInput | ReactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InboxCreateWithoutSenderInput = {
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    unsent?: boolean
    deleted?: boolean | null
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type InboxUncheckedCreateWithoutSenderInput = {
    id?: number
    receiverId: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    unsent?: boolean
    deleted?: boolean | null
  }

  export type InboxCreateOrConnectWithoutSenderInput = {
    where: InboxWhereUniqueInput
    create: XOR<InboxCreateWithoutSenderInput, InboxUncheckedCreateWithoutSenderInput>
  }

  export type InboxCreateManySenderInputEnvelope = {
    data: InboxCreateManySenderInput | InboxCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type InboxCreateWithoutReceiverInput = {
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    unsent?: boolean
    deleted?: boolean | null
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type InboxUncheckedCreateWithoutReceiverInput = {
    id?: number
    senderId: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    unsent?: boolean
    deleted?: boolean | null
  }

  export type InboxCreateOrConnectWithoutReceiverInput = {
    where: InboxWhereUniqueInput
    create: XOR<InboxCreateWithoutReceiverInput, InboxUncheckedCreateWithoutReceiverInput>
  }

  export type InboxCreateManyReceiverInputEnvelope = {
    data: InboxCreateManyReceiverInput | InboxCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type ShopCreateWithoutSellerInput = {
    name: string
    description?: string | null
    productType?: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: $Enums.Category
    deleted?: boolean | null
    buyer: UserCreateNestedOneWithoutBuyerInput
    orders?: OrderCreateNestedOneWithoutSellerInput
    options?: OptionCreateNestedManyWithoutShopInput
    review?: ReviewCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutSellerInput = {
    id?: number
    name: string
    description?: string | null
    productType?: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: $Enums.Category
    buyerId: number
    deleted?: boolean | null
    orders?: OrderUncheckedCreateNestedOneWithoutSellerInput
    options?: OptionUncheckedCreateNestedManyWithoutShopInput
    review?: ReviewUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutSellerInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutSellerInput, ShopUncheckedCreateWithoutSellerInput>
  }

  export type ShopCreateManySellerInputEnvelope = {
    data: ShopCreateManySellerInput | ShopCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type ShopCreateWithoutBuyerInput = {
    name: string
    description?: string | null
    productType?: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: $Enums.Category
    deleted?: boolean | null
    seller: UserCreateNestedOneWithoutSellerInput
    orders?: OrderCreateNestedOneWithoutSellerInput
    options?: OptionCreateNestedManyWithoutShopInput
    review?: ReviewCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutBuyerInput = {
    id?: number
    name: string
    description?: string | null
    productType?: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: $Enums.Category
    sellerId: number
    deleted?: boolean | null
    orders?: OrderUncheckedCreateNestedOneWithoutSellerInput
    options?: OptionUncheckedCreateNestedManyWithoutShopInput
    review?: ReviewUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutBuyerInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutBuyerInput, ShopUncheckedCreateWithoutBuyerInput>
  }

  export type ShopCreateManyBuyerInputEnvelope = {
    data: ShopCreateManyBuyerInput | ShopCreateManyBuyerInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutBuyerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity: number
    buyerId: number
    deleted?: boolean | null
    seller: ShopCreateNestedOneWithoutOrdersInput
    review?: ReviewCreateNestedOneWithoutOrderInput
    cart?: CartCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutBuyerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity: number
    shopId: number
    buyerId: number
    deleted?: boolean | null
    review?: ReviewUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutBuyerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutBuyerInput, OrderUncheckedCreateWithoutBuyerInput>
  }

  export type OrderCreateManyBuyerInputEnvelope = {
    data: OrderCreateManyBuyerInput | OrderCreateManyBuyerInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    rating: number
    order: OrderCreateNestedOneWithoutReviewInput
    shop: ShopCreateNestedOneWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    rating: number
    shopId: number
    orderId: number
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CreditCreateWithoutOwnerInput = {
    createdAt?: Date | string
    creditor: UserCreateNestedOneWithoutCreditInput
  }

  export type CreditUncheckedCreateWithoutOwnerInput = {
    id?: number
    createdAt?: Date | string
    creditorId: number
  }

  export type CreditCreateOrConnectWithoutOwnerInput = {
    where: CreditWhereUniqueInput
    create: XOR<CreditCreateWithoutOwnerInput, CreditUncheckedCreateWithoutOwnerInput>
  }

  export type CreditCreateManyOwnerInputEnvelope = {
    data: CreditCreateManyOwnerInput | CreditCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type CreditCreateWithoutCreditorInput = {
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnerInput
  }

  export type CreditUncheckedCreateWithoutCreditorInput = {
    id?: number
    createdAt?: Date | string
    ownerId: number
  }

  export type CreditCreateOrConnectWithoutCreditorInput = {
    where: CreditWhereUniqueInput
    create: XOR<CreditCreateWithoutCreditorInput, CreditUncheckedCreateWithoutCreditorInput>
  }

  export type CreditCreateManyCreditorInputEnvelope = {
    data: CreditCreateManyCreditorInput | CreditCreateManyCreditorInput[]
    skipDuplicates?: boolean
  }

  export type BusinessAccUpsertWithWhereUniqueWithoutUserInput = {
    where: BusinessAccWhereUniqueInput
    update: XOR<BusinessAccUpdateWithoutUserInput, BusinessAccUncheckedUpdateWithoutUserInput>
    create: XOR<BusinessAccCreateWithoutUserInput, BusinessAccUncheckedCreateWithoutUserInput>
  }

  export type BusinessAccUpdateWithWhereUniqueWithoutUserInput = {
    where: BusinessAccWhereUniqueInput
    data: XOR<BusinessAccUpdateWithoutUserInput, BusinessAccUncheckedUpdateWithoutUserInput>
  }

  export type BusinessAccUpdateManyWithWhereWithoutUserInput = {
    where: BusinessAccScalarWhereInput
    data: XOR<BusinessAccUpdateManyMutationInput, BusinessAccUncheckedUpdateManyWithoutUserInput>
  }

  export type BusinessAccScalarWhereInput = {
    AND?: BusinessAccScalarWhereInput | BusinessAccScalarWhereInput[]
    OR?: BusinessAccScalarWhereInput[]
    NOT?: BusinessAccScalarWhereInput | BusinessAccScalarWhereInput[]
    id?: IntFilter<"BusinessAcc"> | number
    createdAt?: DateTimeNullableFilter<"BusinessAcc"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"BusinessAcc"> | Date | string | null
    businessName?: StringFilter<"BusinessAcc"> | string
    businessUserName?: StringNullableFilter<"BusinessAcc"> | string | null
    businessAvatar?: StringNullableFilter<"BusinessAcc"> | string | null
    businessAddress?: StringNullableFilter<"BusinessAcc"> | string | null
    vatId?: StringFilter<"BusinessAcc"> | string
    businessType?: EnumBusinessTypeFilter<"BusinessAcc"> | $Enums.BusinessType
    taxType?: EnumtaxTypeFilter<"BusinessAcc"> | $Enums.taxType
    userId?: IntFilter<"BusinessAcc"> | number
    memberId?: StringNullableFilter<"BusinessAcc"> | string | null
  }

  export type MemberUpsertWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
  }

  export type MemberUpdateManyWithWhereWithoutUserInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutUserInput>
  }

  export type MemberScalarWhereInput = {
    AND?: MemberScalarWhereInput | MemberScalarWhereInput[]
    OR?: MemberScalarWhereInput[]
    NOT?: MemberScalarWhereInput | MemberScalarWhereInput[]
    uniqueId?: StringFilter<"Member"> | string
    role?: EnumUserRoleFilter<"Member"> | $Enums.UserRole
    permission?: StringFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    userId?: IntFilter<"Member"> | number
    businessId?: IntNullableFilter<"Member"> | number | null
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: IntFilter<"Post"> | number
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    hashtag?: StringNullableListFilter<"Post">
    content?: StringNullableFilter<"Post"> | string | null
    mediaUrl?: StringNullableFilter<"Post"> | string | null
    mediaType?: EnumMediaTypeNullableFilter<"Post"> | $Enums.MediaType | null
    published?: BoolFilter<"Post"> | boolean
    authorId?: IntFilter<"Post"> | number
    deleted?: BoolNullableFilter<"Post"> | boolean | null
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    content?: StringFilter<"Comment"> | string
    postId?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    deleted?: BoolNullableFilter<"Comment"> | boolean | null
  }

  export type ReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: ReactionWhereUniqueInput
    update: XOR<ReactionUpdateWithoutUserInput, ReactionUncheckedUpdateWithoutUserInput>
    create: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput>
  }

  export type ReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: ReactionWhereUniqueInput
    data: XOR<ReactionUpdateWithoutUserInput, ReactionUncheckedUpdateWithoutUserInput>
  }

  export type ReactionUpdateManyWithWhereWithoutUserInput = {
    where: ReactionScalarWhereInput
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyWithoutUserInput>
  }

  export type ReactionScalarWhereInput = {
    AND?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
    OR?: ReactionScalarWhereInput[]
    NOT?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
    id?: IntFilter<"Reaction"> | number
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
    updatedAt?: DateTimeFilter<"Reaction"> | Date | string
    type?: EnumReactionTypeFilter<"Reaction"> | $Enums.ReactionType
    postId?: IntFilter<"Reaction"> | number
    userId?: IntFilter<"Reaction"> | number
  }

  export type InboxUpsertWithWhereUniqueWithoutSenderInput = {
    where: InboxWhereUniqueInput
    update: XOR<InboxUpdateWithoutSenderInput, InboxUncheckedUpdateWithoutSenderInput>
    create: XOR<InboxCreateWithoutSenderInput, InboxUncheckedCreateWithoutSenderInput>
  }

  export type InboxUpdateWithWhereUniqueWithoutSenderInput = {
    where: InboxWhereUniqueInput
    data: XOR<InboxUpdateWithoutSenderInput, InboxUncheckedUpdateWithoutSenderInput>
  }

  export type InboxUpdateManyWithWhereWithoutSenderInput = {
    where: InboxScalarWhereInput
    data: XOR<InboxUpdateManyMutationInput, InboxUncheckedUpdateManyWithoutSenderInput>
  }

  export type InboxScalarWhereInput = {
    AND?: InboxScalarWhereInput | InboxScalarWhereInput[]
    OR?: InboxScalarWhereInput[]
    NOT?: InboxScalarWhereInput | InboxScalarWhereInput[]
    id?: IntFilter<"Inbox"> | number
    senderId?: IntFilter<"Inbox"> | number
    receiverId?: IntFilter<"Inbox"> | number
    message?: StringFilter<"Inbox"> | string
    createdAt?: DateTimeFilter<"Inbox"> | Date | string
    updatedAt?: DateTimeFilter<"Inbox"> | Date | string
    read?: BoolFilter<"Inbox"> | boolean
    unsent?: BoolFilter<"Inbox"> | boolean
    deleted?: BoolNullableFilter<"Inbox"> | boolean | null
  }

  export type InboxUpsertWithWhereUniqueWithoutReceiverInput = {
    where: InboxWhereUniqueInput
    update: XOR<InboxUpdateWithoutReceiverInput, InboxUncheckedUpdateWithoutReceiverInput>
    create: XOR<InboxCreateWithoutReceiverInput, InboxUncheckedCreateWithoutReceiverInput>
  }

  export type InboxUpdateWithWhereUniqueWithoutReceiverInput = {
    where: InboxWhereUniqueInput
    data: XOR<InboxUpdateWithoutReceiverInput, InboxUncheckedUpdateWithoutReceiverInput>
  }

  export type InboxUpdateManyWithWhereWithoutReceiverInput = {
    where: InboxScalarWhereInput
    data: XOR<InboxUpdateManyMutationInput, InboxUncheckedUpdateManyWithoutReceiverInput>
  }

  export type ShopUpsertWithWhereUniqueWithoutSellerInput = {
    where: ShopWhereUniqueInput
    update: XOR<ShopUpdateWithoutSellerInput, ShopUncheckedUpdateWithoutSellerInput>
    create: XOR<ShopCreateWithoutSellerInput, ShopUncheckedCreateWithoutSellerInput>
  }

  export type ShopUpdateWithWhereUniqueWithoutSellerInput = {
    where: ShopWhereUniqueInput
    data: XOR<ShopUpdateWithoutSellerInput, ShopUncheckedUpdateWithoutSellerInput>
  }

  export type ShopUpdateManyWithWhereWithoutSellerInput = {
    where: ShopScalarWhereInput
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyWithoutSellerInput>
  }

  export type ShopScalarWhereInput = {
    AND?: ShopScalarWhereInput | ShopScalarWhereInput[]
    OR?: ShopScalarWhereInput[]
    NOT?: ShopScalarWhereInput | ShopScalarWhereInput[]
    id?: IntFilter<"Shop"> | number
    name?: StringFilter<"Shop"> | string
    description?: StringNullableFilter<"Shop"> | string | null
    productType?: EnumProductTypeFilter<"Shop"> | $Enums.ProductType
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    category?: EnumCategoryFilter<"Shop"> | $Enums.Category
    sellerId?: IntFilter<"Shop"> | number
    buyerId?: IntFilter<"Shop"> | number
    deleted?: BoolNullableFilter<"Shop"> | boolean | null
  }

  export type ShopUpsertWithWhereUniqueWithoutBuyerInput = {
    where: ShopWhereUniqueInput
    update: XOR<ShopUpdateWithoutBuyerInput, ShopUncheckedUpdateWithoutBuyerInput>
    create: XOR<ShopCreateWithoutBuyerInput, ShopUncheckedCreateWithoutBuyerInput>
  }

  export type ShopUpdateWithWhereUniqueWithoutBuyerInput = {
    where: ShopWhereUniqueInput
    data: XOR<ShopUpdateWithoutBuyerInput, ShopUncheckedUpdateWithoutBuyerInput>
  }

  export type ShopUpdateManyWithWhereWithoutBuyerInput = {
    where: ShopScalarWhereInput
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyWithoutBuyerInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutBuyerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutBuyerInput, OrderUncheckedUpdateWithoutBuyerInput>
    create: XOR<OrderCreateWithoutBuyerInput, OrderUncheckedCreateWithoutBuyerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutBuyerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutBuyerInput, OrderUncheckedUpdateWithoutBuyerInput>
  }

  export type OrderUpdateManyWithWhereWithoutBuyerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutBuyerInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: IntFilter<"Order"> | number
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    quantity?: IntFilter<"Order"> | number
    shopId?: IntFilter<"Order"> | number
    buyerId?: IntFilter<"Order"> | number
    sellerId?: IntFilter<"Order"> | number
    deleted?: BoolNullableFilter<"Order"> | boolean | null
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: IntFilter<"Review"> | number
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    content?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    shopId?: IntFilter<"Review"> | number
    userId?: IntFilter<"Review"> | number
    orderId?: IntFilter<"Review"> | number
  }

  export type CreditUpsertWithWhereUniqueWithoutOwnerInput = {
    where: CreditWhereUniqueInput
    update: XOR<CreditUpdateWithoutOwnerInput, CreditUncheckedUpdateWithoutOwnerInput>
    create: XOR<CreditCreateWithoutOwnerInput, CreditUncheckedCreateWithoutOwnerInput>
  }

  export type CreditUpdateWithWhereUniqueWithoutOwnerInput = {
    where: CreditWhereUniqueInput
    data: XOR<CreditUpdateWithoutOwnerInput, CreditUncheckedUpdateWithoutOwnerInput>
  }

  export type CreditUpdateManyWithWhereWithoutOwnerInput = {
    where: CreditScalarWhereInput
    data: XOR<CreditUpdateManyMutationInput, CreditUncheckedUpdateManyWithoutOwnerInput>
  }

  export type CreditScalarWhereInput = {
    AND?: CreditScalarWhereInput | CreditScalarWhereInput[]
    OR?: CreditScalarWhereInput[]
    NOT?: CreditScalarWhereInput | CreditScalarWhereInput[]
    id?: IntFilter<"Credit"> | number
    createdAt?: DateTimeFilter<"Credit"> | Date | string
    ownerId?: IntFilter<"Credit"> | number
    creditorId?: IntFilter<"Credit"> | number
  }

  export type CreditUpsertWithWhereUniqueWithoutCreditorInput = {
    where: CreditWhereUniqueInput
    update: XOR<CreditUpdateWithoutCreditorInput, CreditUncheckedUpdateWithoutCreditorInput>
    create: XOR<CreditCreateWithoutCreditorInput, CreditUncheckedCreateWithoutCreditorInput>
  }

  export type CreditUpdateWithWhereUniqueWithoutCreditorInput = {
    where: CreditWhereUniqueInput
    data: XOR<CreditUpdateWithoutCreditorInput, CreditUncheckedUpdateWithoutCreditorInput>
  }

  export type CreditUpdateManyWithWhereWithoutCreditorInput = {
    where: CreditScalarWhereInput
    data: XOR<CreditUpdateManyMutationInput, CreditUncheckedUpdateManyWithoutCreditorInput>
  }

  export type UserCreateWithoutMemberInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    sentMessages?: InboxCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxCreateNestedManyWithoutReceiverInput
    seller?: ShopCreateNestedManyWithoutSellerInput
    buyer?: ShopCreateNestedManyWithoutBuyerInput
    Order?: OrderCreateNestedManyWithoutBuyerInput
    review?: ReviewCreateNestedManyWithoutUserInput
    owner?: CreditCreateNestedManyWithoutOwnerInput
    credit?: CreditCreateNestedManyWithoutCreditorInput
  }

  export type UserUncheckedCreateWithoutMemberInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: InboxUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxUncheckedCreateNestedManyWithoutReceiverInput
    seller?: ShopUncheckedCreateNestedManyWithoutSellerInput
    buyer?: ShopUncheckedCreateNestedManyWithoutBuyerInput
    Order?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    owner?: CreditUncheckedCreateNestedManyWithoutOwnerInput
    credit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
  }

  export type UserCreateOrConnectWithoutMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMemberInput, UserUncheckedCreateWithoutMemberInput>
  }

  export type BusinessAccCreateWithoutAllMemberInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    memberId?: string | null
    user: UserCreateNestedOneWithoutBusinessInput
    billRecord?: BillCreateNestedManyWithoutBusinessIdInput
    expenseRecord?: ExpenseCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreCreateNestedManyWithoutBusinessIdInput
    product?: ProductCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccUncheckedCreateWithoutAllMemberInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    userId: number
    memberId?: string | null
    billRecord?: BillUncheckedCreateNestedManyWithoutBusinessIdInput
    expenseRecord?: ExpenseUncheckedCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostUncheckedCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformUncheckedCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreUncheckedCreateNestedManyWithoutBusinessIdInput
    product?: ProductUncheckedCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccCreateOrConnectWithoutAllMemberInput = {
    where: BusinessAccWhereUniqueInput
    create: XOR<BusinessAccCreateWithoutAllMemberInput, BusinessAccUncheckedCreateWithoutAllMemberInput>
  }

  export type BillCreateWithoutMemberInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    cName: string
    cLastName?: string | null
    cPhone?: string | null
    cGender?: $Enums.Gender | null
    cAddress?: string | null
    cProvince?: string | null
    cPostId?: string | null
    payment: $Enums.Payment
    amount: number
    purchaseAt?: Date | string
    platform: $Enums.IncomeChannel
    cashStatus?: boolean
    price: number
    image?: string | null
    deleted?: boolean | null
    productList: ProductCreateNestedOneWithoutBillRecordInput
    businessId: BusinessAccCreateNestedOneWithoutBillRecordInput
    store: StoreCreateNestedOneWithoutStorefrontIdInput
  }

  export type BillUncheckedCreateWithoutMemberInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cName: string
    cLastName?: string | null
    cPhone?: string | null
    cGender?: $Enums.Gender | null
    cAddress?: string | null
    cProvince?: string | null
    cPostId?: string | null
    product: string
    payment: $Enums.Payment
    amount: number
    purchaseAt?: Date | string
    platform: $Enums.IncomeChannel
    cashStatus?: boolean
    price: number
    image?: string | null
    deleted?: boolean | null
    businessAcc: number
    storeId: number
  }

  export type BillCreateOrConnectWithoutMemberInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutMemberInput, BillUncheckedCreateWithoutMemberInput>
  }

  export type BillCreateManyMemberInputEnvelope = {
    data: BillCreateManyMemberInput | BillCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type AdsCostCreateWithoutMemberInput = {
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    adsCost: Decimal | DecimalJsLike | number | string
    platform: PlatformCreateNestedOneWithoutPlatformIdInput
    businessId: BusinessAccCreateNestedOneWithoutAdsCostRecordInput
    productList: ProductCreateNestedOneWithoutAdsRecordInput
  }

  export type AdsCostUncheckedCreateWithoutMemberInput = {
    id?: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    adsCost: Decimal | DecimalJsLike | number | string
    platformId: number
    product: string
    businessAcc: number
  }

  export type AdsCostCreateOrConnectWithoutMemberInput = {
    where: AdsCostWhereUniqueInput
    create: XOR<AdsCostCreateWithoutMemberInput, AdsCostUncheckedCreateWithoutMemberInput>
  }

  export type AdsCostCreateManyMemberInputEnvelope = {
    data: AdsCostCreateManyMemberInput | AdsCostCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutMemberInput = {
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    group?: string | null
    image?: string | null
    note?: string | null
    desc?: string | null
    deleted?: boolean | null
    save?: boolean | null
    channel?: $Enums.Bank | null
    code?: string | null
    businessId: BusinessAccCreateNestedOneWithoutExpenseRecordInput
  }

  export type ExpenseUncheckedCreateWithoutMemberInput = {
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    group?: string | null
    image?: string | null
    note?: string | null
    desc?: string | null
    deleted?: boolean | null
    save?: boolean | null
    channel?: $Enums.Bank | null
    code?: string | null
    businessAcc: number
  }

  export type ExpenseCreateOrConnectWithoutMemberInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutMemberInput, ExpenseUncheckedCreateWithoutMemberInput>
  }

  export type ExpenseCreateManyMemberInputEnvelope = {
    data: ExpenseCreateManyMemberInput | ExpenseCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutMemberInput = {
    name: string
    description?: string | null
    barcode: string
    image?: string | null
    stock: number
    price: number
    categoryId?: number | null
    statusId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    billRecord?: BillCreateNestedManyWithoutProductListInput
    adsRecord?: AdsCostCreateNestedManyWithoutProductListInput
    businessId: BusinessAccCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutMemberInput = {
    id?: number
    name: string
    description?: string | null
    barcode: string
    image?: string | null
    stock: number
    price: number
    categoryId?: number | null
    statusId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    businessAcc: number
    billRecord?: BillUncheckedCreateNestedManyWithoutProductListInput
    adsRecord?: AdsCostUncheckedCreateNestedManyWithoutProductListInput
  }

  export type ProductCreateOrConnectWithoutMemberInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutMemberInput, ProductUncheckedCreateWithoutMemberInput>
  }

  export type ProductCreateManyMemberInputEnvelope = {
    data: ProductCreateManyMemberInput | ProductCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type PlatformCreateWithoutMemberInput = {
    platform: $Enums.SocialMedia
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    platformId?: AdsCostCreateNestedManyWithoutPlatformInput
    businessId: BusinessAccCreateNestedOneWithoutPlatformInput
  }

  export type PlatformUncheckedCreateWithoutMemberInput = {
    id?: number
    platform: $Enums.SocialMedia
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessAcc: number
    deleted?: boolean | null
    platformId?: AdsCostUncheckedCreateNestedManyWithoutPlatformInput
  }

  export type PlatformCreateOrConnectWithoutMemberInput = {
    where: PlatformWhereUniqueInput
    create: XOR<PlatformCreateWithoutMemberInput, PlatformUncheckedCreateWithoutMemberInput>
  }

  export type PlatformCreateManyMemberInputEnvelope = {
    data: PlatformCreateManyMemberInput | PlatformCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type StoreCreateWithoutMemberInput = {
    platform: $Enums.IncomeChannel
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    storefrontId?: BillCreateNestedManyWithoutStoreInput
    businessId: BusinessAccCreateNestedOneWithoutStorefrontInput
  }

  export type StoreUncheckedCreateWithoutMemberInput = {
    id?: number
    platform: $Enums.IncomeChannel
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessAcc: number
    deleted?: boolean | null
    storefrontId?: BillUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutMemberInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutMemberInput, StoreUncheckedCreateWithoutMemberInput>
  }

  export type StoreCreateManyMemberInputEnvelope = {
    data: StoreCreateManyMemberInput | StoreCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMemberInput = {
    update: XOR<UserUpdateWithoutMemberInput, UserUncheckedUpdateWithoutMemberInput>
    create: XOR<UserCreateWithoutMemberInput, UserUncheckedCreateWithoutMemberInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMemberInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMemberInput, UserUncheckedUpdateWithoutMemberInput>
  }

  export type UserUpdateWithoutMemberInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUpdateManyWithoutReceiverNestedInput
    seller?: ShopUpdateManyWithoutSellerNestedInput
    buyer?: ShopUpdateManyWithoutBuyerNestedInput
    Order?: OrderUpdateManyWithoutBuyerNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    owner?: CreditUpdateManyWithoutOwnerNestedInput
    credit?: CreditUpdateManyWithoutCreditorNestedInput
  }

  export type UserUncheckedUpdateWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUncheckedUpdateManyWithoutReceiverNestedInput
    seller?: ShopUncheckedUpdateManyWithoutSellerNestedInput
    buyer?: ShopUncheckedUpdateManyWithoutBuyerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    owner?: CreditUncheckedUpdateManyWithoutOwnerNestedInput
    credit?: CreditUncheckedUpdateManyWithoutCreditorNestedInput
  }

  export type BusinessAccUpsertWithoutAllMemberInput = {
    update: XOR<BusinessAccUpdateWithoutAllMemberInput, BusinessAccUncheckedUpdateWithoutAllMemberInput>
    create: XOR<BusinessAccCreateWithoutAllMemberInput, BusinessAccUncheckedCreateWithoutAllMemberInput>
    where?: BusinessAccWhereInput
  }

  export type BusinessAccUpdateToOneWithWhereWithoutAllMemberInput = {
    where?: BusinessAccWhereInput
    data: XOR<BusinessAccUpdateWithoutAllMemberInput, BusinessAccUncheckedUpdateWithoutAllMemberInput>
  }

  export type BusinessAccUpdateWithoutAllMemberInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    billRecord?: BillUpdateManyWithoutBusinessIdNestedInput
    expenseRecord?: ExpenseUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUpdateManyWithoutBusinessIdNestedInput
  }

  export type BusinessAccUncheckedUpdateWithoutAllMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    userId?: IntFieldUpdateOperationsInput | number
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    billRecord?: BillUncheckedUpdateManyWithoutBusinessIdNestedInput
    expenseRecord?: ExpenseUncheckedUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUncheckedUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUncheckedUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUncheckedUpdateManyWithoutBusinessIdNestedInput
  }

  export type BillUpsertWithWhereUniqueWithoutMemberInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutMemberInput, BillUncheckedUpdateWithoutMemberInput>
    create: XOR<BillCreateWithoutMemberInput, BillUncheckedCreateWithoutMemberInput>
  }

  export type BillUpdateWithWhereUniqueWithoutMemberInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutMemberInput, BillUncheckedUpdateWithoutMemberInput>
  }

  export type BillUpdateManyWithWhereWithoutMemberInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutMemberInput>
  }

  export type BillScalarWhereInput = {
    AND?: BillScalarWhereInput | BillScalarWhereInput[]
    OR?: BillScalarWhereInput[]
    NOT?: BillScalarWhereInput | BillScalarWhereInput[]
    id?: IntFilter<"Bill"> | number
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    updatedAt?: DateTimeFilter<"Bill"> | Date | string
    cName?: StringFilter<"Bill"> | string
    cLastName?: StringNullableFilter<"Bill"> | string | null
    cPhone?: StringNullableFilter<"Bill"> | string | null
    cGender?: EnumGenderNullableFilter<"Bill"> | $Enums.Gender | null
    cAddress?: StringNullableFilter<"Bill"> | string | null
    cProvince?: StringNullableFilter<"Bill"> | string | null
    cPostId?: StringNullableFilter<"Bill"> | string | null
    product?: StringFilter<"Bill"> | string
    payment?: EnumPaymentFilter<"Bill"> | $Enums.Payment
    amount?: IntFilter<"Bill"> | number
    purchaseAt?: DateTimeFilter<"Bill"> | Date | string
    platform?: EnumIncomeChannelFilter<"Bill"> | $Enums.IncomeChannel
    cashStatus?: BoolFilter<"Bill"> | boolean
    price?: IntFilter<"Bill"> | number
    image?: StringNullableFilter<"Bill"> | string | null
    deleted?: BoolNullableFilter<"Bill"> | boolean | null
    memberId?: StringFilter<"Bill"> | string
    businessAcc?: IntFilter<"Bill"> | number
    storeId?: IntFilter<"Bill"> | number
  }

  export type AdsCostUpsertWithWhereUniqueWithoutMemberInput = {
    where: AdsCostWhereUniqueInput
    update: XOR<AdsCostUpdateWithoutMemberInput, AdsCostUncheckedUpdateWithoutMemberInput>
    create: XOR<AdsCostCreateWithoutMemberInput, AdsCostUncheckedCreateWithoutMemberInput>
  }

  export type AdsCostUpdateWithWhereUniqueWithoutMemberInput = {
    where: AdsCostWhereUniqueInput
    data: XOR<AdsCostUpdateWithoutMemberInput, AdsCostUncheckedUpdateWithoutMemberInput>
  }

  export type AdsCostUpdateManyWithWhereWithoutMemberInput = {
    where: AdsCostScalarWhereInput
    data: XOR<AdsCostUpdateManyMutationInput, AdsCostUncheckedUpdateManyWithoutMemberInput>
  }

  export type AdsCostScalarWhereInput = {
    AND?: AdsCostScalarWhereInput | AdsCostScalarWhereInput[]
    OR?: AdsCostScalarWhereInput[]
    NOT?: AdsCostScalarWhereInput | AdsCostScalarWhereInput[]
    id?: IntFilter<"AdsCost"> | number
    date?: DateTimeFilter<"AdsCost"> | Date | string
    createdAt?: DateTimeFilter<"AdsCost"> | Date | string
    updatedAt?: DateTimeFilter<"AdsCost"> | Date | string
    adsCost?: DecimalFilter<"AdsCost"> | Decimal | DecimalJsLike | number | string
    memberId?: StringFilter<"AdsCost"> | string
    platformId?: IntFilter<"AdsCost"> | number
    product?: StringFilter<"AdsCost"> | string
    businessAcc?: IntFilter<"AdsCost"> | number
  }

  export type ExpenseUpsertWithWhereUniqueWithoutMemberInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutMemberInput, ExpenseUncheckedUpdateWithoutMemberInput>
    create: XOR<ExpenseCreateWithoutMemberInput, ExpenseUncheckedCreateWithoutMemberInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutMemberInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutMemberInput, ExpenseUncheckedUpdateWithoutMemberInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutMemberInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutMemberInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    date?: DateTimeFilter<"Expense"> | Date | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    id?: IntFilter<"Expense"> | number
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    group?: StringNullableFilter<"Expense"> | string | null
    image?: StringNullableFilter<"Expense"> | string | null
    note?: StringNullableFilter<"Expense"> | string | null
    desc?: StringNullableFilter<"Expense"> | string | null
    deleted?: BoolNullableFilter<"Expense"> | boolean | null
    save?: BoolNullableFilter<"Expense"> | boolean | null
    channel?: EnumBankNullableFilter<"Expense"> | $Enums.Bank | null
    code?: StringNullableFilter<"Expense"> | string | null
    businessAcc?: IntFilter<"Expense"> | number
    memberId?: StringFilter<"Expense"> | string
  }

  export type ProductUpsertWithWhereUniqueWithoutMemberInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutMemberInput, ProductUncheckedUpdateWithoutMemberInput>
    create: XOR<ProductCreateWithoutMemberInput, ProductUncheckedCreateWithoutMemberInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutMemberInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutMemberInput, ProductUncheckedUpdateWithoutMemberInput>
  }

  export type ProductUpdateManyWithWhereWithoutMemberInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutMemberInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    barcode?: StringFilter<"Product"> | string
    image?: StringNullableFilter<"Product"> | string | null
    stock?: IntFilter<"Product"> | number
    price?: IntFilter<"Product"> | number
    categoryId?: IntNullableFilter<"Product"> | number | null
    memberId?: StringFilter<"Product"> | string
    statusId?: IntNullableFilter<"Product"> | number | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deleted?: BoolNullableFilter<"Product"> | boolean | null
    businessAcc?: IntFilter<"Product"> | number
  }

  export type PlatformUpsertWithWhereUniqueWithoutMemberInput = {
    where: PlatformWhereUniqueInput
    update: XOR<PlatformUpdateWithoutMemberInput, PlatformUncheckedUpdateWithoutMemberInput>
    create: XOR<PlatformCreateWithoutMemberInput, PlatformUncheckedCreateWithoutMemberInput>
  }

  export type PlatformUpdateWithWhereUniqueWithoutMemberInput = {
    where: PlatformWhereUniqueInput
    data: XOR<PlatformUpdateWithoutMemberInput, PlatformUncheckedUpdateWithoutMemberInput>
  }

  export type PlatformUpdateManyWithWhereWithoutMemberInput = {
    where: PlatformScalarWhereInput
    data: XOR<PlatformUpdateManyMutationInput, PlatformUncheckedUpdateManyWithoutMemberInput>
  }

  export type PlatformScalarWhereInput = {
    AND?: PlatformScalarWhereInput | PlatformScalarWhereInput[]
    OR?: PlatformScalarWhereInput[]
    NOT?: PlatformScalarWhereInput | PlatformScalarWhereInput[]
    id?: IntFilter<"Platform"> | number
    platform?: EnumSocialMediaFilter<"Platform"> | $Enums.SocialMedia
    accName?: StringFilter<"Platform"> | string
    accId?: StringFilter<"Platform"> | string
    createdAt?: DateTimeFilter<"Platform"> | Date | string
    updatedAt?: DateTimeFilter<"Platform"> | Date | string
    businessAcc?: IntFilter<"Platform"> | number
    memberId?: StringFilter<"Platform"> | string
    deleted?: BoolNullableFilter<"Platform"> | boolean | null
  }

  export type StoreUpsertWithWhereUniqueWithoutMemberInput = {
    where: StoreWhereUniqueInput
    update: XOR<StoreUpdateWithoutMemberInput, StoreUncheckedUpdateWithoutMemberInput>
    create: XOR<StoreCreateWithoutMemberInput, StoreUncheckedCreateWithoutMemberInput>
  }

  export type StoreUpdateWithWhereUniqueWithoutMemberInput = {
    where: StoreWhereUniqueInput
    data: XOR<StoreUpdateWithoutMemberInput, StoreUncheckedUpdateWithoutMemberInput>
  }

  export type StoreUpdateManyWithWhereWithoutMemberInput = {
    where: StoreScalarWhereInput
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyWithoutMemberInput>
  }

  export type StoreScalarWhereInput = {
    AND?: StoreScalarWhereInput | StoreScalarWhereInput[]
    OR?: StoreScalarWhereInput[]
    NOT?: StoreScalarWhereInput | StoreScalarWhereInput[]
    id?: IntFilter<"Store"> | number
    platform?: EnumIncomeChannelFilter<"Store"> | $Enums.IncomeChannel
    accName?: StringFilter<"Store"> | string
    accId?: StringFilter<"Store"> | string
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    businessAcc?: IntFilter<"Store"> | number
    memberId?: StringFilter<"Store"> | string
    deleted?: BoolNullableFilter<"Store"> | boolean | null
  }

  export type UserCreateWithoutBusinessInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    member?: MemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    sentMessages?: InboxCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxCreateNestedManyWithoutReceiverInput
    seller?: ShopCreateNestedManyWithoutSellerInput
    buyer?: ShopCreateNestedManyWithoutBuyerInput
    Order?: OrderCreateNestedManyWithoutBuyerInput
    review?: ReviewCreateNestedManyWithoutUserInput
    owner?: CreditCreateNestedManyWithoutOwnerInput
    credit?: CreditCreateNestedManyWithoutCreditorInput
  }

  export type UserUncheckedCreateWithoutBusinessInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    member?: MemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: InboxUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxUncheckedCreateNestedManyWithoutReceiverInput
    seller?: ShopUncheckedCreateNestedManyWithoutSellerInput
    buyer?: ShopUncheckedCreateNestedManyWithoutBuyerInput
    Order?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    owner?: CreditUncheckedCreateNestedManyWithoutOwnerInput
    credit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
  }

  export type UserCreateOrConnectWithoutBusinessInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBusinessInput, UserUncheckedCreateWithoutBusinessInput>
  }

  export type MemberCreateWithoutBusinessInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMemberInput
    bill?: BillCreateNestedManyWithoutMemberInput
    adsCost?: AdsCostCreateNestedManyWithoutMemberInput
    expense?: ExpenseCreateNestedManyWithoutMemberInput
    product?: ProductCreateNestedManyWithoutMemberInput
    platform?: PlatformCreateNestedManyWithoutMemberInput
    store?: StoreCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutBusinessInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    bill?: BillUncheckedCreateNestedManyWithoutMemberInput
    adsCost?: AdsCostUncheckedCreateNestedManyWithoutMemberInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutMemberInput
    product?: ProductUncheckedCreateNestedManyWithoutMemberInput
    platform?: PlatformUncheckedCreateNestedManyWithoutMemberInput
    store?: StoreUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutBusinessInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutBusinessInput, MemberUncheckedCreateWithoutBusinessInput>
  }

  export type MemberCreateManyBusinessInputEnvelope = {
    data: MemberCreateManyBusinessInput | MemberCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type BillCreateWithoutBusinessIdInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    cName: string
    cLastName?: string | null
    cPhone?: string | null
    cGender?: $Enums.Gender | null
    cAddress?: string | null
    cProvince?: string | null
    cPostId?: string | null
    payment: $Enums.Payment
    amount: number
    purchaseAt?: Date | string
    platform: $Enums.IncomeChannel
    cashStatus?: boolean
    price: number
    image?: string | null
    deleted?: boolean | null
    productList: ProductCreateNestedOneWithoutBillRecordInput
    member: MemberCreateNestedOneWithoutBillInput
    store: StoreCreateNestedOneWithoutStorefrontIdInput
  }

  export type BillUncheckedCreateWithoutBusinessIdInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cName: string
    cLastName?: string | null
    cPhone?: string | null
    cGender?: $Enums.Gender | null
    cAddress?: string | null
    cProvince?: string | null
    cPostId?: string | null
    product: string
    payment: $Enums.Payment
    amount: number
    purchaseAt?: Date | string
    platform: $Enums.IncomeChannel
    cashStatus?: boolean
    price: number
    image?: string | null
    deleted?: boolean | null
    memberId: string
    storeId: number
  }

  export type BillCreateOrConnectWithoutBusinessIdInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutBusinessIdInput, BillUncheckedCreateWithoutBusinessIdInput>
  }

  export type BillCreateManyBusinessIdInputEnvelope = {
    data: BillCreateManyBusinessIdInput | BillCreateManyBusinessIdInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutBusinessIdInput = {
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    group?: string | null
    image?: string | null
    note?: string | null
    desc?: string | null
    deleted?: boolean | null
    save?: boolean | null
    channel?: $Enums.Bank | null
    code?: string | null
    member: MemberCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutBusinessIdInput = {
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    group?: string | null
    image?: string | null
    note?: string | null
    desc?: string | null
    deleted?: boolean | null
    save?: boolean | null
    channel?: $Enums.Bank | null
    code?: string | null
    memberId: string
  }

  export type ExpenseCreateOrConnectWithoutBusinessIdInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutBusinessIdInput, ExpenseUncheckedCreateWithoutBusinessIdInput>
  }

  export type ExpenseCreateManyBusinessIdInputEnvelope = {
    data: ExpenseCreateManyBusinessIdInput | ExpenseCreateManyBusinessIdInput[]
    skipDuplicates?: boolean
  }

  export type AdsCostCreateWithoutBusinessIdInput = {
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    adsCost: Decimal | DecimalJsLike | number | string
    member: MemberCreateNestedOneWithoutAdsCostInput
    platform: PlatformCreateNestedOneWithoutPlatformIdInput
    productList: ProductCreateNestedOneWithoutAdsRecordInput
  }

  export type AdsCostUncheckedCreateWithoutBusinessIdInput = {
    id?: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    adsCost: Decimal | DecimalJsLike | number | string
    memberId: string
    platformId: number
    product: string
  }

  export type AdsCostCreateOrConnectWithoutBusinessIdInput = {
    where: AdsCostWhereUniqueInput
    create: XOR<AdsCostCreateWithoutBusinessIdInput, AdsCostUncheckedCreateWithoutBusinessIdInput>
  }

  export type AdsCostCreateManyBusinessIdInputEnvelope = {
    data: AdsCostCreateManyBusinessIdInput | AdsCostCreateManyBusinessIdInput[]
    skipDuplicates?: boolean
  }

  export type PlatformCreateWithoutBusinessIdInput = {
    platform: $Enums.SocialMedia
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    platformId?: AdsCostCreateNestedManyWithoutPlatformInput
    member: MemberCreateNestedOneWithoutPlatformInput
  }

  export type PlatformUncheckedCreateWithoutBusinessIdInput = {
    id?: number
    platform: $Enums.SocialMedia
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    memberId: string
    deleted?: boolean | null
    platformId?: AdsCostUncheckedCreateNestedManyWithoutPlatformInput
  }

  export type PlatformCreateOrConnectWithoutBusinessIdInput = {
    where: PlatformWhereUniqueInput
    create: XOR<PlatformCreateWithoutBusinessIdInput, PlatformUncheckedCreateWithoutBusinessIdInput>
  }

  export type PlatformCreateManyBusinessIdInputEnvelope = {
    data: PlatformCreateManyBusinessIdInput | PlatformCreateManyBusinessIdInput[]
    skipDuplicates?: boolean
  }

  export type StoreCreateWithoutBusinessIdInput = {
    platform: $Enums.IncomeChannel
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    storefrontId?: BillCreateNestedManyWithoutStoreInput
    member: MemberCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutBusinessIdInput = {
    id?: number
    platform: $Enums.IncomeChannel
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    memberId: string
    deleted?: boolean | null
    storefrontId?: BillUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutBusinessIdInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutBusinessIdInput, StoreUncheckedCreateWithoutBusinessIdInput>
  }

  export type StoreCreateManyBusinessIdInputEnvelope = {
    data: StoreCreateManyBusinessIdInput | StoreCreateManyBusinessIdInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutBusinessIdInput = {
    name: string
    description?: string | null
    barcode: string
    image?: string | null
    stock: number
    price: number
    categoryId?: number | null
    statusId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    billRecord?: BillCreateNestedManyWithoutProductListInput
    adsRecord?: AdsCostCreateNestedManyWithoutProductListInput
    member: MemberCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBusinessIdInput = {
    id?: number
    name: string
    description?: string | null
    barcode: string
    image?: string | null
    stock: number
    price: number
    categoryId?: number | null
    memberId: string
    statusId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    billRecord?: BillUncheckedCreateNestedManyWithoutProductListInput
    adsRecord?: AdsCostUncheckedCreateNestedManyWithoutProductListInput
  }

  export type ProductCreateOrConnectWithoutBusinessIdInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBusinessIdInput, ProductUncheckedCreateWithoutBusinessIdInput>
  }

  export type ProductCreateManyBusinessIdInputEnvelope = {
    data: ProductCreateManyBusinessIdInput | ProductCreateManyBusinessIdInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBusinessInput = {
    update: XOR<UserUpdateWithoutBusinessInput, UserUncheckedUpdateWithoutBusinessInput>
    create: XOR<UserCreateWithoutBusinessInput, UserUncheckedCreateWithoutBusinessInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBusinessInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBusinessInput, UserUncheckedUpdateWithoutBusinessInput>
  }

  export type UserUpdateWithoutBusinessInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    member?: MemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUpdateManyWithoutReceiverNestedInput
    seller?: ShopUpdateManyWithoutSellerNestedInput
    buyer?: ShopUpdateManyWithoutBuyerNestedInput
    Order?: OrderUpdateManyWithoutBuyerNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    owner?: CreditUpdateManyWithoutOwnerNestedInput
    credit?: CreditUpdateManyWithoutCreditorNestedInput
  }

  export type UserUncheckedUpdateWithoutBusinessInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUncheckedUpdateManyWithoutReceiverNestedInput
    seller?: ShopUncheckedUpdateManyWithoutSellerNestedInput
    buyer?: ShopUncheckedUpdateManyWithoutBuyerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    owner?: CreditUncheckedUpdateManyWithoutOwnerNestedInput
    credit?: CreditUncheckedUpdateManyWithoutCreditorNestedInput
  }

  export type MemberUpsertWithWhereUniqueWithoutBusinessInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutBusinessInput, MemberUncheckedUpdateWithoutBusinessInput>
    create: XOR<MemberCreateWithoutBusinessInput, MemberUncheckedCreateWithoutBusinessInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutBusinessInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutBusinessInput, MemberUncheckedUpdateWithoutBusinessInput>
  }

  export type MemberUpdateManyWithWhereWithoutBusinessInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutBusinessInput>
  }

  export type BillUpsertWithWhereUniqueWithoutBusinessIdInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutBusinessIdInput, BillUncheckedUpdateWithoutBusinessIdInput>
    create: XOR<BillCreateWithoutBusinessIdInput, BillUncheckedCreateWithoutBusinessIdInput>
  }

  export type BillUpdateWithWhereUniqueWithoutBusinessIdInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutBusinessIdInput, BillUncheckedUpdateWithoutBusinessIdInput>
  }

  export type BillUpdateManyWithWhereWithoutBusinessIdInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutBusinessIdInput>
  }

  export type ExpenseUpsertWithWhereUniqueWithoutBusinessIdInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutBusinessIdInput, ExpenseUncheckedUpdateWithoutBusinessIdInput>
    create: XOR<ExpenseCreateWithoutBusinessIdInput, ExpenseUncheckedCreateWithoutBusinessIdInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutBusinessIdInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutBusinessIdInput, ExpenseUncheckedUpdateWithoutBusinessIdInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutBusinessIdInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutBusinessIdInput>
  }

  export type AdsCostUpsertWithWhereUniqueWithoutBusinessIdInput = {
    where: AdsCostWhereUniqueInput
    update: XOR<AdsCostUpdateWithoutBusinessIdInput, AdsCostUncheckedUpdateWithoutBusinessIdInput>
    create: XOR<AdsCostCreateWithoutBusinessIdInput, AdsCostUncheckedCreateWithoutBusinessIdInput>
  }

  export type AdsCostUpdateWithWhereUniqueWithoutBusinessIdInput = {
    where: AdsCostWhereUniqueInput
    data: XOR<AdsCostUpdateWithoutBusinessIdInput, AdsCostUncheckedUpdateWithoutBusinessIdInput>
  }

  export type AdsCostUpdateManyWithWhereWithoutBusinessIdInput = {
    where: AdsCostScalarWhereInput
    data: XOR<AdsCostUpdateManyMutationInput, AdsCostUncheckedUpdateManyWithoutBusinessIdInput>
  }

  export type PlatformUpsertWithWhereUniqueWithoutBusinessIdInput = {
    where: PlatformWhereUniqueInput
    update: XOR<PlatformUpdateWithoutBusinessIdInput, PlatformUncheckedUpdateWithoutBusinessIdInput>
    create: XOR<PlatformCreateWithoutBusinessIdInput, PlatformUncheckedCreateWithoutBusinessIdInput>
  }

  export type PlatformUpdateWithWhereUniqueWithoutBusinessIdInput = {
    where: PlatformWhereUniqueInput
    data: XOR<PlatformUpdateWithoutBusinessIdInput, PlatformUncheckedUpdateWithoutBusinessIdInput>
  }

  export type PlatformUpdateManyWithWhereWithoutBusinessIdInput = {
    where: PlatformScalarWhereInput
    data: XOR<PlatformUpdateManyMutationInput, PlatformUncheckedUpdateManyWithoutBusinessIdInput>
  }

  export type StoreUpsertWithWhereUniqueWithoutBusinessIdInput = {
    where: StoreWhereUniqueInput
    update: XOR<StoreUpdateWithoutBusinessIdInput, StoreUncheckedUpdateWithoutBusinessIdInput>
    create: XOR<StoreCreateWithoutBusinessIdInput, StoreUncheckedCreateWithoutBusinessIdInput>
  }

  export type StoreUpdateWithWhereUniqueWithoutBusinessIdInput = {
    where: StoreWhereUniqueInput
    data: XOR<StoreUpdateWithoutBusinessIdInput, StoreUncheckedUpdateWithoutBusinessIdInput>
  }

  export type StoreUpdateManyWithWhereWithoutBusinessIdInput = {
    where: StoreScalarWhereInput
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyWithoutBusinessIdInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutBusinessIdInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBusinessIdInput, ProductUncheckedUpdateWithoutBusinessIdInput>
    create: XOR<ProductCreateWithoutBusinessIdInput, ProductUncheckedCreateWithoutBusinessIdInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBusinessIdInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBusinessIdInput, ProductUncheckedUpdateWithoutBusinessIdInput>
  }

  export type ProductUpdateManyWithWhereWithoutBusinessIdInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBusinessIdInput>
  }

  export type ProductCreateWithoutBillRecordInput = {
    name: string
    description?: string | null
    barcode: string
    image?: string | null
    stock: number
    price: number
    categoryId?: number | null
    statusId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    adsRecord?: AdsCostCreateNestedManyWithoutProductListInput
    member: MemberCreateNestedOneWithoutProductInput
    businessId: BusinessAccCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBillRecordInput = {
    id?: number
    name: string
    description?: string | null
    barcode: string
    image?: string | null
    stock: number
    price: number
    categoryId?: number | null
    memberId: string
    statusId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    businessAcc: number
    adsRecord?: AdsCostUncheckedCreateNestedManyWithoutProductListInput
  }

  export type ProductCreateOrConnectWithoutBillRecordInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBillRecordInput, ProductUncheckedCreateWithoutBillRecordInput>
  }

  export type MemberCreateWithoutBillInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMemberInput
    business?: BusinessAccCreateNestedOneWithoutAllMemberInput
    adsCost?: AdsCostCreateNestedManyWithoutMemberInput
    expense?: ExpenseCreateNestedManyWithoutMemberInput
    product?: ProductCreateNestedManyWithoutMemberInput
    platform?: PlatformCreateNestedManyWithoutMemberInput
    store?: StoreCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutBillInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    businessId?: number | null
    adsCost?: AdsCostUncheckedCreateNestedManyWithoutMemberInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutMemberInput
    product?: ProductUncheckedCreateNestedManyWithoutMemberInput
    platform?: PlatformUncheckedCreateNestedManyWithoutMemberInput
    store?: StoreUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutBillInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutBillInput, MemberUncheckedCreateWithoutBillInput>
  }

  export type BusinessAccCreateWithoutBillRecordInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    memberId?: string | null
    user: UserCreateNestedOneWithoutBusinessInput
    AllMember?: MemberCreateNestedManyWithoutBusinessInput
    expenseRecord?: ExpenseCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreCreateNestedManyWithoutBusinessIdInput
    product?: ProductCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccUncheckedCreateWithoutBillRecordInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    userId: number
    memberId?: string | null
    AllMember?: MemberUncheckedCreateNestedManyWithoutBusinessInput
    expenseRecord?: ExpenseUncheckedCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostUncheckedCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformUncheckedCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreUncheckedCreateNestedManyWithoutBusinessIdInput
    product?: ProductUncheckedCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccCreateOrConnectWithoutBillRecordInput = {
    where: BusinessAccWhereUniqueInput
    create: XOR<BusinessAccCreateWithoutBillRecordInput, BusinessAccUncheckedCreateWithoutBillRecordInput>
  }

  export type StoreCreateWithoutStorefrontIdInput = {
    platform: $Enums.IncomeChannel
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    businessId: BusinessAccCreateNestedOneWithoutStorefrontInput
    member: MemberCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutStorefrontIdInput = {
    id?: number
    platform: $Enums.IncomeChannel
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessAcc: number
    memberId: string
    deleted?: boolean | null
  }

  export type StoreCreateOrConnectWithoutStorefrontIdInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStorefrontIdInput, StoreUncheckedCreateWithoutStorefrontIdInput>
  }

  export type ProductUpsertWithoutBillRecordInput = {
    update: XOR<ProductUpdateWithoutBillRecordInput, ProductUncheckedUpdateWithoutBillRecordInput>
    create: XOR<ProductCreateWithoutBillRecordInput, ProductUncheckedCreateWithoutBillRecordInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutBillRecordInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutBillRecordInput, ProductUncheckedUpdateWithoutBillRecordInput>
  }

  export type ProductUpdateWithoutBillRecordInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    adsRecord?: AdsCostUpdateManyWithoutProductListNestedInput
    member?: MemberUpdateOneRequiredWithoutProductNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBillRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    memberId?: StringFieldUpdateOperationsInput | string
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    businessAcc?: IntFieldUpdateOperationsInput | number
    adsRecord?: AdsCostUncheckedUpdateManyWithoutProductListNestedInput
  }

  export type MemberUpsertWithoutBillInput = {
    update: XOR<MemberUpdateWithoutBillInput, MemberUncheckedUpdateWithoutBillInput>
    create: XOR<MemberCreateWithoutBillInput, MemberUncheckedCreateWithoutBillInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutBillInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutBillInput, MemberUncheckedUpdateWithoutBillInput>
  }

  export type MemberUpdateWithoutBillInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMemberNestedInput
    business?: BusinessAccUpdateOneWithoutAllMemberNestedInput
    adsCost?: AdsCostUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUpdateManyWithoutMemberNestedInput
    product?: ProductUpdateManyWithoutMemberNestedInput
    platform?: PlatformUpdateManyWithoutMemberNestedInput
    store?: StoreUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutBillInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    businessId?: NullableIntFieldUpdateOperationsInput | number | null
    adsCost?: AdsCostUncheckedUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutMemberNestedInput
    product?: ProductUncheckedUpdateManyWithoutMemberNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutMemberNestedInput
    store?: StoreUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type BusinessAccUpsertWithoutBillRecordInput = {
    update: XOR<BusinessAccUpdateWithoutBillRecordInput, BusinessAccUncheckedUpdateWithoutBillRecordInput>
    create: XOR<BusinessAccCreateWithoutBillRecordInput, BusinessAccUncheckedCreateWithoutBillRecordInput>
    where?: BusinessAccWhereInput
  }

  export type BusinessAccUpdateToOneWithWhereWithoutBillRecordInput = {
    where?: BusinessAccWhereInput
    data: XOR<BusinessAccUpdateWithoutBillRecordInput, BusinessAccUncheckedUpdateWithoutBillRecordInput>
  }

  export type BusinessAccUpdateWithoutBillRecordInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    AllMember?: MemberUpdateManyWithoutBusinessNestedInput
    expenseRecord?: ExpenseUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUpdateManyWithoutBusinessIdNestedInput
  }

  export type BusinessAccUncheckedUpdateWithoutBillRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    userId?: IntFieldUpdateOperationsInput | number
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    AllMember?: MemberUncheckedUpdateManyWithoutBusinessNestedInput
    expenseRecord?: ExpenseUncheckedUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUncheckedUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUncheckedUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUncheckedUpdateManyWithoutBusinessIdNestedInput
  }

  export type StoreUpsertWithoutStorefrontIdInput = {
    update: XOR<StoreUpdateWithoutStorefrontIdInput, StoreUncheckedUpdateWithoutStorefrontIdInput>
    create: XOR<StoreCreateWithoutStorefrontIdInput, StoreUncheckedCreateWithoutStorefrontIdInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutStorefrontIdInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutStorefrontIdInput, StoreUncheckedUpdateWithoutStorefrontIdInput>
  }

  export type StoreUpdateWithoutStorefrontIdInput = {
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    businessId?: BusinessAccUpdateOneRequiredWithoutStorefrontNestedInput
    member?: MemberUpdateOneRequiredWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutStorefrontIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessAcc?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type MemberCreateWithoutAdsCostInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMemberInput
    business?: BusinessAccCreateNestedOneWithoutAllMemberInput
    bill?: BillCreateNestedManyWithoutMemberInput
    expense?: ExpenseCreateNestedManyWithoutMemberInput
    product?: ProductCreateNestedManyWithoutMemberInput
    platform?: PlatformCreateNestedManyWithoutMemberInput
    store?: StoreCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutAdsCostInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    businessId?: number | null
    bill?: BillUncheckedCreateNestedManyWithoutMemberInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutMemberInput
    product?: ProductUncheckedCreateNestedManyWithoutMemberInput
    platform?: PlatformUncheckedCreateNestedManyWithoutMemberInput
    store?: StoreUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutAdsCostInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutAdsCostInput, MemberUncheckedCreateWithoutAdsCostInput>
  }

  export type PlatformCreateWithoutPlatformIdInput = {
    platform: $Enums.SocialMedia
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    businessId: BusinessAccCreateNestedOneWithoutPlatformInput
    member: MemberCreateNestedOneWithoutPlatformInput
  }

  export type PlatformUncheckedCreateWithoutPlatformIdInput = {
    id?: number
    platform: $Enums.SocialMedia
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessAcc: number
    memberId: string
    deleted?: boolean | null
  }

  export type PlatformCreateOrConnectWithoutPlatformIdInput = {
    where: PlatformWhereUniqueInput
    create: XOR<PlatformCreateWithoutPlatformIdInput, PlatformUncheckedCreateWithoutPlatformIdInput>
  }

  export type BusinessAccCreateWithoutAdsCostRecordInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    memberId?: string | null
    user: UserCreateNestedOneWithoutBusinessInput
    AllMember?: MemberCreateNestedManyWithoutBusinessInput
    billRecord?: BillCreateNestedManyWithoutBusinessIdInput
    expenseRecord?: ExpenseCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreCreateNestedManyWithoutBusinessIdInput
    product?: ProductCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccUncheckedCreateWithoutAdsCostRecordInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    userId: number
    memberId?: string | null
    AllMember?: MemberUncheckedCreateNestedManyWithoutBusinessInput
    billRecord?: BillUncheckedCreateNestedManyWithoutBusinessIdInput
    expenseRecord?: ExpenseUncheckedCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformUncheckedCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreUncheckedCreateNestedManyWithoutBusinessIdInput
    product?: ProductUncheckedCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccCreateOrConnectWithoutAdsCostRecordInput = {
    where: BusinessAccWhereUniqueInput
    create: XOR<BusinessAccCreateWithoutAdsCostRecordInput, BusinessAccUncheckedCreateWithoutAdsCostRecordInput>
  }

  export type ProductCreateWithoutAdsRecordInput = {
    name: string
    description?: string | null
    barcode: string
    image?: string | null
    stock: number
    price: number
    categoryId?: number | null
    statusId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    billRecord?: BillCreateNestedManyWithoutProductListInput
    member: MemberCreateNestedOneWithoutProductInput
    businessId: BusinessAccCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAdsRecordInput = {
    id?: number
    name: string
    description?: string | null
    barcode: string
    image?: string | null
    stock: number
    price: number
    categoryId?: number | null
    memberId: string
    statusId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    businessAcc: number
    billRecord?: BillUncheckedCreateNestedManyWithoutProductListInput
  }

  export type ProductCreateOrConnectWithoutAdsRecordInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAdsRecordInput, ProductUncheckedCreateWithoutAdsRecordInput>
  }

  export type MemberUpsertWithoutAdsCostInput = {
    update: XOR<MemberUpdateWithoutAdsCostInput, MemberUncheckedUpdateWithoutAdsCostInput>
    create: XOR<MemberCreateWithoutAdsCostInput, MemberUncheckedCreateWithoutAdsCostInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutAdsCostInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutAdsCostInput, MemberUncheckedUpdateWithoutAdsCostInput>
  }

  export type MemberUpdateWithoutAdsCostInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMemberNestedInput
    business?: BusinessAccUpdateOneWithoutAllMemberNestedInput
    bill?: BillUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUpdateManyWithoutMemberNestedInput
    product?: ProductUpdateManyWithoutMemberNestedInput
    platform?: PlatformUpdateManyWithoutMemberNestedInput
    store?: StoreUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutAdsCostInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    businessId?: NullableIntFieldUpdateOperationsInput | number | null
    bill?: BillUncheckedUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutMemberNestedInput
    product?: ProductUncheckedUpdateManyWithoutMemberNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutMemberNestedInput
    store?: StoreUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type PlatformUpsertWithoutPlatformIdInput = {
    update: XOR<PlatformUpdateWithoutPlatformIdInput, PlatformUncheckedUpdateWithoutPlatformIdInput>
    create: XOR<PlatformCreateWithoutPlatformIdInput, PlatformUncheckedCreateWithoutPlatformIdInput>
    where?: PlatformWhereInput
  }

  export type PlatformUpdateToOneWithWhereWithoutPlatformIdInput = {
    where?: PlatformWhereInput
    data: XOR<PlatformUpdateWithoutPlatformIdInput, PlatformUncheckedUpdateWithoutPlatformIdInput>
  }

  export type PlatformUpdateWithoutPlatformIdInput = {
    platform?: EnumSocialMediaFieldUpdateOperationsInput | $Enums.SocialMedia
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    businessId?: BusinessAccUpdateOneRequiredWithoutPlatformNestedInput
    member?: MemberUpdateOneRequiredWithoutPlatformNestedInput
  }

  export type PlatformUncheckedUpdateWithoutPlatformIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumSocialMediaFieldUpdateOperationsInput | $Enums.SocialMedia
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessAcc?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BusinessAccUpsertWithoutAdsCostRecordInput = {
    update: XOR<BusinessAccUpdateWithoutAdsCostRecordInput, BusinessAccUncheckedUpdateWithoutAdsCostRecordInput>
    create: XOR<BusinessAccCreateWithoutAdsCostRecordInput, BusinessAccUncheckedCreateWithoutAdsCostRecordInput>
    where?: BusinessAccWhereInput
  }

  export type BusinessAccUpdateToOneWithWhereWithoutAdsCostRecordInput = {
    where?: BusinessAccWhereInput
    data: XOR<BusinessAccUpdateWithoutAdsCostRecordInput, BusinessAccUncheckedUpdateWithoutAdsCostRecordInput>
  }

  export type BusinessAccUpdateWithoutAdsCostRecordInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    AllMember?: MemberUpdateManyWithoutBusinessNestedInput
    billRecord?: BillUpdateManyWithoutBusinessIdNestedInput
    expenseRecord?: ExpenseUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUpdateManyWithoutBusinessIdNestedInput
  }

  export type BusinessAccUncheckedUpdateWithoutAdsCostRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    userId?: IntFieldUpdateOperationsInput | number
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    AllMember?: MemberUncheckedUpdateManyWithoutBusinessNestedInput
    billRecord?: BillUncheckedUpdateManyWithoutBusinessIdNestedInput
    expenseRecord?: ExpenseUncheckedUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUncheckedUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUncheckedUpdateManyWithoutBusinessIdNestedInput
  }

  export type ProductUpsertWithoutAdsRecordInput = {
    update: XOR<ProductUpdateWithoutAdsRecordInput, ProductUncheckedUpdateWithoutAdsRecordInput>
    create: XOR<ProductCreateWithoutAdsRecordInput, ProductUncheckedCreateWithoutAdsRecordInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutAdsRecordInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutAdsRecordInput, ProductUncheckedUpdateWithoutAdsRecordInput>
  }

  export type ProductUpdateWithoutAdsRecordInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    billRecord?: BillUpdateManyWithoutProductListNestedInput
    member?: MemberUpdateOneRequiredWithoutProductNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutAdsRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    memberId?: StringFieldUpdateOperationsInput | string
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    businessAcc?: IntFieldUpdateOperationsInput | number
    billRecord?: BillUncheckedUpdateManyWithoutProductListNestedInput
  }

  export type BusinessAccCreateWithoutExpenseRecordInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    memberId?: string | null
    user: UserCreateNestedOneWithoutBusinessInput
    AllMember?: MemberCreateNestedManyWithoutBusinessInput
    billRecord?: BillCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreCreateNestedManyWithoutBusinessIdInput
    product?: ProductCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccUncheckedCreateWithoutExpenseRecordInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    userId: number
    memberId?: string | null
    AllMember?: MemberUncheckedCreateNestedManyWithoutBusinessInput
    billRecord?: BillUncheckedCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostUncheckedCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformUncheckedCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreUncheckedCreateNestedManyWithoutBusinessIdInput
    product?: ProductUncheckedCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccCreateOrConnectWithoutExpenseRecordInput = {
    where: BusinessAccWhereUniqueInput
    create: XOR<BusinessAccCreateWithoutExpenseRecordInput, BusinessAccUncheckedCreateWithoutExpenseRecordInput>
  }

  export type MemberCreateWithoutExpenseInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMemberInput
    business?: BusinessAccCreateNestedOneWithoutAllMemberInput
    bill?: BillCreateNestedManyWithoutMemberInput
    adsCost?: AdsCostCreateNestedManyWithoutMemberInput
    product?: ProductCreateNestedManyWithoutMemberInput
    platform?: PlatformCreateNestedManyWithoutMemberInput
    store?: StoreCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutExpenseInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    businessId?: number | null
    bill?: BillUncheckedCreateNestedManyWithoutMemberInput
    adsCost?: AdsCostUncheckedCreateNestedManyWithoutMemberInput
    product?: ProductUncheckedCreateNestedManyWithoutMemberInput
    platform?: PlatformUncheckedCreateNestedManyWithoutMemberInput
    store?: StoreUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutExpenseInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutExpenseInput, MemberUncheckedCreateWithoutExpenseInput>
  }

  export type BusinessAccUpsertWithoutExpenseRecordInput = {
    update: XOR<BusinessAccUpdateWithoutExpenseRecordInput, BusinessAccUncheckedUpdateWithoutExpenseRecordInput>
    create: XOR<BusinessAccCreateWithoutExpenseRecordInput, BusinessAccUncheckedCreateWithoutExpenseRecordInput>
    where?: BusinessAccWhereInput
  }

  export type BusinessAccUpdateToOneWithWhereWithoutExpenseRecordInput = {
    where?: BusinessAccWhereInput
    data: XOR<BusinessAccUpdateWithoutExpenseRecordInput, BusinessAccUncheckedUpdateWithoutExpenseRecordInput>
  }

  export type BusinessAccUpdateWithoutExpenseRecordInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    AllMember?: MemberUpdateManyWithoutBusinessNestedInput
    billRecord?: BillUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUpdateManyWithoutBusinessIdNestedInput
  }

  export type BusinessAccUncheckedUpdateWithoutExpenseRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    userId?: IntFieldUpdateOperationsInput | number
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    AllMember?: MemberUncheckedUpdateManyWithoutBusinessNestedInput
    billRecord?: BillUncheckedUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUncheckedUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUncheckedUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUncheckedUpdateManyWithoutBusinessIdNestedInput
  }

  export type MemberUpsertWithoutExpenseInput = {
    update: XOR<MemberUpdateWithoutExpenseInput, MemberUncheckedUpdateWithoutExpenseInput>
    create: XOR<MemberCreateWithoutExpenseInput, MemberUncheckedCreateWithoutExpenseInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutExpenseInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutExpenseInput, MemberUncheckedUpdateWithoutExpenseInput>
  }

  export type MemberUpdateWithoutExpenseInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMemberNestedInput
    business?: BusinessAccUpdateOneWithoutAllMemberNestedInput
    bill?: BillUpdateManyWithoutMemberNestedInput
    adsCost?: AdsCostUpdateManyWithoutMemberNestedInput
    product?: ProductUpdateManyWithoutMemberNestedInput
    platform?: PlatformUpdateManyWithoutMemberNestedInput
    store?: StoreUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutExpenseInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    businessId?: NullableIntFieldUpdateOperationsInput | number | null
    bill?: BillUncheckedUpdateManyWithoutMemberNestedInput
    adsCost?: AdsCostUncheckedUpdateManyWithoutMemberNestedInput
    product?: ProductUncheckedUpdateManyWithoutMemberNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutMemberNestedInput
    store?: StoreUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type AdsCostCreateWithoutPlatformInput = {
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    adsCost: Decimal | DecimalJsLike | number | string
    member: MemberCreateNestedOneWithoutAdsCostInput
    businessId: BusinessAccCreateNestedOneWithoutAdsCostRecordInput
    productList: ProductCreateNestedOneWithoutAdsRecordInput
  }

  export type AdsCostUncheckedCreateWithoutPlatformInput = {
    id?: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    adsCost: Decimal | DecimalJsLike | number | string
    memberId: string
    product: string
    businessAcc: number
  }

  export type AdsCostCreateOrConnectWithoutPlatformInput = {
    where: AdsCostWhereUniqueInput
    create: XOR<AdsCostCreateWithoutPlatformInput, AdsCostUncheckedCreateWithoutPlatformInput>
  }

  export type AdsCostCreateManyPlatformInputEnvelope = {
    data: AdsCostCreateManyPlatformInput | AdsCostCreateManyPlatformInput[]
    skipDuplicates?: boolean
  }

  export type BusinessAccCreateWithoutPlatformInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    memberId?: string | null
    user: UserCreateNestedOneWithoutBusinessInput
    AllMember?: MemberCreateNestedManyWithoutBusinessInput
    billRecord?: BillCreateNestedManyWithoutBusinessIdInput
    expenseRecord?: ExpenseCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreCreateNestedManyWithoutBusinessIdInput
    product?: ProductCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccUncheckedCreateWithoutPlatformInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    userId: number
    memberId?: string | null
    AllMember?: MemberUncheckedCreateNestedManyWithoutBusinessInput
    billRecord?: BillUncheckedCreateNestedManyWithoutBusinessIdInput
    expenseRecord?: ExpenseUncheckedCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostUncheckedCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreUncheckedCreateNestedManyWithoutBusinessIdInput
    product?: ProductUncheckedCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccCreateOrConnectWithoutPlatformInput = {
    where: BusinessAccWhereUniqueInput
    create: XOR<BusinessAccCreateWithoutPlatformInput, BusinessAccUncheckedCreateWithoutPlatformInput>
  }

  export type MemberCreateWithoutPlatformInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMemberInput
    business?: BusinessAccCreateNestedOneWithoutAllMemberInput
    bill?: BillCreateNestedManyWithoutMemberInput
    adsCost?: AdsCostCreateNestedManyWithoutMemberInput
    expense?: ExpenseCreateNestedManyWithoutMemberInput
    product?: ProductCreateNestedManyWithoutMemberInput
    store?: StoreCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutPlatformInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    businessId?: number | null
    bill?: BillUncheckedCreateNestedManyWithoutMemberInput
    adsCost?: AdsCostUncheckedCreateNestedManyWithoutMemberInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutMemberInput
    product?: ProductUncheckedCreateNestedManyWithoutMemberInput
    store?: StoreUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutPlatformInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutPlatformInput, MemberUncheckedCreateWithoutPlatformInput>
  }

  export type AdsCostUpsertWithWhereUniqueWithoutPlatformInput = {
    where: AdsCostWhereUniqueInput
    update: XOR<AdsCostUpdateWithoutPlatformInput, AdsCostUncheckedUpdateWithoutPlatformInput>
    create: XOR<AdsCostCreateWithoutPlatformInput, AdsCostUncheckedCreateWithoutPlatformInput>
  }

  export type AdsCostUpdateWithWhereUniqueWithoutPlatformInput = {
    where: AdsCostWhereUniqueInput
    data: XOR<AdsCostUpdateWithoutPlatformInput, AdsCostUncheckedUpdateWithoutPlatformInput>
  }

  export type AdsCostUpdateManyWithWhereWithoutPlatformInput = {
    where: AdsCostScalarWhereInput
    data: XOR<AdsCostUpdateManyMutationInput, AdsCostUncheckedUpdateManyWithoutPlatformInput>
  }

  export type BusinessAccUpsertWithoutPlatformInput = {
    update: XOR<BusinessAccUpdateWithoutPlatformInput, BusinessAccUncheckedUpdateWithoutPlatformInput>
    create: XOR<BusinessAccCreateWithoutPlatformInput, BusinessAccUncheckedCreateWithoutPlatformInput>
    where?: BusinessAccWhereInput
  }

  export type BusinessAccUpdateToOneWithWhereWithoutPlatformInput = {
    where?: BusinessAccWhereInput
    data: XOR<BusinessAccUpdateWithoutPlatformInput, BusinessAccUncheckedUpdateWithoutPlatformInput>
  }

  export type BusinessAccUpdateWithoutPlatformInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    AllMember?: MemberUpdateManyWithoutBusinessNestedInput
    billRecord?: BillUpdateManyWithoutBusinessIdNestedInput
    expenseRecord?: ExpenseUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUpdateManyWithoutBusinessIdNestedInput
  }

  export type BusinessAccUncheckedUpdateWithoutPlatformInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    userId?: IntFieldUpdateOperationsInput | number
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    AllMember?: MemberUncheckedUpdateManyWithoutBusinessNestedInput
    billRecord?: BillUncheckedUpdateManyWithoutBusinessIdNestedInput
    expenseRecord?: ExpenseUncheckedUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUncheckedUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUncheckedUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUncheckedUpdateManyWithoutBusinessIdNestedInput
  }

  export type MemberUpsertWithoutPlatformInput = {
    update: XOR<MemberUpdateWithoutPlatformInput, MemberUncheckedUpdateWithoutPlatformInput>
    create: XOR<MemberCreateWithoutPlatformInput, MemberUncheckedCreateWithoutPlatformInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutPlatformInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutPlatformInput, MemberUncheckedUpdateWithoutPlatformInput>
  }

  export type MemberUpdateWithoutPlatformInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMemberNestedInput
    business?: BusinessAccUpdateOneWithoutAllMemberNestedInput
    bill?: BillUpdateManyWithoutMemberNestedInput
    adsCost?: AdsCostUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUpdateManyWithoutMemberNestedInput
    product?: ProductUpdateManyWithoutMemberNestedInput
    store?: StoreUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutPlatformInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    businessId?: NullableIntFieldUpdateOperationsInput | number | null
    bill?: BillUncheckedUpdateManyWithoutMemberNestedInput
    adsCost?: AdsCostUncheckedUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutMemberNestedInput
    product?: ProductUncheckedUpdateManyWithoutMemberNestedInput
    store?: StoreUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type BillCreateWithoutStoreInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    cName: string
    cLastName?: string | null
    cPhone?: string | null
    cGender?: $Enums.Gender | null
    cAddress?: string | null
    cProvince?: string | null
    cPostId?: string | null
    payment: $Enums.Payment
    amount: number
    purchaseAt?: Date | string
    platform: $Enums.IncomeChannel
    cashStatus?: boolean
    price: number
    image?: string | null
    deleted?: boolean | null
    productList: ProductCreateNestedOneWithoutBillRecordInput
    member: MemberCreateNestedOneWithoutBillInput
    businessId: BusinessAccCreateNestedOneWithoutBillRecordInput
  }

  export type BillUncheckedCreateWithoutStoreInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cName: string
    cLastName?: string | null
    cPhone?: string | null
    cGender?: $Enums.Gender | null
    cAddress?: string | null
    cProvince?: string | null
    cPostId?: string | null
    product: string
    payment: $Enums.Payment
    amount: number
    purchaseAt?: Date | string
    platform: $Enums.IncomeChannel
    cashStatus?: boolean
    price: number
    image?: string | null
    deleted?: boolean | null
    memberId: string
    businessAcc: number
  }

  export type BillCreateOrConnectWithoutStoreInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutStoreInput, BillUncheckedCreateWithoutStoreInput>
  }

  export type BillCreateManyStoreInputEnvelope = {
    data: BillCreateManyStoreInput | BillCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type BusinessAccCreateWithoutStorefrontInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    memberId?: string | null
    user: UserCreateNestedOneWithoutBusinessInput
    AllMember?: MemberCreateNestedManyWithoutBusinessInput
    billRecord?: BillCreateNestedManyWithoutBusinessIdInput
    expenseRecord?: ExpenseCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformCreateNestedManyWithoutBusinessIdInput
    product?: ProductCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccUncheckedCreateWithoutStorefrontInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    userId: number
    memberId?: string | null
    AllMember?: MemberUncheckedCreateNestedManyWithoutBusinessInput
    billRecord?: BillUncheckedCreateNestedManyWithoutBusinessIdInput
    expenseRecord?: ExpenseUncheckedCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostUncheckedCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformUncheckedCreateNestedManyWithoutBusinessIdInput
    product?: ProductUncheckedCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccCreateOrConnectWithoutStorefrontInput = {
    where: BusinessAccWhereUniqueInput
    create: XOR<BusinessAccCreateWithoutStorefrontInput, BusinessAccUncheckedCreateWithoutStorefrontInput>
  }

  export type MemberCreateWithoutStoreInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMemberInput
    business?: BusinessAccCreateNestedOneWithoutAllMemberInput
    bill?: BillCreateNestedManyWithoutMemberInput
    adsCost?: AdsCostCreateNestedManyWithoutMemberInput
    expense?: ExpenseCreateNestedManyWithoutMemberInput
    product?: ProductCreateNestedManyWithoutMemberInput
    platform?: PlatformCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutStoreInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    businessId?: number | null
    bill?: BillUncheckedCreateNestedManyWithoutMemberInput
    adsCost?: AdsCostUncheckedCreateNestedManyWithoutMemberInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutMemberInput
    product?: ProductUncheckedCreateNestedManyWithoutMemberInput
    platform?: PlatformUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutStoreInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutStoreInput, MemberUncheckedCreateWithoutStoreInput>
  }

  export type BillUpsertWithWhereUniqueWithoutStoreInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutStoreInput, BillUncheckedUpdateWithoutStoreInput>
    create: XOR<BillCreateWithoutStoreInput, BillUncheckedCreateWithoutStoreInput>
  }

  export type BillUpdateWithWhereUniqueWithoutStoreInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutStoreInput, BillUncheckedUpdateWithoutStoreInput>
  }

  export type BillUpdateManyWithWhereWithoutStoreInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutStoreInput>
  }

  export type BusinessAccUpsertWithoutStorefrontInput = {
    update: XOR<BusinessAccUpdateWithoutStorefrontInput, BusinessAccUncheckedUpdateWithoutStorefrontInput>
    create: XOR<BusinessAccCreateWithoutStorefrontInput, BusinessAccUncheckedCreateWithoutStorefrontInput>
    where?: BusinessAccWhereInput
  }

  export type BusinessAccUpdateToOneWithWhereWithoutStorefrontInput = {
    where?: BusinessAccWhereInput
    data: XOR<BusinessAccUpdateWithoutStorefrontInput, BusinessAccUncheckedUpdateWithoutStorefrontInput>
  }

  export type BusinessAccUpdateWithoutStorefrontInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    AllMember?: MemberUpdateManyWithoutBusinessNestedInput
    billRecord?: BillUpdateManyWithoutBusinessIdNestedInput
    expenseRecord?: ExpenseUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUpdateManyWithoutBusinessIdNestedInput
  }

  export type BusinessAccUncheckedUpdateWithoutStorefrontInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    userId?: IntFieldUpdateOperationsInput | number
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    AllMember?: MemberUncheckedUpdateManyWithoutBusinessNestedInput
    billRecord?: BillUncheckedUpdateManyWithoutBusinessIdNestedInput
    expenseRecord?: ExpenseUncheckedUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUncheckedUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUncheckedUpdateManyWithoutBusinessIdNestedInput
  }

  export type MemberUpsertWithoutStoreInput = {
    update: XOR<MemberUpdateWithoutStoreInput, MemberUncheckedUpdateWithoutStoreInput>
    create: XOR<MemberCreateWithoutStoreInput, MemberUncheckedCreateWithoutStoreInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutStoreInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutStoreInput, MemberUncheckedUpdateWithoutStoreInput>
  }

  export type MemberUpdateWithoutStoreInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMemberNestedInput
    business?: BusinessAccUpdateOneWithoutAllMemberNestedInput
    bill?: BillUpdateManyWithoutMemberNestedInput
    adsCost?: AdsCostUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUpdateManyWithoutMemberNestedInput
    product?: ProductUpdateManyWithoutMemberNestedInput
    platform?: PlatformUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutStoreInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    businessId?: NullableIntFieldUpdateOperationsInput | number | null
    bill?: BillUncheckedUpdateManyWithoutMemberNestedInput
    adsCost?: AdsCostUncheckedUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutMemberNestedInput
    product?: ProductUncheckedUpdateManyWithoutMemberNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type BillCreateWithoutProductListInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    cName: string
    cLastName?: string | null
    cPhone?: string | null
    cGender?: $Enums.Gender | null
    cAddress?: string | null
    cProvince?: string | null
    cPostId?: string | null
    payment: $Enums.Payment
    amount: number
    purchaseAt?: Date | string
    platform: $Enums.IncomeChannel
    cashStatus?: boolean
    price: number
    image?: string | null
    deleted?: boolean | null
    member: MemberCreateNestedOneWithoutBillInput
    businessId: BusinessAccCreateNestedOneWithoutBillRecordInput
    store: StoreCreateNestedOneWithoutStorefrontIdInput
  }

  export type BillUncheckedCreateWithoutProductListInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cName: string
    cLastName?: string | null
    cPhone?: string | null
    cGender?: $Enums.Gender | null
    cAddress?: string | null
    cProvince?: string | null
    cPostId?: string | null
    payment: $Enums.Payment
    amount: number
    purchaseAt?: Date | string
    platform: $Enums.IncomeChannel
    cashStatus?: boolean
    price: number
    image?: string | null
    deleted?: boolean | null
    memberId: string
    businessAcc: number
    storeId: number
  }

  export type BillCreateOrConnectWithoutProductListInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutProductListInput, BillUncheckedCreateWithoutProductListInput>
  }

  export type BillCreateManyProductListInputEnvelope = {
    data: BillCreateManyProductListInput | BillCreateManyProductListInput[]
    skipDuplicates?: boolean
  }

  export type AdsCostCreateWithoutProductListInput = {
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    adsCost: Decimal | DecimalJsLike | number | string
    member: MemberCreateNestedOneWithoutAdsCostInput
    platform: PlatformCreateNestedOneWithoutPlatformIdInput
    businessId: BusinessAccCreateNestedOneWithoutAdsCostRecordInput
  }

  export type AdsCostUncheckedCreateWithoutProductListInput = {
    id?: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    adsCost: Decimal | DecimalJsLike | number | string
    memberId: string
    platformId: number
    businessAcc: number
  }

  export type AdsCostCreateOrConnectWithoutProductListInput = {
    where: AdsCostWhereUniqueInput
    create: XOR<AdsCostCreateWithoutProductListInput, AdsCostUncheckedCreateWithoutProductListInput>
  }

  export type AdsCostCreateManyProductListInputEnvelope = {
    data: AdsCostCreateManyProductListInput | AdsCostCreateManyProductListInput[]
    skipDuplicates?: boolean
  }

  export type MemberCreateWithoutProductInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMemberInput
    business?: BusinessAccCreateNestedOneWithoutAllMemberInput
    bill?: BillCreateNestedManyWithoutMemberInput
    adsCost?: AdsCostCreateNestedManyWithoutMemberInput
    expense?: ExpenseCreateNestedManyWithoutMemberInput
    platform?: PlatformCreateNestedManyWithoutMemberInput
    store?: StoreCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutProductInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    businessId?: number | null
    bill?: BillUncheckedCreateNestedManyWithoutMemberInput
    adsCost?: AdsCostUncheckedCreateNestedManyWithoutMemberInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutMemberInput
    platform?: PlatformUncheckedCreateNestedManyWithoutMemberInput
    store?: StoreUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutProductInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutProductInput, MemberUncheckedCreateWithoutProductInput>
  }

  export type BusinessAccCreateWithoutProductInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    memberId?: string | null
    user: UserCreateNestedOneWithoutBusinessInput
    AllMember?: MemberCreateNestedManyWithoutBusinessInput
    billRecord?: BillCreateNestedManyWithoutBusinessIdInput
    expenseRecord?: ExpenseCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccUncheckedCreateWithoutProductInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    userId: number
    memberId?: string | null
    AllMember?: MemberUncheckedCreateNestedManyWithoutBusinessInput
    billRecord?: BillUncheckedCreateNestedManyWithoutBusinessIdInput
    expenseRecord?: ExpenseUncheckedCreateNestedManyWithoutBusinessIdInput
    adsCostRecord?: AdsCostUncheckedCreateNestedManyWithoutBusinessIdInput
    platform?: PlatformUncheckedCreateNestedManyWithoutBusinessIdInput
    storefront?: StoreUncheckedCreateNestedManyWithoutBusinessIdInput
  }

  export type BusinessAccCreateOrConnectWithoutProductInput = {
    where: BusinessAccWhereUniqueInput
    create: XOR<BusinessAccCreateWithoutProductInput, BusinessAccUncheckedCreateWithoutProductInput>
  }

  export type BillUpsertWithWhereUniqueWithoutProductListInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutProductListInput, BillUncheckedUpdateWithoutProductListInput>
    create: XOR<BillCreateWithoutProductListInput, BillUncheckedCreateWithoutProductListInput>
  }

  export type BillUpdateWithWhereUniqueWithoutProductListInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutProductListInput, BillUncheckedUpdateWithoutProductListInput>
  }

  export type BillUpdateManyWithWhereWithoutProductListInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutProductListInput>
  }

  export type AdsCostUpsertWithWhereUniqueWithoutProductListInput = {
    where: AdsCostWhereUniqueInput
    update: XOR<AdsCostUpdateWithoutProductListInput, AdsCostUncheckedUpdateWithoutProductListInput>
    create: XOR<AdsCostCreateWithoutProductListInput, AdsCostUncheckedCreateWithoutProductListInput>
  }

  export type AdsCostUpdateWithWhereUniqueWithoutProductListInput = {
    where: AdsCostWhereUniqueInput
    data: XOR<AdsCostUpdateWithoutProductListInput, AdsCostUncheckedUpdateWithoutProductListInput>
  }

  export type AdsCostUpdateManyWithWhereWithoutProductListInput = {
    where: AdsCostScalarWhereInput
    data: XOR<AdsCostUpdateManyMutationInput, AdsCostUncheckedUpdateManyWithoutProductListInput>
  }

  export type MemberUpsertWithoutProductInput = {
    update: XOR<MemberUpdateWithoutProductInput, MemberUncheckedUpdateWithoutProductInput>
    create: XOR<MemberCreateWithoutProductInput, MemberUncheckedCreateWithoutProductInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutProductInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutProductInput, MemberUncheckedUpdateWithoutProductInput>
  }

  export type MemberUpdateWithoutProductInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMemberNestedInput
    business?: BusinessAccUpdateOneWithoutAllMemberNestedInput
    bill?: BillUpdateManyWithoutMemberNestedInput
    adsCost?: AdsCostUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUpdateManyWithoutMemberNestedInput
    platform?: PlatformUpdateManyWithoutMemberNestedInput
    store?: StoreUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutProductInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    businessId?: NullableIntFieldUpdateOperationsInput | number | null
    bill?: BillUncheckedUpdateManyWithoutMemberNestedInput
    adsCost?: AdsCostUncheckedUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutMemberNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutMemberNestedInput
    store?: StoreUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type BusinessAccUpsertWithoutProductInput = {
    update: XOR<BusinessAccUpdateWithoutProductInput, BusinessAccUncheckedUpdateWithoutProductInput>
    create: XOR<BusinessAccCreateWithoutProductInput, BusinessAccUncheckedCreateWithoutProductInput>
    where?: BusinessAccWhereInput
  }

  export type BusinessAccUpdateToOneWithWhereWithoutProductInput = {
    where?: BusinessAccWhereInput
    data: XOR<BusinessAccUpdateWithoutProductInput, BusinessAccUncheckedUpdateWithoutProductInput>
  }

  export type BusinessAccUpdateWithoutProductInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    AllMember?: MemberUpdateManyWithoutBusinessNestedInput
    billRecord?: BillUpdateManyWithoutBusinessIdNestedInput
    expenseRecord?: ExpenseUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUpdateManyWithoutBusinessIdNestedInput
  }

  export type BusinessAccUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    userId?: IntFieldUpdateOperationsInput | number
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    AllMember?: MemberUncheckedUpdateManyWithoutBusinessNestedInput
    billRecord?: BillUncheckedUpdateManyWithoutBusinessIdNestedInput
    expenseRecord?: ExpenseUncheckedUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUncheckedUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUncheckedUpdateManyWithoutBusinessIdNestedInput
  }

  export type UserCreateWithoutOwnerInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccCreateNestedManyWithoutUserInput
    member?: MemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    sentMessages?: InboxCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxCreateNestedManyWithoutReceiverInput
    seller?: ShopCreateNestedManyWithoutSellerInput
    buyer?: ShopCreateNestedManyWithoutBuyerInput
    Order?: OrderCreateNestedManyWithoutBuyerInput
    review?: ReviewCreateNestedManyWithoutUserInput
    credit?: CreditCreateNestedManyWithoutCreditorInput
  }

  export type UserUncheckedCreateWithoutOwnerInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccUncheckedCreateNestedManyWithoutUserInput
    member?: MemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: InboxUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxUncheckedCreateNestedManyWithoutReceiverInput
    seller?: ShopUncheckedCreateNestedManyWithoutSellerInput
    buyer?: ShopUncheckedCreateNestedManyWithoutBuyerInput
    Order?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    credit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
  }

  export type UserCreateOrConnectWithoutOwnerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnerInput, UserUncheckedCreateWithoutOwnerInput>
  }

  export type UserCreateWithoutCreditInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccCreateNestedManyWithoutUserInput
    member?: MemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    sentMessages?: InboxCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxCreateNestedManyWithoutReceiverInput
    seller?: ShopCreateNestedManyWithoutSellerInput
    buyer?: ShopCreateNestedManyWithoutBuyerInput
    Order?: OrderCreateNestedManyWithoutBuyerInput
    review?: ReviewCreateNestedManyWithoutUserInput
    owner?: CreditCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutCreditInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccUncheckedCreateNestedManyWithoutUserInput
    member?: MemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: InboxUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxUncheckedCreateNestedManyWithoutReceiverInput
    seller?: ShopUncheckedCreateNestedManyWithoutSellerInput
    buyer?: ShopUncheckedCreateNestedManyWithoutBuyerInput
    Order?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    owner?: CreditUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutCreditInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreditInput, UserUncheckedCreateWithoutCreditInput>
  }

  export type UserUpsertWithoutOwnerInput = {
    update: XOR<UserUpdateWithoutOwnerInput, UserUncheckedUpdateWithoutOwnerInput>
    create: XOR<UserCreateWithoutOwnerInput, UserUncheckedCreateWithoutOwnerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnerInput, UserUncheckedUpdateWithoutOwnerInput>
  }

  export type UserUpdateWithoutOwnerInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUpdateManyWithoutUserNestedInput
    member?: MemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUpdateManyWithoutReceiverNestedInput
    seller?: ShopUpdateManyWithoutSellerNestedInput
    buyer?: ShopUpdateManyWithoutBuyerNestedInput
    Order?: OrderUpdateManyWithoutBuyerNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    credit?: CreditUpdateManyWithoutCreditorNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUncheckedUpdateManyWithoutUserNestedInput
    member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUncheckedUpdateManyWithoutReceiverNestedInput
    seller?: ShopUncheckedUpdateManyWithoutSellerNestedInput
    buyer?: ShopUncheckedUpdateManyWithoutBuyerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    credit?: CreditUncheckedUpdateManyWithoutCreditorNestedInput
  }

  export type UserUpsertWithoutCreditInput = {
    update: XOR<UserUpdateWithoutCreditInput, UserUncheckedUpdateWithoutCreditInput>
    create: XOR<UserCreateWithoutCreditInput, UserUncheckedCreateWithoutCreditInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreditInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreditInput, UserUncheckedUpdateWithoutCreditInput>
  }

  export type UserUpdateWithoutCreditInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUpdateManyWithoutUserNestedInput
    member?: MemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUpdateManyWithoutReceiverNestedInput
    seller?: ShopUpdateManyWithoutSellerNestedInput
    buyer?: ShopUpdateManyWithoutBuyerNestedInput
    Order?: OrderUpdateManyWithoutBuyerNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    owner?: CreditUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreditInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUncheckedUpdateManyWithoutUserNestedInput
    member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUncheckedUpdateManyWithoutReceiverNestedInput
    seller?: ShopUncheckedUpdateManyWithoutSellerNestedInput
    buyer?: ShopUncheckedUpdateManyWithoutBuyerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    owner?: CreditUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateWithoutPostsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccCreateNestedManyWithoutUserInput
    member?: MemberCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    sentMessages?: InboxCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxCreateNestedManyWithoutReceiverInput
    seller?: ShopCreateNestedManyWithoutSellerInput
    buyer?: ShopCreateNestedManyWithoutBuyerInput
    Order?: OrderCreateNestedManyWithoutBuyerInput
    review?: ReviewCreateNestedManyWithoutUserInput
    owner?: CreditCreateNestedManyWithoutOwnerInput
    credit?: CreditCreateNestedManyWithoutCreditorInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccUncheckedCreateNestedManyWithoutUserInput
    member?: MemberUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: InboxUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxUncheckedCreateNestedManyWithoutReceiverInput
    seller?: ShopUncheckedCreateNestedManyWithoutSellerInput
    buyer?: ShopUncheckedCreateNestedManyWithoutBuyerInput
    Order?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    owner?: CreditUncheckedCreateNestedManyWithoutOwnerInput
    credit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type ReactionCreateWithoutPostInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ReactionType
    user: UserCreateNestedOneWithoutReactionsInput
  }

  export type ReactionUncheckedCreateWithoutPostInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ReactionType
    userId: number
  }

  export type ReactionCreateOrConnectWithoutPostInput = {
    where: ReactionWhereUniqueInput
    create: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput>
  }

  export type ReactionCreateManyPostInputEnvelope = {
    data: ReactionCreateManyPostInput | ReactionCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutPostInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    deleted?: boolean | null
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    userId: number
    deleted?: boolean | null
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUpdateManyWithoutUserNestedInput
    member?: MemberUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUpdateManyWithoutReceiverNestedInput
    seller?: ShopUpdateManyWithoutSellerNestedInput
    buyer?: ShopUpdateManyWithoutBuyerNestedInput
    Order?: OrderUpdateManyWithoutBuyerNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    owner?: CreditUpdateManyWithoutOwnerNestedInput
    credit?: CreditUpdateManyWithoutCreditorNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUncheckedUpdateManyWithoutUserNestedInput
    member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUncheckedUpdateManyWithoutReceiverNestedInput
    seller?: ShopUncheckedUpdateManyWithoutSellerNestedInput
    buyer?: ShopUncheckedUpdateManyWithoutBuyerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    owner?: CreditUncheckedUpdateManyWithoutOwnerNestedInput
    credit?: CreditUncheckedUpdateManyWithoutCreditorNestedInput
  }

  export type ReactionUpsertWithWhereUniqueWithoutPostInput = {
    where: ReactionWhereUniqueInput
    update: XOR<ReactionUpdateWithoutPostInput, ReactionUncheckedUpdateWithoutPostInput>
    create: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput>
  }

  export type ReactionUpdateWithWhereUniqueWithoutPostInput = {
    where: ReactionWhereUniqueInput
    data: XOR<ReactionUpdateWithoutPostInput, ReactionUncheckedUpdateWithoutPostInput>
  }

  export type ReactionUpdateManyWithWhereWithoutPostInput = {
    where: ReactionScalarWhereInput
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyWithoutPostInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type PostCreateWithoutReactionsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    hashtag?: PostCreatehashtagInput | string[]
    content?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.MediaType | null
    published?: boolean
    deleted?: boolean | null
    author: UserCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutReactionsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hashtag?: PostCreatehashtagInput | string[]
    content?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.MediaType | null
    published?: boolean
    authorId: number
    deleted?: boolean | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutReactionsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
  }

  export type UserCreateWithoutReactionsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccCreateNestedManyWithoutUserInput
    member?: MemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    sentMessages?: InboxCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxCreateNestedManyWithoutReceiverInput
    seller?: ShopCreateNestedManyWithoutSellerInput
    buyer?: ShopCreateNestedManyWithoutBuyerInput
    Order?: OrderCreateNestedManyWithoutBuyerInput
    review?: ReviewCreateNestedManyWithoutUserInput
    owner?: CreditCreateNestedManyWithoutOwnerInput
    credit?: CreditCreateNestedManyWithoutCreditorInput
  }

  export type UserUncheckedCreateWithoutReactionsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccUncheckedCreateNestedManyWithoutUserInput
    member?: MemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: InboxUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxUncheckedCreateNestedManyWithoutReceiverInput
    seller?: ShopUncheckedCreateNestedManyWithoutSellerInput
    buyer?: ShopUncheckedCreateNestedManyWithoutBuyerInput
    Order?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    owner?: CreditUncheckedCreateNestedManyWithoutOwnerInput
    credit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
  }

  export type UserCreateOrConnectWithoutReactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReactionsInput, UserUncheckedCreateWithoutReactionsInput>
  }

  export type PostUpsertWithoutReactionsInput = {
    update: XOR<PostUpdateWithoutReactionsInput, PostUncheckedUpdateWithoutReactionsInput>
    create: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutReactionsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutReactionsInput, PostUncheckedUpdateWithoutReactionsInput>
  }

  export type PostUpdateWithoutReactionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtag?: PostUpdatehashtagInput | string[]
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    published?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtag?: PostUpdatehashtagInput | string[]
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    published?: BoolFieldUpdateOperationsInput | boolean
    authorId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutReactionsInput = {
    update: XOR<UserUpdateWithoutReactionsInput, UserUncheckedUpdateWithoutReactionsInput>
    create: XOR<UserCreateWithoutReactionsInput, UserUncheckedCreateWithoutReactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReactionsInput, UserUncheckedUpdateWithoutReactionsInput>
  }

  export type UserUpdateWithoutReactionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUpdateManyWithoutUserNestedInput
    member?: MemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUpdateManyWithoutReceiverNestedInput
    seller?: ShopUpdateManyWithoutSellerNestedInput
    buyer?: ShopUpdateManyWithoutBuyerNestedInput
    Order?: OrderUpdateManyWithoutBuyerNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    owner?: CreditUpdateManyWithoutOwnerNestedInput
    credit?: CreditUpdateManyWithoutCreditorNestedInput
  }

  export type UserUncheckedUpdateWithoutReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUncheckedUpdateManyWithoutUserNestedInput
    member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUncheckedUpdateManyWithoutReceiverNestedInput
    seller?: ShopUncheckedUpdateManyWithoutSellerNestedInput
    buyer?: ShopUncheckedUpdateManyWithoutBuyerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    owner?: CreditUncheckedUpdateManyWithoutOwnerNestedInput
    credit?: CreditUncheckedUpdateManyWithoutCreditorNestedInput
  }

  export type PostCreateWithoutCommentsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    hashtag?: PostCreatehashtagInput | string[]
    content?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.MediaType | null
    published?: boolean
    deleted?: boolean | null
    author: UserCreateNestedOneWithoutPostsInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hashtag?: PostCreatehashtagInput | string[]
    content?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.MediaType | null
    published?: boolean
    authorId: number
    deleted?: boolean | null
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccCreateNestedManyWithoutUserInput
    member?: MemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    sentMessages?: InboxCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxCreateNestedManyWithoutReceiverInput
    seller?: ShopCreateNestedManyWithoutSellerInput
    buyer?: ShopCreateNestedManyWithoutBuyerInput
    Order?: OrderCreateNestedManyWithoutBuyerInput
    review?: ReviewCreateNestedManyWithoutUserInput
    owner?: CreditCreateNestedManyWithoutOwnerInput
    credit?: CreditCreateNestedManyWithoutCreditorInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccUncheckedCreateNestedManyWithoutUserInput
    member?: MemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: InboxUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxUncheckedCreateNestedManyWithoutReceiverInput
    seller?: ShopUncheckedCreateNestedManyWithoutSellerInput
    buyer?: ShopUncheckedCreateNestedManyWithoutBuyerInput
    Order?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    owner?: CreditUncheckedCreateNestedManyWithoutOwnerInput
    credit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtag?: PostUpdatehashtagInput | string[]
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    published?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtag?: PostUpdatehashtagInput | string[]
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    published?: BoolFieldUpdateOperationsInput | boolean
    authorId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUpdateManyWithoutUserNestedInput
    member?: MemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUpdateManyWithoutReceiverNestedInput
    seller?: ShopUpdateManyWithoutSellerNestedInput
    buyer?: ShopUpdateManyWithoutBuyerNestedInput
    Order?: OrderUpdateManyWithoutBuyerNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    owner?: CreditUpdateManyWithoutOwnerNestedInput
    credit?: CreditUpdateManyWithoutCreditorNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUncheckedUpdateManyWithoutUserNestedInput
    member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUncheckedUpdateManyWithoutReceiverNestedInput
    seller?: ShopUncheckedUpdateManyWithoutSellerNestedInput
    buyer?: ShopUncheckedUpdateManyWithoutBuyerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    owner?: CreditUncheckedUpdateManyWithoutOwnerNestedInput
    credit?: CreditUncheckedUpdateManyWithoutCreditorNestedInput
  }

  export type UserCreateWithoutSentMessagesInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccCreateNestedManyWithoutUserInput
    member?: MemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    receivedMessages?: InboxCreateNestedManyWithoutReceiverInput
    seller?: ShopCreateNestedManyWithoutSellerInput
    buyer?: ShopCreateNestedManyWithoutBuyerInput
    Order?: OrderCreateNestedManyWithoutBuyerInput
    review?: ReviewCreateNestedManyWithoutUserInput
    owner?: CreditCreateNestedManyWithoutOwnerInput
    credit?: CreditCreateNestedManyWithoutCreditorInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccUncheckedCreateNestedManyWithoutUserInput
    member?: MemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    receivedMessages?: InboxUncheckedCreateNestedManyWithoutReceiverInput
    seller?: ShopUncheckedCreateNestedManyWithoutSellerInput
    buyer?: ShopUncheckedCreateNestedManyWithoutBuyerInput
    Order?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    owner?: CreditUncheckedCreateNestedManyWithoutOwnerInput
    credit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccCreateNestedManyWithoutUserInput
    member?: MemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    sentMessages?: InboxCreateNestedManyWithoutSenderInput
    seller?: ShopCreateNestedManyWithoutSellerInput
    buyer?: ShopCreateNestedManyWithoutBuyerInput
    Order?: OrderCreateNestedManyWithoutBuyerInput
    review?: ReviewCreateNestedManyWithoutUserInput
    owner?: CreditCreateNestedManyWithoutOwnerInput
    credit?: CreditCreateNestedManyWithoutCreditorInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccUncheckedCreateNestedManyWithoutUserInput
    member?: MemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: InboxUncheckedCreateNestedManyWithoutSenderInput
    seller?: ShopUncheckedCreateNestedManyWithoutSellerInput
    buyer?: ShopUncheckedCreateNestedManyWithoutBuyerInput
    Order?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    owner?: CreditUncheckedCreateNestedManyWithoutOwnerInput
    credit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUpdateManyWithoutUserNestedInput
    member?: MemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    receivedMessages?: InboxUpdateManyWithoutReceiverNestedInput
    seller?: ShopUpdateManyWithoutSellerNestedInput
    buyer?: ShopUpdateManyWithoutBuyerNestedInput
    Order?: OrderUpdateManyWithoutBuyerNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    owner?: CreditUpdateManyWithoutOwnerNestedInput
    credit?: CreditUpdateManyWithoutCreditorNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUncheckedUpdateManyWithoutUserNestedInput
    member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    receivedMessages?: InboxUncheckedUpdateManyWithoutReceiverNestedInput
    seller?: ShopUncheckedUpdateManyWithoutSellerNestedInput
    buyer?: ShopUncheckedUpdateManyWithoutBuyerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    owner?: CreditUncheckedUpdateManyWithoutOwnerNestedInput
    credit?: CreditUncheckedUpdateManyWithoutCreditorNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUpdateManyWithoutUserNestedInput
    member?: MemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUpdateManyWithoutSenderNestedInput
    seller?: ShopUpdateManyWithoutSellerNestedInput
    buyer?: ShopUpdateManyWithoutBuyerNestedInput
    Order?: OrderUpdateManyWithoutBuyerNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    owner?: CreditUpdateManyWithoutOwnerNestedInput
    credit?: CreditUpdateManyWithoutCreditorNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUncheckedUpdateManyWithoutUserNestedInput
    member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUncheckedUpdateManyWithoutSenderNestedInput
    seller?: ShopUncheckedUpdateManyWithoutSellerNestedInput
    buyer?: ShopUncheckedUpdateManyWithoutBuyerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    owner?: CreditUncheckedUpdateManyWithoutOwnerNestedInput
    credit?: CreditUncheckedUpdateManyWithoutCreditorNestedInput
  }

  export type UserCreateWithoutSellerInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccCreateNestedManyWithoutUserInput
    member?: MemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    sentMessages?: InboxCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxCreateNestedManyWithoutReceiverInput
    buyer?: ShopCreateNestedManyWithoutBuyerInput
    Order?: OrderCreateNestedManyWithoutBuyerInput
    review?: ReviewCreateNestedManyWithoutUserInput
    owner?: CreditCreateNestedManyWithoutOwnerInput
    credit?: CreditCreateNestedManyWithoutCreditorInput
  }

  export type UserUncheckedCreateWithoutSellerInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccUncheckedCreateNestedManyWithoutUserInput
    member?: MemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: InboxUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxUncheckedCreateNestedManyWithoutReceiverInput
    buyer?: ShopUncheckedCreateNestedManyWithoutBuyerInput
    Order?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    owner?: CreditUncheckedCreateNestedManyWithoutOwnerInput
    credit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
  }

  export type UserCreateOrConnectWithoutSellerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSellerInput, UserUncheckedCreateWithoutSellerInput>
  }

  export type UserCreateWithoutBuyerInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccCreateNestedManyWithoutUserInput
    member?: MemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    sentMessages?: InboxCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxCreateNestedManyWithoutReceiverInput
    seller?: ShopCreateNestedManyWithoutSellerInput
    Order?: OrderCreateNestedManyWithoutBuyerInput
    review?: ReviewCreateNestedManyWithoutUserInput
    owner?: CreditCreateNestedManyWithoutOwnerInput
    credit?: CreditCreateNestedManyWithoutCreditorInput
  }

  export type UserUncheckedCreateWithoutBuyerInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccUncheckedCreateNestedManyWithoutUserInput
    member?: MemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: InboxUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxUncheckedCreateNestedManyWithoutReceiverInput
    seller?: ShopUncheckedCreateNestedManyWithoutSellerInput
    Order?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    owner?: CreditUncheckedCreateNestedManyWithoutOwnerInput
    credit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
  }

  export type UserCreateOrConnectWithoutBuyerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuyerInput, UserUncheckedCreateWithoutBuyerInput>
  }

  export type OrderCreateWithoutSellerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity: number
    buyerId: number
    deleted?: boolean | null
    buyer: UserCreateNestedOneWithoutOrderInput
    review?: ReviewCreateNestedOneWithoutOrderInput
    cart?: CartCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutSellerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity: number
    buyerId: number
    sellerId: number
    deleted?: boolean | null
    review?: ReviewUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutSellerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutSellerInput, OrderUncheckedCreateWithoutSellerInput>
  }

  export type OptionCreateWithoutShopInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: $Enums.OptionName
    values?: OptionValueCreateNestedManyWithoutOptionInput
  }

  export type OptionUncheckedCreateWithoutShopInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: $Enums.OptionName
    values?: OptionValueUncheckedCreateNestedManyWithoutOptionInput
  }

  export type OptionCreateOrConnectWithoutShopInput = {
    where: OptionWhereUniqueInput
    create: XOR<OptionCreateWithoutShopInput, OptionUncheckedCreateWithoutShopInput>
  }

  export type OptionCreateManyShopInputEnvelope = {
    data: OptionCreateManyShopInput | OptionCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutShopInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    rating: number
    order: OrderCreateNestedOneWithoutReviewInput
    user: UserCreateNestedOneWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutShopInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    rating: number
    userId: number
    orderId: number
  }

  export type ReviewCreateOrConnectWithoutShopInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutShopInput, ReviewUncheckedCreateWithoutShopInput>
  }

  export type ReviewCreateManyShopInputEnvelope = {
    data: ReviewCreateManyShopInput | ReviewCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSellerInput = {
    update: XOR<UserUpdateWithoutSellerInput, UserUncheckedUpdateWithoutSellerInput>
    create: XOR<UserCreateWithoutSellerInput, UserUncheckedCreateWithoutSellerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSellerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSellerInput, UserUncheckedUpdateWithoutSellerInput>
  }

  export type UserUpdateWithoutSellerInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUpdateManyWithoutUserNestedInput
    member?: MemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUpdateManyWithoutReceiverNestedInput
    buyer?: ShopUpdateManyWithoutBuyerNestedInput
    Order?: OrderUpdateManyWithoutBuyerNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    owner?: CreditUpdateManyWithoutOwnerNestedInput
    credit?: CreditUpdateManyWithoutCreditorNestedInput
  }

  export type UserUncheckedUpdateWithoutSellerInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUncheckedUpdateManyWithoutUserNestedInput
    member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUncheckedUpdateManyWithoutReceiverNestedInput
    buyer?: ShopUncheckedUpdateManyWithoutBuyerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    owner?: CreditUncheckedUpdateManyWithoutOwnerNestedInput
    credit?: CreditUncheckedUpdateManyWithoutCreditorNestedInput
  }

  export type UserUpsertWithoutBuyerInput = {
    update: XOR<UserUpdateWithoutBuyerInput, UserUncheckedUpdateWithoutBuyerInput>
    create: XOR<UserCreateWithoutBuyerInput, UserUncheckedCreateWithoutBuyerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBuyerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBuyerInput, UserUncheckedUpdateWithoutBuyerInput>
  }

  export type UserUpdateWithoutBuyerInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUpdateManyWithoutUserNestedInput
    member?: MemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUpdateManyWithoutReceiverNestedInput
    seller?: ShopUpdateManyWithoutSellerNestedInput
    Order?: OrderUpdateManyWithoutBuyerNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    owner?: CreditUpdateManyWithoutOwnerNestedInput
    credit?: CreditUpdateManyWithoutCreditorNestedInput
  }

  export type UserUncheckedUpdateWithoutBuyerInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUncheckedUpdateManyWithoutUserNestedInput
    member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUncheckedUpdateManyWithoutReceiverNestedInput
    seller?: ShopUncheckedUpdateManyWithoutSellerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    owner?: CreditUncheckedUpdateManyWithoutOwnerNestedInput
    credit?: CreditUncheckedUpdateManyWithoutCreditorNestedInput
  }

  export type OrderUpsertWithoutSellerInput = {
    update: XOR<OrderUpdateWithoutSellerInput, OrderUncheckedUpdateWithoutSellerInput>
    create: XOR<OrderCreateWithoutSellerInput, OrderUncheckedCreateWithoutSellerInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutSellerInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutSellerInput, OrderUncheckedUpdateWithoutSellerInput>
  }

  export type OrderUpdateWithoutSellerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    buyer?: UserUpdateOneRequiredWithoutOrderNestedInput
    review?: ReviewUpdateOneWithoutOrderNestedInput
    cart?: CartUpdateOneRequiredWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutSellerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    review?: ReviewUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OptionUpsertWithWhereUniqueWithoutShopInput = {
    where: OptionWhereUniqueInput
    update: XOR<OptionUpdateWithoutShopInput, OptionUncheckedUpdateWithoutShopInput>
    create: XOR<OptionCreateWithoutShopInput, OptionUncheckedCreateWithoutShopInput>
  }

  export type OptionUpdateWithWhereUniqueWithoutShopInput = {
    where: OptionWhereUniqueInput
    data: XOR<OptionUpdateWithoutShopInput, OptionUncheckedUpdateWithoutShopInput>
  }

  export type OptionUpdateManyWithWhereWithoutShopInput = {
    where: OptionScalarWhereInput
    data: XOR<OptionUpdateManyMutationInput, OptionUncheckedUpdateManyWithoutShopInput>
  }

  export type OptionScalarWhereInput = {
    AND?: OptionScalarWhereInput | OptionScalarWhereInput[]
    OR?: OptionScalarWhereInput[]
    NOT?: OptionScalarWhereInput | OptionScalarWhereInput[]
    id?: IntFilter<"Option"> | number
    createdAt?: DateTimeFilter<"Option"> | Date | string
    updatedAt?: DateTimeFilter<"Option"> | Date | string
    name?: EnumOptionNameFilter<"Option"> | $Enums.OptionName
    shopId?: IntFilter<"Option"> | number
  }

  export type ReviewUpsertWithWhereUniqueWithoutShopInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutShopInput, ReviewUncheckedUpdateWithoutShopInput>
    create: XOR<ReviewCreateWithoutShopInput, ReviewUncheckedCreateWithoutShopInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutShopInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutShopInput, ReviewUncheckedUpdateWithoutShopInput>
  }

  export type ReviewUpdateManyWithWhereWithoutShopInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutShopInput>
  }

  export type ShopCreateWithoutOrdersInput = {
    name: string
    description?: string | null
    productType?: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: $Enums.Category
    deleted?: boolean | null
    seller: UserCreateNestedOneWithoutSellerInput
    buyer: UserCreateNestedOneWithoutBuyerInput
    options?: OptionCreateNestedManyWithoutShopInput
    review?: ReviewCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutOrdersInput = {
    id?: number
    name: string
    description?: string | null
    productType?: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: $Enums.Category
    sellerId: number
    buyerId: number
    deleted?: boolean | null
    options?: OptionUncheckedCreateNestedManyWithoutShopInput
    review?: ReviewUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutOrdersInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutOrdersInput, ShopUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutOrderInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccCreateNestedManyWithoutUserInput
    member?: MemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    sentMessages?: InboxCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxCreateNestedManyWithoutReceiverInput
    seller?: ShopCreateNestedManyWithoutSellerInput
    buyer?: ShopCreateNestedManyWithoutBuyerInput
    review?: ReviewCreateNestedManyWithoutUserInput
    owner?: CreditCreateNestedManyWithoutOwnerInput
    credit?: CreditCreateNestedManyWithoutCreditorInput
  }

  export type UserUncheckedCreateWithoutOrderInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccUncheckedCreateNestedManyWithoutUserInput
    member?: MemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: InboxUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxUncheckedCreateNestedManyWithoutReceiverInput
    seller?: ShopUncheckedCreateNestedManyWithoutSellerInput
    buyer?: ShopUncheckedCreateNestedManyWithoutBuyerInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    owner?: CreditUncheckedCreateNestedManyWithoutOwnerInput
    credit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
  }

  export type UserCreateOrConnectWithoutOrderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
  }

  export type ReviewCreateWithoutOrderInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    rating: number
    user: UserCreateNestedOneWithoutReviewInput
    shop: ShopCreateNestedOneWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutOrderInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    rating: number
    shopId: number
    userId: number
  }

  export type ReviewCreateOrConnectWithoutOrderInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
  }

  export type CartCreateWithoutOrderInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId: number
    payment: $Enums.Payment
    status: string
    total: number
  }

  export type CartUncheckedCreateWithoutOrderInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId: number
    payment: $Enums.Payment
    status: string
    total: number
  }

  export type CartCreateOrConnectWithoutOrderInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutOrderInput, CartUncheckedCreateWithoutOrderInput>
  }

  export type ShopUpsertWithoutOrdersInput = {
    update: XOR<ShopUpdateWithoutOrdersInput, ShopUncheckedUpdateWithoutOrdersInput>
    create: XOR<ShopCreateWithoutOrdersInput, ShopUncheckedCreateWithoutOrdersInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutOrdersInput, ShopUncheckedUpdateWithoutOrdersInput>
  }

  export type ShopUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seller?: UserUpdateOneRequiredWithoutSellerNestedInput
    buyer?: UserUpdateOneRequiredWithoutBuyerNestedInput
    options?: OptionUpdateManyWithoutShopNestedInput
    review?: ReviewUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    sellerId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    options?: OptionUncheckedUpdateManyWithoutShopNestedInput
    review?: ReviewUncheckedUpdateManyWithoutShopNestedInput
  }

  export type UserUpsertWithoutOrderInput = {
    update: XOR<UserUpdateWithoutOrderInput, UserUncheckedUpdateWithoutOrderInput>
    create: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrderInput, UserUncheckedUpdateWithoutOrderInput>
  }

  export type UserUpdateWithoutOrderInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUpdateManyWithoutUserNestedInput
    member?: MemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUpdateManyWithoutReceiverNestedInput
    seller?: ShopUpdateManyWithoutSellerNestedInput
    buyer?: ShopUpdateManyWithoutBuyerNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    owner?: CreditUpdateManyWithoutOwnerNestedInput
    credit?: CreditUpdateManyWithoutCreditorNestedInput
  }

  export type UserUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUncheckedUpdateManyWithoutUserNestedInput
    member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUncheckedUpdateManyWithoutReceiverNestedInput
    seller?: ShopUncheckedUpdateManyWithoutSellerNestedInput
    buyer?: ShopUncheckedUpdateManyWithoutBuyerNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    owner?: CreditUncheckedUpdateManyWithoutOwnerNestedInput
    credit?: CreditUncheckedUpdateManyWithoutCreditorNestedInput
  }

  export type ReviewUpsertWithoutOrderInput = {
    update: XOR<ReviewUpdateWithoutOrderInput, ReviewUncheckedUpdateWithoutOrderInput>
    create: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutOrderInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutOrderInput, ReviewUncheckedUpdateWithoutOrderInput>
  }

  export type ReviewUpdateWithoutOrderInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutReviewNestedInput
    shop?: ShopUpdateOneRequiredWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CartUpsertWithoutOrderInput = {
    update: XOR<CartUpdateWithoutOrderInput, CartUncheckedUpdateWithoutOrderInput>
    create: XOR<CartCreateWithoutOrderInput, CartUncheckedCreateWithoutOrderInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutOrderInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutOrderInput, CartUncheckedUpdateWithoutOrderInput>
  }

  export type CartUpdateWithoutOrderInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: IntFieldUpdateOperationsInput | number
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    status?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
  }

  export type CartUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: IntFieldUpdateOperationsInput | number
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    status?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
  }

  export type ShopCreateWithoutOptionsInput = {
    name: string
    description?: string | null
    productType?: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: $Enums.Category
    deleted?: boolean | null
    seller: UserCreateNestedOneWithoutSellerInput
    buyer: UserCreateNestedOneWithoutBuyerInput
    orders?: OrderCreateNestedOneWithoutSellerInput
    review?: ReviewCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutOptionsInput = {
    id?: number
    name: string
    description?: string | null
    productType?: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: $Enums.Category
    sellerId: number
    buyerId: number
    deleted?: boolean | null
    orders?: OrderUncheckedCreateNestedOneWithoutSellerInput
    review?: ReviewUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutOptionsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutOptionsInput, ShopUncheckedCreateWithoutOptionsInput>
  }

  export type OptionValueCreateWithoutOptionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    value: string
    price?: number | null
    interest?: number | null
    duration?: number | null
  }

  export type OptionValueUncheckedCreateWithoutOptionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    value: string
    price?: number | null
    interest?: number | null
    duration?: number | null
  }

  export type OptionValueCreateOrConnectWithoutOptionInput = {
    where: OptionValueWhereUniqueInput
    create: XOR<OptionValueCreateWithoutOptionInput, OptionValueUncheckedCreateWithoutOptionInput>
  }

  export type OptionValueCreateManyOptionInputEnvelope = {
    data: OptionValueCreateManyOptionInput | OptionValueCreateManyOptionInput[]
    skipDuplicates?: boolean
  }

  export type ShopUpsertWithoutOptionsInput = {
    update: XOR<ShopUpdateWithoutOptionsInput, ShopUncheckedUpdateWithoutOptionsInput>
    create: XOR<ShopCreateWithoutOptionsInput, ShopUncheckedCreateWithoutOptionsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutOptionsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutOptionsInput, ShopUncheckedUpdateWithoutOptionsInput>
  }

  export type ShopUpdateWithoutOptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seller?: UserUpdateOneRequiredWithoutSellerNestedInput
    buyer?: UserUpdateOneRequiredWithoutBuyerNestedInput
    orders?: OrderUpdateOneWithoutSellerNestedInput
    review?: ReviewUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    sellerId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orders?: OrderUncheckedUpdateOneWithoutSellerNestedInput
    review?: ReviewUncheckedUpdateManyWithoutShopNestedInput
  }

  export type OptionValueUpsertWithWhereUniqueWithoutOptionInput = {
    where: OptionValueWhereUniqueInput
    update: XOR<OptionValueUpdateWithoutOptionInput, OptionValueUncheckedUpdateWithoutOptionInput>
    create: XOR<OptionValueCreateWithoutOptionInput, OptionValueUncheckedCreateWithoutOptionInput>
  }

  export type OptionValueUpdateWithWhereUniqueWithoutOptionInput = {
    where: OptionValueWhereUniqueInput
    data: XOR<OptionValueUpdateWithoutOptionInput, OptionValueUncheckedUpdateWithoutOptionInput>
  }

  export type OptionValueUpdateManyWithWhereWithoutOptionInput = {
    where: OptionValueScalarWhereInput
    data: XOR<OptionValueUpdateManyMutationInput, OptionValueUncheckedUpdateManyWithoutOptionInput>
  }

  export type OptionValueScalarWhereInput = {
    AND?: OptionValueScalarWhereInput | OptionValueScalarWhereInput[]
    OR?: OptionValueScalarWhereInput[]
    NOT?: OptionValueScalarWhereInput | OptionValueScalarWhereInput[]
    id?: IntFilter<"OptionValue"> | number
    createdAt?: DateTimeFilter<"OptionValue"> | Date | string
    updatedAt?: DateTimeFilter<"OptionValue"> | Date | string
    value?: StringFilter<"OptionValue"> | string
    price?: FloatNullableFilter<"OptionValue"> | number | null
    interest?: FloatNullableFilter<"OptionValue"> | number | null
    duration?: IntNullableFilter<"OptionValue"> | number | null
    optionId?: IntFilter<"OptionValue"> | number
  }

  export type OptionCreateWithoutValuesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: $Enums.OptionName
    shop: ShopCreateNestedOneWithoutOptionsInput
  }

  export type OptionUncheckedCreateWithoutValuesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: $Enums.OptionName
    shopId: number
  }

  export type OptionCreateOrConnectWithoutValuesInput = {
    where: OptionWhereUniqueInput
    create: XOR<OptionCreateWithoutValuesInput, OptionUncheckedCreateWithoutValuesInput>
  }

  export type OptionUpsertWithoutValuesInput = {
    update: XOR<OptionUpdateWithoutValuesInput, OptionUncheckedUpdateWithoutValuesInput>
    create: XOR<OptionCreateWithoutValuesInput, OptionUncheckedCreateWithoutValuesInput>
    where?: OptionWhereInput
  }

  export type OptionUpdateToOneWithWhereWithoutValuesInput = {
    where?: OptionWhereInput
    data: XOR<OptionUpdateWithoutValuesInput, OptionUncheckedUpdateWithoutValuesInput>
  }

  export type OptionUpdateWithoutValuesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: EnumOptionNameFieldUpdateOperationsInput | $Enums.OptionName
    shop?: ShopUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type OptionUncheckedUpdateWithoutValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: EnumOptionNameFieldUpdateOperationsInput | $Enums.OptionName
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderCreateWithoutReviewInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity: number
    buyerId: number
    deleted?: boolean | null
    seller: ShopCreateNestedOneWithoutOrdersInput
    buyer: UserCreateNestedOneWithoutOrderInput
    cart?: CartCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutReviewInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity: number
    shopId: number
    buyerId: number
    sellerId: number
    deleted?: boolean | null
  }

  export type OrderCreateOrConnectWithoutReviewInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutReviewInput, OrderUncheckedCreateWithoutReviewInput>
  }

  export type UserCreateWithoutReviewInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccCreateNestedManyWithoutUserInput
    member?: MemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    sentMessages?: InboxCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxCreateNestedManyWithoutReceiverInput
    seller?: ShopCreateNestedManyWithoutSellerInput
    buyer?: ShopCreateNestedManyWithoutBuyerInput
    Order?: OrderCreateNestedManyWithoutBuyerInput
    owner?: CreditCreateNestedManyWithoutOwnerInput
    credit?: CreditCreateNestedManyWithoutCreditorInput
  }

  export type UserUncheckedCreateWithoutReviewInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone: string
    username?: string | null
    bio?: string | null
    business?: BusinessAccUncheckedCreateNestedManyWithoutUserInput
    member?: MemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: InboxUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: InboxUncheckedCreateNestedManyWithoutReceiverInput
    seller?: ShopUncheckedCreateNestedManyWithoutSellerInput
    buyer?: ShopUncheckedCreateNestedManyWithoutBuyerInput
    Order?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    owner?: CreditUncheckedCreateNestedManyWithoutOwnerInput
    credit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
  }

  export type UserCreateOrConnectWithoutReviewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
  }

  export type ShopCreateWithoutReviewInput = {
    name: string
    description?: string | null
    productType?: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: $Enums.Category
    deleted?: boolean | null
    seller: UserCreateNestedOneWithoutSellerInput
    buyer: UserCreateNestedOneWithoutBuyerInput
    orders?: OrderCreateNestedOneWithoutSellerInput
    options?: OptionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutReviewInput = {
    id?: number
    name: string
    description?: string | null
    productType?: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: $Enums.Category
    sellerId: number
    buyerId: number
    deleted?: boolean | null
    orders?: OrderUncheckedCreateNestedOneWithoutSellerInput
    options?: OptionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutReviewInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutReviewInput, ShopUncheckedCreateWithoutReviewInput>
  }

  export type OrderUpsertWithoutReviewInput = {
    update: XOR<OrderUpdateWithoutReviewInput, OrderUncheckedUpdateWithoutReviewInput>
    create: XOR<OrderCreateWithoutReviewInput, OrderUncheckedCreateWithoutReviewInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutReviewInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutReviewInput, OrderUncheckedUpdateWithoutReviewInput>
  }

  export type OrderUpdateWithoutReviewInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seller?: ShopUpdateOneRequiredWithoutOrdersNestedInput
    buyer?: UserUpdateOneRequiredWithoutOrderNestedInput
    cart?: CartUpdateOneRequiredWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserUpsertWithoutReviewInput = {
    update: XOR<UserUpdateWithoutReviewInput, UserUncheckedUpdateWithoutReviewInput>
    create: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewInput, UserUncheckedUpdateWithoutReviewInput>
  }

  export type UserUpdateWithoutReviewInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUpdateManyWithoutUserNestedInput
    member?: MemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUpdateManyWithoutReceiverNestedInput
    seller?: ShopUpdateManyWithoutSellerNestedInput
    buyer?: ShopUpdateManyWithoutBuyerNestedInput
    Order?: OrderUpdateManyWithoutBuyerNestedInput
    owner?: CreditUpdateManyWithoutOwnerNestedInput
    credit?: CreditUpdateManyWithoutCreditorNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessAccUncheckedUpdateManyWithoutUserNestedInput
    member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: InboxUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: InboxUncheckedUpdateManyWithoutReceiverNestedInput
    seller?: ShopUncheckedUpdateManyWithoutSellerNestedInput
    buyer?: ShopUncheckedUpdateManyWithoutBuyerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    owner?: CreditUncheckedUpdateManyWithoutOwnerNestedInput
    credit?: CreditUncheckedUpdateManyWithoutCreditorNestedInput
  }

  export type ShopUpsertWithoutReviewInput = {
    update: XOR<ShopUpdateWithoutReviewInput, ShopUncheckedUpdateWithoutReviewInput>
    create: XOR<ShopCreateWithoutReviewInput, ShopUncheckedCreateWithoutReviewInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutReviewInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutReviewInput, ShopUncheckedUpdateWithoutReviewInput>
  }

  export type ShopUpdateWithoutReviewInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seller?: UserUpdateOneRequiredWithoutSellerNestedInput
    buyer?: UserUpdateOneRequiredWithoutBuyerNestedInput
    orders?: OrderUpdateOneWithoutSellerNestedInput
    options?: OptionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    sellerId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orders?: OrderUncheckedUpdateOneWithoutSellerNestedInput
    options?: OptionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type OrderCreateWithoutCartInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity: number
    buyerId: number
    deleted?: boolean | null
    seller: ShopCreateNestedOneWithoutOrdersInput
    buyer: UserCreateNestedOneWithoutOrderInput
    review?: ReviewCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCartInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity: number
    shopId: number
    buyerId: number
    sellerId: number
    deleted?: boolean | null
    review?: ReviewUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCartInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCartInput, OrderUncheckedCreateWithoutCartInput>
  }

  export type OrderCreateManyCartInputEnvelope = {
    data: OrderCreateManyCartInput | OrderCreateManyCartInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutCartInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCartInput, OrderUncheckedUpdateWithoutCartInput>
    create: XOR<OrderCreateWithoutCartInput, OrderUncheckedCreateWithoutCartInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCartInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCartInput, OrderUncheckedUpdateWithoutCartInput>
  }

  export type OrderUpdateManyWithWhereWithoutCartInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCartInput>
  }

  export type BusinessAccCreateManyUserInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    businessName: string
    businessUserName?: string | null
    businessAvatar?: string | null
    businessAddress?: string | null
    vatId: string
    businessType?: $Enums.BusinessType
    taxType?: $Enums.taxType
    memberId?: string | null
  }

  export type MemberCreateManyUserInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessId?: number | null
  }

  export type PostCreateManyAuthorInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hashtag?: PostCreatehashtagInput | string[]
    content?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.MediaType | null
    published?: boolean
    deleted?: boolean | null
  }

  export type CommentCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    postId: number
    deleted?: boolean | null
  }

  export type ReactionCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ReactionType
    postId: number
  }

  export type InboxCreateManySenderInput = {
    id?: number
    receiverId: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    unsent?: boolean
    deleted?: boolean | null
  }

  export type InboxCreateManyReceiverInput = {
    id?: number
    senderId: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    unsent?: boolean
    deleted?: boolean | null
  }

  export type ShopCreateManySellerInput = {
    id?: number
    name: string
    description?: string | null
    productType?: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: $Enums.Category
    buyerId: number
    deleted?: boolean | null
  }

  export type ShopCreateManyBuyerInput = {
    id?: number
    name: string
    description?: string | null
    productType?: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: $Enums.Category
    sellerId: number
    deleted?: boolean | null
  }

  export type OrderCreateManyBuyerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity: number
    shopId: number
    buyerId: number
    deleted?: boolean | null
  }

  export type ReviewCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    rating: number
    shopId: number
    orderId: number
  }

  export type CreditCreateManyOwnerInput = {
    id?: number
    createdAt?: Date | string
    creditorId: number
  }

  export type CreditCreateManyCreditorInput = {
    id?: number
    createdAt?: Date | string
    ownerId: number
  }

  export type BusinessAccUpdateWithoutUserInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    AllMember?: MemberUpdateManyWithoutBusinessNestedInput
    billRecord?: BillUpdateManyWithoutBusinessIdNestedInput
    expenseRecord?: ExpenseUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUpdateManyWithoutBusinessIdNestedInput
  }

  export type BusinessAccUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    AllMember?: MemberUncheckedUpdateManyWithoutBusinessNestedInput
    billRecord?: BillUncheckedUpdateManyWithoutBusinessIdNestedInput
    expenseRecord?: ExpenseUncheckedUpdateManyWithoutBusinessIdNestedInput
    adsCostRecord?: AdsCostUncheckedUpdateManyWithoutBusinessIdNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutBusinessIdNestedInput
    storefront?: StoreUncheckedUpdateManyWithoutBusinessIdNestedInput
    product?: ProductUncheckedUpdateManyWithoutBusinessIdNestedInput
  }

  export type BusinessAccUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: StringFieldUpdateOperationsInput | string
    businessUserName?: NullableStringFieldUpdateOperationsInput | string | null
    businessAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: StringFieldUpdateOperationsInput | string
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    taxType?: EnumtaxTypeFieldUpdateOperationsInput | $Enums.taxType
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberUpdateWithoutUserInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessAccUpdateOneWithoutAllMemberNestedInput
    bill?: BillUpdateManyWithoutMemberNestedInput
    adsCost?: AdsCostUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUpdateManyWithoutMemberNestedInput
    product?: ProductUpdateManyWithoutMemberNestedInput
    platform?: PlatformUpdateManyWithoutMemberNestedInput
    store?: StoreUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutUserInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableIntFieldUpdateOperationsInput | number | null
    bill?: BillUncheckedUpdateManyWithoutMemberNestedInput
    adsCost?: AdsCostUncheckedUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutMemberNestedInput
    product?: ProductUncheckedUpdateManyWithoutMemberNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutMemberNestedInput
    store?: StoreUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutUserInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PostUpdateWithoutAuthorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtag?: PostUpdatehashtagInput | string[]
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    published?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtag?: PostUpdatehashtagInput | string[]
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    published?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtag?: PostUpdatehashtagInput | string[]
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType | null
    published?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CommentUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ReactionUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    post?: PostUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type ReactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type ReactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type InboxUpdateWithoutSenderInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    unsent?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type InboxUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    unsent?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type InboxUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    unsent?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type InboxUpdateWithoutReceiverInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    unsent?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type InboxUncheckedUpdateWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    unsent?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type InboxUncheckedUpdateManyWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    unsent?: BoolFieldUpdateOperationsInput | boolean
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ShopUpdateWithoutSellerInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    buyer?: UserUpdateOneRequiredWithoutBuyerNestedInput
    orders?: OrderUpdateOneWithoutSellerNestedInput
    options?: OptionUpdateManyWithoutShopNestedInput
    review?: ReviewUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutSellerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    buyerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orders?: OrderUncheckedUpdateOneWithoutSellerNestedInput
    options?: OptionUncheckedUpdateManyWithoutShopNestedInput
    review?: ReviewUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateManyWithoutSellerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    buyerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ShopUpdateWithoutBuyerInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seller?: UserUpdateOneRequiredWithoutSellerNestedInput
    orders?: OrderUpdateOneWithoutSellerNestedInput
    options?: OptionUpdateManyWithoutShopNestedInput
    review?: ReviewUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutBuyerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    sellerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orders?: OrderUncheckedUpdateOneWithoutSellerNestedInput
    options?: OptionUncheckedUpdateManyWithoutShopNestedInput
    review?: ReviewUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateManyWithoutBuyerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    sellerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OrderUpdateWithoutBuyerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seller?: ShopUpdateOneRequiredWithoutOrdersNestedInput
    review?: ReviewUpdateOneWithoutOrderNestedInput
    cart?: CartUpdateOneRequiredWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutBuyerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    review?: ReviewUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutBuyerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ReviewUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutReviewNestedInput
    shop?: ShopUpdateOneRequiredWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type CreditUpdateWithoutOwnerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditor?: UserUpdateOneRequiredWithoutCreditNestedInput
  }

  export type CreditUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditorId?: IntFieldUpdateOperationsInput | number
  }

  export type CreditUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditorId?: IntFieldUpdateOperationsInput | number
  }

  export type CreditUpdateWithoutCreditorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnerNestedInput
  }

  export type CreditUncheckedUpdateWithoutCreditorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
  }

  export type CreditUncheckedUpdateManyWithoutCreditorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
  }

  export type BillCreateManyMemberInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cName: string
    cLastName?: string | null
    cPhone?: string | null
    cGender?: $Enums.Gender | null
    cAddress?: string | null
    cProvince?: string | null
    cPostId?: string | null
    product: string
    payment: $Enums.Payment
    amount: number
    purchaseAt?: Date | string
    platform: $Enums.IncomeChannel
    cashStatus?: boolean
    price: number
    image?: string | null
    deleted?: boolean | null
    businessAcc: number
    storeId: number
  }

  export type AdsCostCreateManyMemberInput = {
    id?: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    adsCost: Decimal | DecimalJsLike | number | string
    platformId: number
    product: string
    businessAcc: number
  }

  export type ExpenseCreateManyMemberInput = {
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    group?: string | null
    image?: string | null
    note?: string | null
    desc?: string | null
    deleted?: boolean | null
    save?: boolean | null
    channel?: $Enums.Bank | null
    code?: string | null
    businessAcc: number
  }

  export type ProductCreateManyMemberInput = {
    id?: number
    name: string
    description?: string | null
    barcode: string
    image?: string | null
    stock: number
    price: number
    categoryId?: number | null
    statusId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
    businessAcc: number
  }

  export type PlatformCreateManyMemberInput = {
    id?: number
    platform: $Enums.SocialMedia
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessAcc: number
    deleted?: boolean | null
  }

  export type StoreCreateManyMemberInput = {
    id?: number
    platform: $Enums.IncomeChannel
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessAcc: number
    deleted?: boolean | null
  }

  export type BillUpdateWithoutMemberInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    productList?: ProductUpdateOneRequiredWithoutBillRecordNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutBillRecordNestedInput
    store?: StoreUpdateOneRequiredWithoutStorefrontIdNestedInput
  }

  export type BillUncheckedUpdateWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    product?: StringFieldUpdateOperationsInput | string
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    businessAcc?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type BillUncheckedUpdateManyWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    product?: StringFieldUpdateOperationsInput | string
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    businessAcc?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type AdsCostUpdateWithoutMemberInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platform?: PlatformUpdateOneRequiredWithoutPlatformIdNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutAdsCostRecordNestedInput
    productList?: ProductUpdateOneRequiredWithoutAdsRecordNestedInput
  }

  export type AdsCostUncheckedUpdateWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    businessAcc?: IntFieldUpdateOperationsInput | number
  }

  export type AdsCostUncheckedUpdateManyWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    businessAcc?: IntFieldUpdateOperationsInput | number
  }

  export type ExpenseUpdateWithoutMemberInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    save?: NullableBoolFieldUpdateOperationsInput | boolean | null
    channel?: NullableEnumBankFieldUpdateOperationsInput | $Enums.Bank | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: BusinessAccUpdateOneRequiredWithoutExpenseRecordNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutMemberInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    save?: NullableBoolFieldUpdateOperationsInput | boolean | null
    channel?: NullableEnumBankFieldUpdateOperationsInput | $Enums.Bank | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    businessAcc?: IntFieldUpdateOperationsInput | number
  }

  export type ExpenseUncheckedUpdateManyWithoutMemberInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    save?: NullableBoolFieldUpdateOperationsInput | boolean | null
    channel?: NullableEnumBankFieldUpdateOperationsInput | $Enums.Bank | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    businessAcc?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpdateWithoutMemberInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    billRecord?: BillUpdateManyWithoutProductListNestedInput
    adsRecord?: AdsCostUpdateManyWithoutProductListNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    businessAcc?: IntFieldUpdateOperationsInput | number
    billRecord?: BillUncheckedUpdateManyWithoutProductListNestedInput
    adsRecord?: AdsCostUncheckedUpdateManyWithoutProductListNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    businessAcc?: IntFieldUpdateOperationsInput | number
  }

  export type PlatformUpdateWithoutMemberInput = {
    platform?: EnumSocialMediaFieldUpdateOperationsInput | $Enums.SocialMedia
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    platformId?: AdsCostUpdateManyWithoutPlatformNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutPlatformNestedInput
  }

  export type PlatformUncheckedUpdateWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumSocialMediaFieldUpdateOperationsInput | $Enums.SocialMedia
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessAcc?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    platformId?: AdsCostUncheckedUpdateManyWithoutPlatformNestedInput
  }

  export type PlatformUncheckedUpdateManyWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumSocialMediaFieldUpdateOperationsInput | $Enums.SocialMedia
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessAcc?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StoreUpdateWithoutMemberInput = {
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storefrontId?: BillUpdateManyWithoutStoreNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutStorefrontNestedInput
  }

  export type StoreUncheckedUpdateWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessAcc?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storefrontId?: BillUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateManyWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessAcc?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type MemberCreateManyBusinessInput = {
    uniqueId?: string
    role?: $Enums.UserRole
    permission: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
  }

  export type BillCreateManyBusinessIdInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cName: string
    cLastName?: string | null
    cPhone?: string | null
    cGender?: $Enums.Gender | null
    cAddress?: string | null
    cProvince?: string | null
    cPostId?: string | null
    product: string
    payment: $Enums.Payment
    amount: number
    purchaseAt?: Date | string
    platform: $Enums.IncomeChannel
    cashStatus?: boolean
    price: number
    image?: string | null
    deleted?: boolean | null
    memberId: string
    storeId: number
  }

  export type ExpenseCreateManyBusinessIdInput = {
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    group?: string | null
    image?: string | null
    note?: string | null
    desc?: string | null
    deleted?: boolean | null
    save?: boolean | null
    channel?: $Enums.Bank | null
    code?: string | null
    memberId: string
  }

  export type AdsCostCreateManyBusinessIdInput = {
    id?: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    adsCost: Decimal | DecimalJsLike | number | string
    memberId: string
    platformId: number
    product: string
  }

  export type PlatformCreateManyBusinessIdInput = {
    id?: number
    platform: $Enums.SocialMedia
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    memberId: string
    deleted?: boolean | null
  }

  export type StoreCreateManyBusinessIdInput = {
    id?: number
    platform: $Enums.IncomeChannel
    accName: string
    accId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    memberId: string
    deleted?: boolean | null
  }

  export type ProductCreateManyBusinessIdInput = {
    id?: number
    name: string
    description?: string | null
    barcode: string
    image?: string | null
    stock: number
    price: number
    categoryId?: number | null
    memberId: string
    statusId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean | null
  }

  export type MemberUpdateWithoutBusinessInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMemberNestedInput
    bill?: BillUpdateManyWithoutMemberNestedInput
    adsCost?: AdsCostUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUpdateManyWithoutMemberNestedInput
    product?: ProductUpdateManyWithoutMemberNestedInput
    platform?: PlatformUpdateManyWithoutMemberNestedInput
    store?: StoreUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutBusinessInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    bill?: BillUncheckedUpdateManyWithoutMemberNestedInput
    adsCost?: AdsCostUncheckedUpdateManyWithoutMemberNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutMemberNestedInput
    product?: ProductUncheckedUpdateManyWithoutMemberNestedInput
    platform?: PlatformUncheckedUpdateManyWithoutMemberNestedInput
    store?: StoreUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutBusinessInput = {
    uniqueId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type BillUpdateWithoutBusinessIdInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    productList?: ProductUpdateOneRequiredWithoutBillRecordNestedInput
    member?: MemberUpdateOneRequiredWithoutBillNestedInput
    store?: StoreUpdateOneRequiredWithoutStorefrontIdNestedInput
  }

  export type BillUncheckedUpdateWithoutBusinessIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    product?: StringFieldUpdateOperationsInput | string
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    memberId?: StringFieldUpdateOperationsInput | string
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type BillUncheckedUpdateManyWithoutBusinessIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    product?: StringFieldUpdateOperationsInput | string
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    memberId?: StringFieldUpdateOperationsInput | string
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type ExpenseUpdateWithoutBusinessIdInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    save?: NullableBoolFieldUpdateOperationsInput | boolean | null
    channel?: NullableEnumBankFieldUpdateOperationsInput | $Enums.Bank | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    member?: MemberUpdateOneRequiredWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutBusinessIdInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    save?: NullableBoolFieldUpdateOperationsInput | boolean | null
    channel?: NullableEnumBankFieldUpdateOperationsInput | $Enums.Bank | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseUncheckedUpdateManyWithoutBusinessIdInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    save?: NullableBoolFieldUpdateOperationsInput | boolean | null
    channel?: NullableEnumBankFieldUpdateOperationsInput | $Enums.Bank | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type AdsCostUpdateWithoutBusinessIdInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    member?: MemberUpdateOneRequiredWithoutAdsCostNestedInput
    platform?: PlatformUpdateOneRequiredWithoutPlatformIdNestedInput
    productList?: ProductUpdateOneRequiredWithoutAdsRecordNestedInput
  }

  export type AdsCostUncheckedUpdateWithoutBusinessIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    memberId?: StringFieldUpdateOperationsInput | string
    platformId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
  }

  export type AdsCostUncheckedUpdateManyWithoutBusinessIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    memberId?: StringFieldUpdateOperationsInput | string
    platformId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
  }

  export type PlatformUpdateWithoutBusinessIdInput = {
    platform?: EnumSocialMediaFieldUpdateOperationsInput | $Enums.SocialMedia
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    platformId?: AdsCostUpdateManyWithoutPlatformNestedInput
    member?: MemberUpdateOneRequiredWithoutPlatformNestedInput
  }

  export type PlatformUncheckedUpdateWithoutBusinessIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumSocialMediaFieldUpdateOperationsInput | $Enums.SocialMedia
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    platformId?: AdsCostUncheckedUpdateManyWithoutPlatformNestedInput
  }

  export type PlatformUncheckedUpdateManyWithoutBusinessIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumSocialMediaFieldUpdateOperationsInput | $Enums.SocialMedia
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StoreUpdateWithoutBusinessIdInput = {
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storefrontId?: BillUpdateManyWithoutStoreNestedInput
    member?: MemberUpdateOneRequiredWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutBusinessIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storefrontId?: BillUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateManyWithoutBusinessIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    accName?: StringFieldUpdateOperationsInput | string
    accId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ProductUpdateWithoutBusinessIdInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    billRecord?: BillUpdateManyWithoutProductListNestedInput
    adsRecord?: AdsCostUpdateManyWithoutProductListNestedInput
    member?: MemberUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBusinessIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    memberId?: StringFieldUpdateOperationsInput | string
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    billRecord?: BillUncheckedUpdateManyWithoutProductListNestedInput
    adsRecord?: AdsCostUncheckedUpdateManyWithoutProductListNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBusinessIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    memberId?: StringFieldUpdateOperationsInput | string
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AdsCostCreateManyPlatformInput = {
    id?: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    adsCost: Decimal | DecimalJsLike | number | string
    memberId: string
    product: string
    businessAcc: number
  }

  export type AdsCostUpdateWithoutPlatformInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    member?: MemberUpdateOneRequiredWithoutAdsCostNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutAdsCostRecordNestedInput
    productList?: ProductUpdateOneRequiredWithoutAdsRecordNestedInput
  }

  export type AdsCostUncheckedUpdateWithoutPlatformInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    memberId?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    businessAcc?: IntFieldUpdateOperationsInput | number
  }

  export type AdsCostUncheckedUpdateManyWithoutPlatformInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    memberId?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    businessAcc?: IntFieldUpdateOperationsInput | number
  }

  export type BillCreateManyStoreInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cName: string
    cLastName?: string | null
    cPhone?: string | null
    cGender?: $Enums.Gender | null
    cAddress?: string | null
    cProvince?: string | null
    cPostId?: string | null
    product: string
    payment: $Enums.Payment
    amount: number
    purchaseAt?: Date | string
    platform: $Enums.IncomeChannel
    cashStatus?: boolean
    price: number
    image?: string | null
    deleted?: boolean | null
    memberId: string
    businessAcc: number
  }

  export type BillUpdateWithoutStoreInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    productList?: ProductUpdateOneRequiredWithoutBillRecordNestedInput
    member?: MemberUpdateOneRequiredWithoutBillNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutBillRecordNestedInput
  }

  export type BillUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    product?: StringFieldUpdateOperationsInput | string
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    memberId?: StringFieldUpdateOperationsInput | string
    businessAcc?: IntFieldUpdateOperationsInput | number
  }

  export type BillUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    product?: StringFieldUpdateOperationsInput | string
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    memberId?: StringFieldUpdateOperationsInput | string
    businessAcc?: IntFieldUpdateOperationsInput | number
  }

  export type BillCreateManyProductListInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cName: string
    cLastName?: string | null
    cPhone?: string | null
    cGender?: $Enums.Gender | null
    cAddress?: string | null
    cProvince?: string | null
    cPostId?: string | null
    payment: $Enums.Payment
    amount: number
    purchaseAt?: Date | string
    platform: $Enums.IncomeChannel
    cashStatus?: boolean
    price: number
    image?: string | null
    deleted?: boolean | null
    memberId: string
    businessAcc: number
    storeId: number
  }

  export type AdsCostCreateManyProductListInput = {
    id?: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    adsCost: Decimal | DecimalJsLike | number | string
    memberId: string
    platformId: number
    businessAcc: number
  }

  export type BillUpdateWithoutProductListInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    member?: MemberUpdateOneRequiredWithoutBillNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutBillRecordNestedInput
    store?: StoreUpdateOneRequiredWithoutStorefrontIdNestedInput
  }

  export type BillUncheckedUpdateWithoutProductListInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    memberId?: StringFieldUpdateOperationsInput | string
    businessAcc?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type BillUncheckedUpdateManyWithoutProductListInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cName?: StringFieldUpdateOperationsInput | string
    cLastName?: NullableStringFieldUpdateOperationsInput | string | null
    cPhone?: NullableStringFieldUpdateOperationsInput | string | null
    cGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    cAddress?: NullableStringFieldUpdateOperationsInput | string | null
    cProvince?: NullableStringFieldUpdateOperationsInput | string | null
    cPostId?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    amount?: IntFieldUpdateOperationsInput | number
    purchaseAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: EnumIncomeChannelFieldUpdateOperationsInput | $Enums.IncomeChannel
    cashStatus?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    memberId?: StringFieldUpdateOperationsInput | string
    businessAcc?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type AdsCostUpdateWithoutProductListInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    member?: MemberUpdateOneRequiredWithoutAdsCostNestedInput
    platform?: PlatformUpdateOneRequiredWithoutPlatformIdNestedInput
    businessId?: BusinessAccUpdateOneRequiredWithoutAdsCostRecordNestedInput
  }

  export type AdsCostUncheckedUpdateWithoutProductListInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    memberId?: StringFieldUpdateOperationsInput | string
    platformId?: IntFieldUpdateOperationsInput | number
    businessAcc?: IntFieldUpdateOperationsInput | number
  }

  export type AdsCostUncheckedUpdateManyWithoutProductListInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    memberId?: StringFieldUpdateOperationsInput | string
    platformId?: IntFieldUpdateOperationsInput | number
    businessAcc?: IntFieldUpdateOperationsInput | number
  }

  export type ReactionCreateManyPostInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ReactionType
    userId: number
  }

  export type CommentCreateManyPostInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    userId: number
    deleted?: boolean | null
  }

  export type ReactionUpdateWithoutPostInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    user?: UserUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type ReactionUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ReactionUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUpdateWithoutPostInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OptionCreateManyShopInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: $Enums.OptionName
  }

  export type ReviewCreateManyShopInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    rating: number
    userId: number
    orderId: number
  }

  export type OptionUpdateWithoutShopInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: EnumOptionNameFieldUpdateOperationsInput | $Enums.OptionName
    values?: OptionValueUpdateManyWithoutOptionNestedInput
  }

  export type OptionUncheckedUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: EnumOptionNameFieldUpdateOperationsInput | $Enums.OptionName
    values?: OptionValueUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type OptionUncheckedUpdateManyWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: EnumOptionNameFieldUpdateOperationsInput | $Enums.OptionName
  }

  export type ReviewUpdateWithoutShopInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutReviewNestedInput
    user?: UserUpdateOneRequiredWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUncheckedUpdateManyWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type OptionValueCreateManyOptionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    value: string
    price?: number | null
    interest?: number | null
    duration?: number | null
  }

  export type OptionValueUpdateWithoutOptionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    interest?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OptionValueUncheckedUpdateWithoutOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    interest?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OptionValueUncheckedUpdateManyWithoutOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    interest?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderCreateManyCartInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity: number
    shopId: number
    buyerId: number
    sellerId: number
    deleted?: boolean | null
  }

  export type OrderUpdateWithoutCartInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seller?: ShopUpdateOneRequiredWithoutOrdersNestedInput
    buyer?: UserUpdateOneRequiredWithoutOrderNestedInput
    review?: ReviewUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCartInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    review?: ReviewUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCartInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}